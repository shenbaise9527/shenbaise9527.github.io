<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 深白色9527</title>
		<link>https://shenbaise9527.com/posts/</link>
		<description>Recent content in Posts on 深白色9527</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 10 Dec 2020 21:35:42 +0800</lastBuildDate>
		<atom:link href="https://shenbaise9527.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Zipkin指南</title>
			<link>https://shenbaise9527.com/posts/zipkin%E6%8C%87%E5%8D%97/</link>
			<pubDate>Thu, 10 Dec 2020 21:35:42 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/zipkin%E6%8C%87%E5%8D%97/</guid>
			<description>快速启动 可以通过http://your_host:9411去访问zipkin UI. Docker docker run -d -p 9411:9411 openzipkin/zipkin Java 需要Java8或更高版本. curl -sSL https://zipkin.io/quickstart.sh | bash -s java -jar zipkin.jar Source</description>
			<content type="html"><![CDATA[<h2 id="快速启动">快速启动</h2>
<p>可以通过<code>http://your_host:9411</code>去访问zipkin UI.</p>
<p><strong>Docker</strong>
<code>docker run -d -p 9411:9411 openzipkin/zipkin</code></p>
<p><strong>Java</strong>
需要Java8或更高版本.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">curl -sSL https://zipkin.io/quickstart.sh <span class="p">|</span> bash -s
java -jar zipkin.jar
</code></pre></div><p><strong>Source</strong>
可以通过源码来安装并运行.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># get the latest source</span>
git clone https://github.com/openzipkin/zipkin
<span class="nb">cd</span> zipkin
<span class="c1"># Build the server and also make its dependencies</span>
./mvnw -DskipTests --also-make -pl zipkin-server clean install
<span class="c1"># Run the server</span>
java -jar ./zipkin-server/target/zipkin-server-*exec.jar
</code></pre></div><h2 id="架构">架构</h2>
<p>整体架构如下图所示(来源于<a href="https://zipkin.io/pages/architecture.html">官网</a>):
<img src="/images/zk-architecture-1.png" alt="架构" title="架构图"></p>
<p>zipkin已支持的平台和语言<a href="https://zipkin.io/pages/tracers_instrumentation">列表</a>.</p>
<h2 id="流程示例">流程示例</h2>
<p>标示符会在服务之间传播,而详细信息会被发送到zipkin.在这两种情况下,追踪库都负责创建有效的追踪并呈现它们.追踪库会确保两种数据之间保持奇偶校验一致性.</p>
<p>下面是http追踪的示例,其中用户代码调用了资源<code>/foo</code>.这是一个单独的<code>Span</code>,在用户代码收到响应后会被异步发送到zipkin中.</p>
<pre><code>┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐
│ User Code   │ │ Trace Instrumentation │  │ Http Client │  │ Zipkin Collector │
└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘
       │                 │                         │                 │
           ┌─────────┐
       │ ──┤GET /foo ├─▶ │ ────┐                   │                 │
           └─────────┘         │ record tags
       │                 │ ◀───┘                   │                 │
                           ────┐
       │                 │     │ add trace headers │                 │
                           ◀───┘
       │                 │ ────┐                   │                 │
                               │ record timestamp
       │                 │ ◀───┘                   │                 │
                             ┌─────────────────┐
       │                 │ ──┤GET /foo         ├─▶ │                 │
                             │X-B3-TraceId: aa │     ────┐
       │                 │   │X-B3-SpanId: 6b  │   │     │           │
                             └─────────────────┘         │ invoke
       │                 │                         │     │ request   │
                                                         │
       │                 │                         │     │           │
                                 ┌────────┐          ◀───┘
       │                 │ ◀─────┤200 OK  ├─────── │                 │
                           ────┐ └────────┘
       │                 │     │ record duration   │                 │
            ┌────────┐     ◀───┘
       │ ◀──┤200 OK  ├── │                         │                 │
            └────────┘       ┌────────────────────────────────┐
       │                 │ ──┤ asynchronously report span     ├────▶ │
                             │                                │
                             │{                               │
                             │  &quot;traceId&quot;: &quot;aa&quot;,              │
                             │  &quot;id&quot;: &quot;6b&quot;,                   │
                             │  &quot;name&quot;: &quot;get&quot;,                │
                             │  &quot;timestamp&quot;: 1483945573944000,│
                             │  &quot;duration&quot;: 386000,           │
                             │  &quot;annotations&quot;: [              │
                             │--snip--                        │
                             └────────────────────────────────┘
</code></pre><p>追踪库会异步发送<code>Span</code>,是为了防止与追踪系统有关的延迟或故障导致用户代码的延迟或破坏.</p>
<h2 id="transport">Transport</h2>
<p>追踪库发送<code>Span</code>时,必须要从被追踪系统传输到Zipkin的collectors组件.目前主要有三种方式传输:HTTP,kafka和Scribe.</p>
<h2 id="组件">组件</h2>
<p>主要包含四个组件:</p>
<ul>
<li>collector</li>
<li>storage</li>
<li>query service</li>
<li>web UI</li>
</ul>
<h3 id="collector">Collector</h3>
<p>当数据到达zipkin的收集器守护程序后,将对其进行验证、存储及索引,供zipkin收集器进行查找.</p>
<p><strong>HTTP</strong>
默认HTTP方式是可用的,URI为<code>POST /api/v1/spans</code>和<code>POST /api/v2/spans</code>,目前主要使用v2版本.支持如下配置项:</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">环境变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zipkin.collector.http.enabled</td>
<td style="text-align:left">COLLECTOR_HTTP_ENABLED</td>
<td style="text-align:left"><code>false</code>禁用HTTP方式,默认为<code>true</code></td>
</tr>
</tbody>
</table>
<p><strong>Kafka</strong>
当参数<code>KAFKA_BOOTSTRAP_SERVERS</code>设置为v0.10+版本的Kafka时,该收集器就会启用.支持如下配置项:</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">新Consumer配置</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">COLLECTOR_KAFKA_ENABLED</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><code>false</code>禁用Kafka收集器,默认为<code>true</code></td>
</tr>
<tr>
<td style="text-align:left">KAFKA_BOOTSTRAP_SERVERS</td>
<td style="text-align:left">bootstrap.servers</td>
<td style="text-align:left">以逗号分隔的broker地址,如127.0.0.1:9092.没有默认值</td>
</tr>
<tr>
<td style="text-align:left">KAFKA_GROUP_ID</td>
<td style="text-align:left">group.id</td>
<td style="text-align:left">此过程代表的消费组.默认为zipkin</td>
</tr>
<tr>
<td style="text-align:left">KAFKA_TOPIC</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">以逗号分隔的topic列表,默认为zipkin</td>
</tr>
<tr>
<td style="text-align:left">KAFKA_STREAMS</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">消费topic的线程数,默认为1</td>
</tr>
</tbody>
</table>
<p>启动命令:<code>KAFKA_BOOTSTRAP_SERVERS=127.0.0.1:9092 java -jar zipkin.jar</code></p>
<p>也可以设置其它<a href="https://kafka.apache.org/documentation/#newconsumerconfigs">Kafka的conusmer属性</a></p>
<p>举例:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 容器方式启动kafka</span>
$ <span class="nb">export</span> <span class="nv">KAFKA_BOOTSTRAP_SERVERS</span><span class="o">=</span><span class="k">$(</span>docker-machine ip <span class="sb">`</span>docker-machine active<span class="sb">`</span><span class="k">)</span>
<span class="c1"># Run Kafka in the background</span>
$ docker run -d -p 9092:9092 <span class="se">\
</span><span class="se"></span>    --env <span class="nv">ADVERTISED_HOST</span><span class="o">=</span><span class="nv">$KAFKA_BOOTSTRAP_SERVERS</span> <span class="se">\
</span><span class="se"></span>    --env <span class="nv">AUTO_CREATE_TOPICS</span><span class="o">=</span><span class="nb">true</span> <span class="se">\
</span><span class="se"></span>    spotify/kafka
<span class="c1"># Start the zipkin server, which reads $KAFKA_BOOTSTRAP_SERVERS</span>
$ java -jar zipkin.jar

<span class="c1"># 设置多个broker地址</span>
$ <span class="nv">KAFKA_BOOTSTRAP_SERVERS</span><span class="o">=</span>broker1.local:9092,broker2.local:9092 java -jar zipkin.jar

<span class="c1"># 备用topic名称</span>
$ <span class="nv">KAFKA_BOOTSTRAP_SERVERS</span><span class="o">=</span>127.0.0.1:9092 java -Dzipkin.collector.kafka.topic<span class="o">=</span>zapkin,zipken -jar zipkin.jar

<span class="c1"># 使用系统属性取代环境变量KAFKA_BOOTSTRAP_SERVERS.</span>
$ java -Dzipkin.collector.kafka.bootstrap-servers<span class="o">=</span>127.0.0.1:9092 -jar zipkin.jar
</code></pre></div><p><strong>RabbitMQ</strong>
支持如下配置项:</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">环境变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.concurrency</td>
<td style="text-align:left">RABBIT_CONCURRENCY</td>
<td style="text-align:left">当前消费者数量,默认为1</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.connection-timeout</td>
<td style="text-align:left">RABBIT_CONNECTION_TIMEOUT</td>
<td style="text-align:left">等待建立连接的超时时间,单位为毫秒,默认为60000(1分钟)</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.queue</td>
<td style="text-align:left">RABBIT_QUEUE</td>
<td style="text-align:left">队列名称,默认为zipkin</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.uri</td>
<td style="text-align:left">RABBIT_URI</td>
<td style="text-align:left">rabbitmq完整的uri,如:<code>amqp://user:pass@host:10000/vhost</code></td>
</tr>
<tr>
<td style="text-align:left">如果uri被设置了,下面的配置项将会被忽略:</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">环境变量</td>
<td style="text-align:left">描述</td>
</tr>
<tr>
<td style="text-align:left">:&ndash;</td>
<td style="text-align:left">:&ndash;</td>
<td style="text-align:left">:&ndash;</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.addresses</td>
<td style="text-align:left">RABBIT_ADDRESSES</td>
<td style="text-align:left">逗号分隔的rabbitmq地址,如:<code>localhost:5672,localhost:5673</code></td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.password</td>
<td style="text-align:left">RABBIT_PASSWORD</td>
<td style="text-align:left">连接rabbitmq的密码,默认为guest</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.username</td>
<td style="text-align:left">RABBIT_USER</td>
<td style="text-align:left">连接rabbitmq的用户名,默认为guest</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.virtual-host</td>
<td style="text-align:left">RABBIT_VIRTUAL_HOST</td>
<td style="text-align:left">rabbitmq的虚拟主机名,默认为<code>/</code></td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.rabbitmq.use-ssl</td>
<td style="text-align:left">RABBIT_USE_SSL</td>
<td style="text-align:left">设置为<code>true</code>,表示使用ssl连接到rabbitmq</td>
</tr>
</tbody>
</table>
<p>队列会被申明为持久化的,收集器使用单个conn连接到rabbitmq,通过配置的<code>concurrency</code>数量的线程(每个线程一个channel)来消费消息.消费消息时<code>autoAck</code>设置为<code>on</code>了,表示消费者收到消息后rabbitmq就会在队列中自动删除该消息,若消费者出现异常是不能再重复消费该消息的.</p>
<p>启动命令:<code>RABBIT_ADDRESSES=localhost java -jar zipkin.jar</code></p>
<p><strong>ActiveMQ</strong>
支持ActiveMQ v5.x版本.</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">环境变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zipkin.collector.activemq.enabled</td>
<td style="text-align:left">COLLECTOR_ACTIVEMQ_ENABLED</td>
<td style="text-align:left"><code>false</code>表示禁用该收集器,默认为<code>true</code></td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.url</td>
<td style="text-align:left">ACTIVEMQ_URL</td>
<td style="text-align:left">ActiveMQ broker地址,如:tcp://localhost:61616或者故障转移:(tcp://localhost:61616,tcp://remotehost:61616)</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.queue</td>
<td style="text-align:left">ACTIVEMQ_QUEUE</td>
<td style="text-align:left">队列名,默认为zipkin</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.client-id-prefix</td>
<td style="text-align:left">ACTIVEMQ_CLIENT_ID_PREFIX</td>
<td style="text-align:left">消费者的客户端ID的前缀,默认为zipkin</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.concurrency</td>
<td style="text-align:left">ACTIVEMQ_CONCURRENCY</td>
<td style="text-align:left">消费者数量,默认为1</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.username</td>
<td style="text-align:left">ACTIVEMQ_USERNAME</td>
<td style="text-align:left">连接到ActiveMQ时的用户名,可选</td>
</tr>
<tr>
<td style="text-align:left">zipkin.collector.activemq.password</td>
<td style="text-align:left">ACTIVEMQ_PASSWORD</td>
<td style="text-align:left">连接到ActiveMQ时的密码,可选</td>
</tr>
</tbody>
</table>
<p>启动命令:<code>ACTIVEMQ_URL=tcp://localhost:61616 java -jar zipkin.jar</code></p>
<h3 id="storage">Storage</h3>
<p>存储组件是采用插件化的方式实现,目前支持InMemory、Cassandra、ElasticSearch和MySQL,还有其它第三方实现的.</p>
<p><strong>InMemory</strong>
默认启动的就是In-Memory方式,所有数据全部保存在内存中,没有持久化功能.
启动方式:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 默认启动方式</span>
java -jar zipkin.jar

<span class="c1"># 指定STORAGE_TYPE为mem</span>
<span class="nv">STORAGE_TYPE</span><span class="o">=</span>mem java -jar zipkin.jar
</code></pre></div><p>提供了参数<code>MEM_MAX_SPANS</code>来控制<code>Span</code>占用的内存大小.当碰到<code>out-of-memory</code>错误时,可以增大该参数或者调整堆大小(-Xmx).</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="sb">`</span>MEM_MAX_SPANS<span class="sb">`</span>: Oldest traces <span class="o">(</span>and their spans<span class="o">)</span> will be purged first when this limit is exceeded. Default <span class="m">500000</span>

<span class="c1"># 调整内存大小.</span>
<span class="nv">MEM_MAX_SPANS</span><span class="o">=</span><span class="m">1000000</span> java -Xmx1G -jar zipkin.jar
</code></pre></div><p><strong>MySQL</strong>
基于MySQL5.7版本,需要先建库建表,<a href="https://github.com/openzipkin/zipkin/tree/master/zipkin-storage/mysql-v1">脚本文件地址</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="o">#</span> <span class="n">install</span> <span class="n">the</span> <span class="k">schema</span> <span class="k">and</span> <span class="n">indexes</span>
<span class="err">$</span> <span class="n">mysql</span> <span class="o">-</span><span class="n">uroot</span> <span class="o">-</span><span class="n">e</span> <span class="s2">&#34;create database if not exists zipkin&#34;</span>
<span class="err">$</span> <span class="n">mysql</span> <span class="o">-</span><span class="n">uroot</span> <span class="o">-</span><span class="n">Dzipkin</span> <span class="o">&lt;</span> <span class="n">zipkin</span><span class="o">-</span><span class="k">storage</span><span class="o">/</span><span class="n">mysql</span><span class="o">-</span><span class="n">v1</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="o">/</span><span class="n">resources</span><span class="o">/</span><span class="n">mysql</span><span class="p">.</span><span class="k">sql</span>

<span class="o">#</span> <span class="err">根据</span><span class="n">trace</span> <span class="n">id来查询</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">zipkin_spans</span> <span class="k">where</span> <span class="n">trace_id</span> <span class="o">=</span> <span class="n">x</span><span class="s1">&#39;27960dafb1ea7454&#39;</span>
</code></pre></div><p>启动时可设置的相关参数</p>
<ul>
<li><code>MYSQL_DB</code>: The database to use. Defaults to &ldquo;zipkin&rdquo;.</li>
<li><code>MYSQL_USER</code> and <code>MYSQL_PASS</code>: MySQL authentication, which defaults to empty string.</li>
<li><code>MYSQL_HOST</code>: Defaults to localhost</li>
<li><code>MYSQL_TCP_PORT</code>: Defaults to 3306</li>
<li><code>MYSQL_MAX_CONNECTIONS</code>: Maximum concurrent connections, defaults to 10</li>
<li><code>MYSQL_USE_SSL</code>: Requires <code>javax.net.ssl.trustStore</code> and <code>javax.net.ssl.trustStorePassword</code>, defaults to false.</li>
</ul>
<p>启动命令:<code>STORAGE_TYPE=mysql MYSQL_USER=root java -jar zipkin.jar</code></p>
<p><strong>Cassandra</strong></p>
<p><strong>Elasticsearch</strong>
启动时可设置的相关参数</p>
<ul>
<li><code>ES_HOSTS</code>: A comma separated list of elasticsearch base urls to connect to ex. http://host:9200. Defaults to &ldquo;http://localhost:9200&rdquo;.</li>
<li><code>ES_PIPELINE</code>: Indicates the ingest pipeline used before spans are indexed. No default.</li>
<li><code>ES_TIMEOUT</code>: Controls the connect, read and write socket timeouts (in milliseconds) for Elasticsearch API. Defaults to 10000 (10 seconds)</li>
<li><code>ES_INDEX</code>: The index prefix to use when generating daily index names. Defaults to zipkin.</li>
<li><code>ES_DATE_SEPARATOR</code>: The date separator to use when generating daily index names. Defaults to &lsquo;-&rsquo;.</li>
<li><code>ES_INDEX_SHARDS</code>: The number of shards to split the index into. Each shard and its replicas are assigned to a machine in the cluster. Increasing the number of shards and machines in the cluster will improve read and write performance. Number of shards cannot be changed for existing indices, but new daily indices will pick up changes to the setting. Defaults to 5.</li>
<li><code>ES_INDEX_REPLICAS</code>: The number of replica copies of each shard in the index. Each shard and its replicas are assigned to a machine in the cluster. Increasing the number of replicas and machines in the cluster will improve read performance, but not write performance. Number of replicas can be changed for existing indices. Defaults to 1. It is highly discouraged to set this to 0 as it would mean a machine failure results in data loss.</li>
<li><code>ES_ENSURE_TEMPLATES</code>: Installs Zipkin index templates when missing. Setting this to false can lead to corrupted data when index templates mismatch expectations. If you set this to false, you choose to troubleshoot your own data or migration problems as opposed to relying on the community for this. Defaults to true.</li>
<li><code>ES_USERNAME</code> and <code>ES_PASSWORD</code>: Elasticsearch basic authentication, which defaults to empty string. Use when X-Pack security (formerly Shield) is in place.</li>
<li><code>ES_CREDENTIALS_FILE</code>: The location of a file containing Elasticsearch basic authentication credentials, as properties. The username property is <code>zipkin.storage.elasticsearch.username</code>, password <code>zipkin.storage.elasticsearch.password</code>.This file is reloaded periodically, using <code>ES_CREDENTIALS_REFRESH_INTERVAL</code> as the interval. This parameter takes precedence over ES_USERNAME and ES_PASSWORD when specified.</li>
<li><code>ES_CREDENTIALS_REFRESH_INTERVAL</code>: Credentials refresh interval in seconds, which defaults to 1 second. This is the maximum amount of time spans will drop due to stale credentials. Any errors reading the credentials file occur in logs at this rate.</li>
<li><code>ES_HTTP_LOGGING</code>: When set, controls the volume of HTTP logging of the Elasticsearch API. Options are BASIC, HEADERS, BODY</li>
<li><code>ES_SSL_NO_VERIFY</code>: When true, disables the verification of server&rsquo;s key certificate chain. This is not appropriate for production. Defaults to false.</li>
<li><code>ES_TEMPLATE_PRIORITY</code>: The priority value of the composable index templates. This is only applicable for ES version 7.8 or above. Must be set, even to 0, to use composable template</li>
</ul>
<p>启动命令:<code>STORAGE_TYPE=elasticsearch ES_HOSTS=http://myhost:9200 java -jar zipkin.jar</code></p>
<h3 id="query-service">Query Service</h3>
<p>查询服务提供简单的<code>JSON API</code>来查询和检索追踪信息,主要是供Web UI使用.</p>
<h3 id="web-ui">Web UI</h3>
<p>以网页的形式来展示追踪数据.</p>
<h2 id="客户端代码">客户端代码</h2>
<p>基于OpenTracing来使用zipkin,以<a href="https://golang.org">Golang</a>为例.
依赖于<a href="https://github.com/openzipkin/zipkin-go">zipkin-go</a>、<a href="https://github.com/openzipkin-contrib/zipkin-go-opentracing">zipkin-go-opentracing</a>和<a href="https://github.com/opentracing/opentracing-go">opentracing-go</a>这三个库.</p>
<h3 id="reporter接口">Reporter接口</h3>
<p>接口定义:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tracer依赖该接口来发送Span数据.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Reporter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Send</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">SpanModel</span><span class="p">)</span>
    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>具体实现:
<strong><a href="https://github.com/openzipkin/zipkin-go/blob/master/reporter/reporter.go">noopReporter</a></strong>
具体实现都是空的,不做任何处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建接口.
</span><span class="c1"></span><span class="nx">reporter</span> <span class="o">:=</span> <span class="nx">zipkin</span><span class="p">.</span><span class="nf">NewNoopReporter</span><span class="p">()</span>
</code></pre></div><p><strong><a href="https://github.com/openzipkin/zipkin-go/blob/master/reporter/http/http.go">httpReporter</a></strong>
基于HTTP协议来发送Span数据.</p>
<p>函数原型:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// url表示zipkin服务端接收数据的端点,如http://127.0.0.1:9411/api/v2/spans.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewReporter</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">ReporterOption</span><span class="p">)</span> <span class="nx">reporter</span><span class="p">.</span><span class="nx">Reporter</span>
</code></pre></div><p>采用了<code>Option</code>设计方式来对相关参数进行自定义处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置http的超时时间,默认为5秒.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Timeout</span><span class="p">(</span><span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置最大的待发送数量,当到达此阈值后就会触发收集操作,默认为100.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BatchSize</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置触发收集操作的时间间隔,默认为1秒.可见触发收集操作有两个因素,当间隔时间达到指定时间或者待发送数量超过batchsize,就会立即触发.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BatchInterval</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置最大的缓存数量,当超过此阈值,从队列开头到超出数量的Span将会被丢弃,默认为1000.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxBacklog</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置回调,在发送span到zipkin之前会被调用,默认为nil,回调定义是type RequestCallbackFn func(*http.Request).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RequestCallback</span><span class="p">(</span><span class="nx">rc</span> <span class="nx">RequestCallbackFn</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置日志对象,默认为Stderr
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Logger</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置span的序列化方式,默认实现的是json格式.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Serializer</span><span class="p">(</span><span class="nx">serializer</span> <span class="nx">reporter</span><span class="p">.</span><span class="nx">SpanSerializer</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置发送请求到zipkin收集器的方式,默认为http.Client.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Client</span><span class="p">(</span><span class="nx">client</span> <span class="nx">HTTPDoer</span><span class="p">)</span> <span class="nx">ReporterOption</span>
</code></pre></div><p><strong><a href="https://github.com/openzipkin/zipkin-go/blob/master/reporter/amqp/amqp.go">rmqReporter</a></strong>
把Span数据发送到<a href="https://www.rabbitmq.com/">rabbitmq</a>消息总线上.</p>
<p>函数原型:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// address表示rabbitmq的地址,如:amqp://guest:guest@localhost:5672/test
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewReporter</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">ReporterOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">reporter</span><span class="p">.</span><span class="nx">Reporter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>采用了<code>Option</code>设计方式来对相关参数进行自定义处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置日志对象,默认为Stderr
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Logger</span><span class="p">(</span><span class="nx">logger</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置rabbitmq中交换器的名字,默认为zipkin.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Exchange</span><span class="p">(</span><span class="nx">exchange</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置rabbitmq队列的名字,默认为zipkin.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Queue</span><span class="p">(</span><span class="nx">queue</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置channel通道对象,默认为nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Channel</span><span class="p">(</span><span class="nx">ch</span> <span class="o">*</span><span class="nx">amqp</span><span class="p">.</span><span class="nx">Channel</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置与rabbitmq连接的对象,默认为nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Connection</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">amqp</span><span class="p">.</span><span class="nx">Connection</span><span class="p">)</span> <span class="nx">ReporterOption</span>
</code></pre></div><p>rabbitmq的交换器类型默认为<code>direct</code>,交换器和队列默认都是持久化的,非独占的.</p>
<p><strong><a href="https://github.com/openzipkin/zipkin-go/blob/master/reporter/kafka/kafka.go">kafkaReporter</a></strong>
把Span数据发送到<a href="https://kafka.apache.org/">kafka</a>中.</p>
<p>函数原型:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// address为broker地址列表.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewReporter</span><span class="p">(</span><span class="nx">address</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">options</span> <span class="o">...</span><span class="nx">ReporterOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">reporter</span><span class="p">.</span><span class="nx">Reporter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div><p>采用了<code>Option</code>设计方式来对相关参数进行自定义处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置日志对象,默认为Stderr
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Logger</span><span class="p">(</span><span class="nx">logger</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置生产者.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Producer</span><span class="p">(</span><span class="nx">p</span> <span class="nx">sarama</span><span class="p">.</span><span class="nx">AsyncProducer</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置topic名字,默认为zipkin
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Topic</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">ReporterOption</span>

<span class="c1">// 设置span的序列化方式,默认实现的是json格式.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Serializer</span><span class="p">(</span><span class="nx">serializer</span> <span class="nx">reporter</span><span class="p">.</span><span class="nx">SpanSerializer</span><span class="p">)</span> <span class="nx">ReporterOption</span>
</code></pre></div><p><strong><a href="https://github.com/openzipkin/zipkin-go/blob/master/reporter/log/log.go">logReporter</a></strong>
把Span数据发送到日志对象中.</p>
<p>函数原型:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewReporter</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">reporter</span><span class="p">.</span><span class="nx">Reporter</span>
</code></pre></div><p>只是把Span数据记录到指定的日志对象中,并不会发送到zipkin中.</p>
<h3 id="newtracer函数">NewTracer函数</h3>
<p>函数原型:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// rep指定Reporter.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTracer</span><span class="p">(</span><span class="nx">rep</span> <span class="nx">reporter</span><span class="p">.</span><span class="nx">Reporter</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">TracerOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tracer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>当指定的rep为nil时,会默认创建为noopRepoerter.</p>
<p>采用了<code>Option</code>设计方式来对相关参数进行自定义处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置被追踪服务的本地endpoint,可调用zipkin.NewEndpoint来生成对应的Endpoint对象,默认为nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithLocalEndpoint</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">Endpoint</span><span class="p">)</span> <span class="nx">TracerOption</span>

<span class="c1">// 设置采样策略,默认为AlwaysSample.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithSampler</span><span class="p">(</span><span class="nx">sampler</span> <span class="nx">Sampler</span><span class="p">)</span> <span class="nx">TracerOption</span>
</code></pre></div><p>针对采样策略,<code>Sampler</code>原型为<code>type Sampler func(id uint64) bool</code>,可按照需求来自定义采样策略.官方默认提供了如下几种方式:
<strong>AlwaysSample</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 所有span都会被发送到zipkin.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AlwaysSample</span><span class="p">(</span><span class="nx">_</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
</code></pre></div><p><strong>NewModuloSampler</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 当mod小于2时采用AlwaysSmaple.当mod大于2时,若trace id对mod求余为0就会被发送zipkin.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewModuloSampler</span><span class="p">(</span><span class="nx">mod</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">Sampler</span>
</code></pre></div><p><strong>NewBoundarySampler</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BoundarySampler适用于提供随机trace id且仅做出一次采样决定的高流量场景.它可以防止集群中的节点选择完全相同的ID.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewBoundarySampler</span><span class="p">(</span><span class="nx">rate</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">salt</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">Sampler</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p><strong>NewCountingSampler</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CountingSampler适用于低流量或不提供随机trace id的场景,由于采样决策不是幂等的(根据traceid一致),因此不适用于收集器.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewCountingSampler</span><span class="p">(</span><span class="nx">rate</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="nx">Sampler</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><h3 id="完整例子">完整例子</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;io&#34;</span>

	<span class="s">&#34;github.com/opentracing/opentracing-go&#34;</span>
	<span class="nx">zipkinot</span> <span class="s">&#34;github.com/openzipkin-contrib/zipkin-go-opentracing&#34;</span>
	<span class="s">&#34;github.com/openzipkin/zipkin-go&#34;</span>
	<span class="nx">zipkinhttp</span> <span class="s">&#34;github.com/openzipkin/zipkin-go/reporter/http&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">noopZkCloser</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">noopZkCloser</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// newTracer 创建基于zipkin的tracer对象.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newTracer</span><span class="p">(</span><span class="nx">tracingURL</span><span class="p">,</span> <span class="nx">serverName</span><span class="p">,</span> <span class="nx">localEndpoint</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">Tracer</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 基于HTTP的Reporter.
</span><span class="c1"></span>    <span class="nx">zipkinReporter</span> <span class="o">:=</span> <span class="nx">zipkinhttp</span><span class="p">.</span><span class="nf">NewReporter</span><span class="p">(</span><span class="nx">tracingURL</span><span class="p">)</span>
    
    <span class="c1">// 创建localendpoint对象.
</span><span class="c1"></span>	<span class="nx">endpoint</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">zipkin</span><span class="p">.</span><span class="nf">NewEndpoint</span><span class="p">(</span><span class="nx">serverName</span><span class="p">,</span> <span class="nx">localEndpoint</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 创建zipkin原生的tracer对象,采样策略使用默认的AlwaysSample.
</span><span class="c1"></span>	<span class="nx">nativeTracer</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">zipkin</span><span class="p">.</span><span class="nf">NewTracer</span><span class="p">(</span><span class="nx">zipkinReporter</span><span class="p">,</span> <span class="nx">zipkin</span><span class="p">.</span><span class="nf">WithLocalEndpoint</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 把zipkin原生tracer对象包装成OpenTracing的tracer对象.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">zipkinot</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">nativeTracer</span><span class="p">),</span> <span class="nx">noopZkCloser</span><span class="p">{},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>OpenTracing最佳实践</title>
			<link>https://shenbaise9527.com/posts/opentracing%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
			<pubDate>Thu, 10 Dec 2020 21:35:32 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/opentracing%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
			<description>回顾: OpenTracing的目标是什么? OpenTracing是一个位于应用程序/库代码和追踪系统之间的一个标准中间层.结构如下: +-------------+ +---------+ +----------+ +------------+</description>
			<content type="html"><![CDATA[<h2 id="回顾-opentracing的目标是什么">回顾: OpenTracing的目标是什么?</h2>
<p>OpenTracing是一个位于应用程序/库代码和追踪系统之间的一个标准中间层.结构如下:</p>
<pre><code>   +-------------+  +---------+  +----------+  +------------+
   | Application |  | Library |  |   OSS    |  |  RPC/IPC   |
   |    Code     |  |  Code   |  | Services |  | Frameworks |
   +-------------+  +---------+  +----------+  +------------+
          |              |             |             |
          |              |             |             |
          v              v             v             v
     +-----------------------------------------------------+
     | · · · · · · · · · · OpenTracing · · · · · · · · · · |
     +-----------------------------------------------------+
       |               |                |               |
       |               |                |               |
       v               v                v               v
 +-----------+  +-------------+  +-------------+  +-----------+
 |  Tracing  |  |   Logging   |  |   Metrics   |  |  Tracing  |
 | System A  |  | Framework B |  | Framework C |  | System D  |
 +-----------+  +-------------+  +-------------+  +-----------+
</code></pre><h2 id="用例">用例</h2>
<p>下面列出一些OpenTracing的用例,并对其进行详细描述:</p>
<table>
<thead>
<tr>
<th>Use case</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用程序代码</td>
<td>编写应用程序代码的开发人员可以使用OpenTracing来描述因果关系,划分控制流,并添加细粒度的日志记录信息.</td>
</tr>
<tr>
<td>库代码</td>
<td>对于请求进行中间控制的库也可以与OpenTracing集成.例如:Web中间件可以使用OpenTracing为每个请求创建spans,或者ORM库可以使用OpenTracing来描述更高级别的ORM语义并衡量特定SQL查询的执行.</td>
</tr>
<tr>
<td>OSS服务</td>
<td>除了嵌入式库之后,整个OSS服务都可以采用OpenTracing来与分布式跟踪系统集成,在较大的分布式系统中启动或传播到其它进程.例如:HTTP负载均衡器可以使用OpenTracing包装所有请求,或者在分布式KV存储系统中使用OpenTracing来跟踪读写性能.</td>
</tr>
<tr>
<td>RPC/IPC框架</td>
<td>任何跨进程边界的任务子系统都可以使用OpenTracing来标准化trace状态,OpenTracing提供了统一的Inject和Extract格式.</td>
</tr>
</tbody>
</table>
<p>所有上述都可以使用OpenTracing来描述和传播分布式跟踪信息,而不用了解分布式追踪系统的底层实现.</p>
<p>OpenTracing优先考虑易用性的问题,主要是站在调用者的角度,而不是分布式追踪系统的实现者上.</p>
<h2 id="举例">举例</h2>
<h3 id="追踪函数">追踪函数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TopLevelFunction</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
	<span class="nx">span1</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;toplevelfunction&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">span1</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
	<span class="nx">subctx</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">span</span><span class="p">)</span>

	<span class="c1">// 业务逻辑.
</span><span class="c1"></span>	<span class="nf">Function2</span><span class="p">(</span><span class="nx">subctx</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>作为业务逻辑的一部分,调用了<code>Function2</code>方法,也想被追踪.为了让<code>Function2</code>里的追踪和<code>TopLevelFunction</code>里的追踪形成因果关系,必须在<code>Function2</code>里要能访问到<code>span1</code>,通过<code>span1</code>来创建一个子span.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Function2</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">span1</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
		<span class="nx">span2</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;function2&#34;</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">span1</span><span class="p">.</span><span class="nf">Context</span><span class="p">()))</span>
		<span class="k">defer</span> <span class="nx">span2</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>通过<code>context.Context</code>来传递<code>span</code>,可以让整个函数调用过程形成一个完整的调用链.</p>
<h3 id="服务端追踪">服务端追踪</h3>
<p>当服务端想要去跟踪每个请求的执行过程,一般需要以下几个步骤.</p>
<ul>
<li>试图中从请求中获取<code>SpanContext</code>(客户端已经开启了trace),如果无法获取就开启一个新的trace.</li>
<li>在上下文中存储最新创建的<code>Span</code>,上下文会通过应用程序代码或RPC框架传播.</li>
<li>最后当处理完请求时需要调用<code>span.Finish()</code>来关闭<code>Span</code>.</li>
</ul>
<p><strong>从请求中获取<code>SpanContext</code></strong></p>
<p>假设有个HTTP服务器,<code>SpanContext</code>通过http头从客户端传播到服务端,可通过<code>request.headers</code>来访问.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
<span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">spanContext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
</code></pre></div><p>把<code>headers</code>转换成<code>carrier</code>,<code>tracer</code>对象知道需要<code>headers</code>中的哪些字段,用来重建tracer的状态及Baggage.</p>
<p><strong>从请求中获取一个已经存在的trace,或者开启一个新的trace</strong></p>
<p>假设客户端没有发送相应字段的值,在服务端就无法从<code>Header</code>中获取到,上文中的<code>spanContext</code>可能为<code>nil</code>.在这种情况下,服务端需要开启一个新的trace.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
<span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">spanContext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">span</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">Span</span>
<span class="k">if</span> <span class="nx">spanContext</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">span</span> <span class="p">=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">span</span> <span class="p">=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">spanContext</span><span class="p">))</span>
<span class="p">}</span>

<span class="nx">ext</span><span class="p">.</span><span class="nx">HTTPMethod</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
</code></pre></div><p><code>ext.HTTPMethod.Set</code>是给<code>span</code>设置一个附加信息,等同于<code>span.SetTag(&quot;http.method&quot;, r.Method)</code>.</p>
<p><code>StartSpan</code>的第一个参数是operationName,用来指定新创建的<code>Span</code>的名字.举例,若HTTP请求是<code>POST</code>类型且URI为<code>/save_user/123</code>,这此时<code>Span</code>的名字会被设置为<code>/save_user/123</code>.OpenTracing规范不会强制要求应用程序如何给<code>Span</code>命名.</p>
<p><strong>进程内请求上下文传播</strong></p>
<p>请求上下文是指:对于一个请求,所有处理这个请求的层都可以访问到同一个<code>context(上下文)</code>.可以通过特定值,如用户id、token、请求截止时间等来获取这个<code>context</code>,也可以用这个方式来获取当前正在追踪的<code>Span</code>.</p>
<p>OpenTracing规范中并没有规定请求上下文的传输实现方式,但这点是非常重要的,便于我们理解后面的章节.一般有两种常见的基数:</p>
<ul>
<li>隐式传输,<code>context</code>需要被储存在平台特定的位置,允许应用程序在任何地方都能访问到.常用的RPC框架会利用<code>thread-local</code>或<code>continuation-local</code>来存储,或者是全局变量(在单线程程序中).这种方式的缺点是性能低下,并且有些平台如Go是不支持线程本地存储的,隐式传输就几乎不可能实现了.</li>
<li>显示传输,要求应用程序代码包装和传递一个<code>context</code>对象.这种方式的缺点在于向应用程序暴露了底层的实现,<a href="https://blog.golang.org/context">Go blog post</a>这篇文章提供了这种方式的深层次解析.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">HandleHttp</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="nf">BusinessFunction1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BusinessFunction1</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">arg1</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nf">BusinessFunction2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BusinessFunction2</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">arg1</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parentSpan</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="nx">childSpan</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span>
        <span class="s">&#34;...&#34;</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">parentSpan</span><span class="p">.</span><span class="nf">Context</span><span class="p">()),</span> <span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="客户端追踪">客户端追踪</h3>
<p>当一个应用程序扮演RPC客户端的角色时,在调用外部接口前可以开启一个新的<code>Span</code>,在请求期间传播该<code>Span</code>.下面通过一个HTTP请求来展示如何处理.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tracedPost</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">operation</span><span class="p">,</span> <span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">body</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">parent_span</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
    <span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span>
        <span class="nx">operation</span><span class="p">,</span>
        <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">parent_span</span><span class="p">.</span><span class="nf">Context</span><span class="p">()),</span>
        <span class="nx">opentracing</span><span class="p">.</span><span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;http.url&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">},</span>
        <span class="nx">opentracing</span><span class="p">.</span><span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;http.method&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">})</span>
    <span class="k">defer</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
    <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span>
    <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">reader</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">ext</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Inject</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">ext</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">cli</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Timeout</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">rsp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">ext</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">ext</span><span class="p">.</span><span class="nx">HTTPStatusCode</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">rsp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">))</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>首先从<code>context</code>中获取<code>parent_span</code>,可以跟上游<code>Span</code>构成一个链条.</li>
<li>针对http请求创建一个新的<code>Span</code>,设置相应的Tag,然后调用<code>Inject</code>把需要传播的信息注入到<code>req.Header</code>中,在服务端就可以利用<code>Header</code>来重组<code>Span</code>.</li>
<li>当有错误发生的时候,调用<code>ext.LogError</code>把错误信息关联到<code>Span</code>上.</li>
<li>最后把相应的状态码作为Tag设置到<code>Span</code>上.</li>
</ul>
<h3 id="使用baggage分布式上下文传输">使用Baggage/分布式上下文传输</h3>
<p>上面的例子都是通过网络在客户端和服务端之间传递<code>Span/Tracer</code>,包含任意的<code>Baggage</code>.客户端可以利用<code>Baggage</code>来传播一些附加信息到服务端及任何其下游服务.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 客户端.
</span><span class="c1"></span><span class="nx">span</span> <span class="p">=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">SetBaggageItem</span><span class="p">(</span><span class="s">&#34;auto_token&#34;</span><span class="p">,</span> <span class="s">&#34;token&#34;</span><span class="p">)</span>

<span class="c1">// 服务端.
</span><span class="c1"></span><span class="nx">token</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">BaggageItem</span><span class="p">(</span><span class="s">&#34;auto_token&#34;</span><span class="p">)</span>
</code></pre></div><h3 id="logging事件">Logging事件</h3>
<p>在上面<a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%BD%E8%B8%AA">客户端追踪</a>的例子中已经使用过Log了.可以记录事件而不需要有<code>payload</code>,而不仅在<code>Span</code>被创建和完成时.举个例子,应用程序在执行过程中可能会需要记录<code>cache miss</code>事件,可以通过在请求上下文中来获取当前<code>Span</code>然后把该事件附加到<code>Span</code>中.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">span</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="c1">// 不带payload的.
</span><span class="c1"></span><span class="nx">span</span><span class="p">.</span><span class="nf">LogEvent</span><span class="p">(</span><span class="s">&#34;cache_miss&#34;</span><span class="p">)</span>
<span class="c1">// 带payload的.
</span><span class="c1"></span><span class="nx">span</span><span class="p">.</span><span class="nf">LogEventWithPayload</span><span class="p">(</span><span class="s">&#34;cache_miss&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p><code>Tracer</code>会自动记录该事件的时间戳,与应用于整个<code>Span</code>的tags相反.也可以将外部提供的时间戳与事件想关联,可以查看<a href="https://github.com/opentracing/opentracing-go">opentracing-go</a>中<code>Span</code>接口的<code>LogFields</code>方法.</p>
<h3 id="使用外部时间戳记录span">使用外部时间戳记录Span</h3>
<p>因为各种各样的原因,在有些场景下会将OpenTracing兼容的tracer集成到服务中.比如一个用户有一个日志文件,其中包含大量来自黑盒系统(如HAProxy)产生的Span数据,为了把这些数据导入到OpenTracing兼容的系统中,API必须提供一种方法通过外部自定义时间戳来记录<code>Span</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;operationname&#34;</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartTime</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()))</span>
<span class="nx">span</span><span class="p">.</span><span class="nf">FinishWithOptions</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">FinishOptions</span><span class="p">{</span><span class="nx">FinishTime</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()})</span>
</code></pre></div><h3 id="开启tracer之前设置好采样策略">开启tracer之前设置好采样策略</h3>
<p>大多数分布式追踪系统都会通过应用不同的采样策略来减少需要记录和处理的追踪数据的总量.有时开发人员希望有一种方式来确保一个tracer数据会被系统记录(采样),如在HTTP请求中包含一个特殊的参数(<code>debug=true</code>).OpenTracing API标准化了一些有用的tags,其中一个叫<code>sampling.priority</code>(采样优先级):精确的实现是由追踪系统的实现者决定的,但任何大于0(默认)代表一条tracer的高优先级.为了传递这个属性到追踪系统中,需要在追踪前进行预处理,如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseBool</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;debug&#34;</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span>
		<span class="s">&#34;operationname&#34;</span><span class="p">,</span> 
		<span class="nx">opentracing</span><span class="p">.</span><span class="nx">Tag</span><span class="p">{</span><span class="nb">string</span><span class="p">(</span><span class="nx">ext</span><span class="p">.</span><span class="nx">SamplingPriority</span><span class="p">),</span> <span class="mi">1</span><span class="p">},</span> 
	<span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="追踪消息总线的方案">追踪消息总线的方案</h3>
<p>有两种类别的消息总线需要处理,包括消息队列和发布/订阅(主题).</p>
<p>从追踪的视角来看,消息总线的类型并不重要,只是要将生产者关联的<code>SpanContext</code>传播到零个或多个消费者中.然后消费者就有责任创建<code>Span</code>来封装都消息的处理,并建立对传播来的<code>SpanContext</code>的<code>FollowsFrom</code>引用.</p>
<p>以RPC客户端为例,生产者在发送消息之前开启了一个新<code>Span</code>,并跟随消息传播该<code>Span</code>的<code>Context</code>.在消息成功发布到消息总线上后这个<code>Span</code>就完成了.下面展示代码是如何实现的:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">traced_send</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
    <span class="c1"># retrieve current span from propagated message context</span>
    <span class="n">parent_span</span> <span class="o">=</span> <span class="n">get_current_span</span><span class="p">()</span>

    <span class="c1"># start a new span to represent the message producer</span>
    <span class="n">span</span> <span class="o">=</span> <span class="n">tracer</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span>
        <span class="n">operation_name</span><span class="o">=</span><span class="n">operation</span><span class="p">,</span>
        <span class="n">child_of</span><span class="o">=</span><span class="n">parent_span</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
        <span class="n">tags</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;message.destination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">destination</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># propagate the Span via message headers</span>
    <span class="n">tracer</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span>
        <span class="n">span</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
        <span class="n">format</span><span class="o">=</span><span class="n">opentracing</span><span class="o">.</span><span class="n">TEXT_MAP_FORMAT</span><span class="p">,</span>
        <span class="n">carrier</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">span</span><span class="p">:</span>
        <span class="n">messaging_client</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="n">e</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">raise</span>
</code></pre></div><p>接下来消费者会判断消息中是否包含了<code>SpanContext</code>,如果有,就会用它来与生产者的<code>Span</code>建立联系.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">extracted_context</span> <span class="o">=</span> <span class="n">tracer</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span>
    <span class="n">format</span><span class="o">=</span><span class="n">opentracing</span><span class="o">.</span><span class="n">TEXT_MAP_FORMAT</span><span class="p">,</span>
    <span class="n">carrier</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">headers</span>
<span class="p">)</span>
<span class="n">span</span> <span class="o">=</span> <span class="n">tracer</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">operation_name</span><span class="o">=</span><span class="n">operation</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">follows_from</span><span class="p">(</span><span class="n">extracted_context</span><span class="p">))</span>
<span class="n">span</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s1">&#39;message.destination&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">destination</span><span class="p">)</span>
</code></pre></div><h3 id="基于队列的同步请求-响应">基于队列的同步请求-响应</h3>
<p>尽管使用不多,但有些消息平台/标准(如JMS)支持在消息头中提供ReplyTo目标的功能.消费者收到消息后,它会将结果返回到指定的目的地.</p>
<p>这种模式常用来模拟同步请求/响应,这种情况下消费者和生产者之间是<code>ClildOf</code>的关系.</p>
<p>但此模式也可以用于委托来指示将结果告知第三方.在这种情况下,它将被视为两个单独的消息交换并具有链接每个阶段的<code>Follows From</code>关系类型(A-&gt;B-&gt;C).</p>
<p>由于很难区分这两种情况,不建议将面向消息中间件用于同步的请求/响应模式,因此从建议跟踪角度忽略请求/响应方案.</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://opentracing.io/specification/conventions/">语义约定</a></li>
<li><a href="https://opentracing.io/docs/best-practices/">Best Practices</a></li>
<li><a href="https://wu-sheng.gitbooks.io/opentracing-io/content/pages/instrumentation/">最佳实践</a></li>
<li><a href="https://github.com/yurishkuro/opentracing-tutorial">opentracing-tutorial</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>OpenTracing分布式链路追踪</title>
			<link>https://shenbaise9527.com/posts/opentracing%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</link>
			<pubDate>Thu, 10 Dec 2020 21:35:19 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/opentracing%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</guid>
			<description>概述 简介 虽然微服务是一种强大的系统架构,但也伴随着新的问题,就是当微服务数量众多且调用链条过长时,在复杂的网络环境下是很难调试和观察分布式事</description>
			<content type="html"><![CDATA[<h2 id="概述">概述</h2>
<h3 id="简介">简介</h3>
<p>虽然微服务是一种强大的系统架构,但也伴随着新的问题,就是当微服务数量众多且调用链条过长时,在复杂的网络环境下是很难调试和观察分布式事务,无法直接在内存或堆栈中来调试或观察.</p>
<p>在这种情况下,分布式追踪系统进入到视野之中,分布式追踪系统对于描述和分析跨进程事务的问题提供了解决方案.大部分的分布式追踪系统的思想都来源于<a href="https://ai.google/research/pubs/pub36356">Google&rsquo;s Dapper paper</a></p>
<h3 id="分布式追踪系统的模型">分布式追踪系统的模型</h3>
<p>大多数分布式追踪系统的模型来自于Google&rsquo;s Dapper paper.OpenTracing也是一样的,采用了相同的名词和动词.
<img src="/images/tracing1_0.png" alt="模型" title="tracing模型"></p>
<ol>
<li>Trace: 用来描述在分布式系统中一个完整的事务(这里的事务不是指数据库中的事务,而是指一个完整的业务流).</li>
<li>Span: 可命名的、记录耗时的一个工作流片段,Span上可设置多个key:value的tags,也可以记录某个时间点的结构化的log.</li>
<li>SpanContext: 追踪信息会伴随着整个分布式事务,会通过网络或者消息总线来传递到下游服务中.包含了trace id、span id和其它需要传播(分布式追踪系统需要传播到下游的)的数据.</li>
</ol>
<h3 id="四个主要的问题">四个主要的问题</h3>
<p>从应用程序层分布式跟踪系统的角度来看，现代软件系统如下图所示：
<img src="/images/tracing2_0.png" alt="系统" title="系统结构"></p>
<p>现代软件系统中的组件可分为三大类:</p>
<ul>
<li>应用程序和业务逻辑: 自己的代码.</li>
<li>广泛使用的共享库: 别人的代码.</li>
<li>广泛使用的服务: 别人的基础设施.</li>
</ul>
<p>这三类组件有不同的需求,并驱动着负责监控应用程序的分布式追踪系统的设计.最终有四个非常重要的设计要点:</p>
<ul>
<li>追踪系统的API: 应用程序如何使用?</li>
<li>传播协议: 在RPC请求中与应用程序一起发送的内容(传递到下游服务中).</li>
<li>数据协议: 异步(带外)发送到分析系统中的内容.</li>
<li>分析系统: 用于处理追踪数据的数据库和交互式UI.</li>
</ul>
<h3 id="opentracing是如何解决的">OpenTracing是如何解决的?</h3>
<p>OpenTracing API提供了标准的、与厂商无关的工具框架.当开发人员想尝试不同的分布式追踪系统时,只需要简单的更改Tracer的配置,而不用为了适配新的分布式追踪系统而重复开发整个追踪过程.</p>
<h2 id="什么是分布式追踪">什么是分布式追踪?</h2>
<p>分布式追踪是一种用来分析和监控应用程序的方法,特别是使用微服务架构的系统.分布式追踪有助于查明发生故障的位置以及导致性能下降的原因.</p>
<h3 id="分布式追踪的使用场景">分布式追踪的使用场景</h3>
<ul>
<li>IT和DevOps团队可以用分布式追踪来监控整个应用程序.分布式追踪特别适合用来调试和监控现代分布式软件体系结构,如微服务.</li>
<li>开发人员可以利用分布式追踪来帮助调试和优化代码.</li>
</ul>
<h3 id="什么是opentracing">什么是OpenTracing?</h3>
<p>首先从什么不是OpenTracing开始可能更容易.</p>
<ul>
<li>OpenTracing不是一个下载文件或程序.分布式追踪系统要求软件开发人员将追踪代码添加到应用程序的代码中,或者应用程序所使用的框架中.</li>
<li>OpenTracing不是一个标准,<a href="https://www.cncf.io/">CNCF</a>不是一个标准化组织.OpenTracing API项目正在努力为分布式追踪系统创建更加标准的API和工具.</li>
</ul>
<p>OpenTracing是由API规范,已实现该规范的框架和库以及该项目的文档组成.OpenTracing允许开发人员使用不会将其受限于任何一种特定的产品或供应商的API来将追踪代码添加到应用程序中.</p>
<p>关于更多已实现OpenTracing规范的信息,可以查看<a href="https://opentracing.io/docs/supported-languages">已支持的语言列表</a>和<a href="https://opentracing.io/docs/supported-tracers/">已支持的分布式追踪系统</a></p>
<h2 id="spans">Spans</h2>
<p>Span是分布式追踪的主要构建对象,代表分布式系统中已完成的单个工作单元.</p>
<p>分布式系统中的每个组件都会构建一个Span(命名的、记录耗时的一个工作流片段).</p>
<p>Spans可以包含对其它Spans的引用,这样就允许多个Span关联到一个已完成的Trace(把一个请求在分布式系统中的生命周期可视化).</p>
<p>根据OpenTracing规范,每个Span会封装以下内容:</p>
<ul>
<li>Operation Name(操作名称).</li>
<li>开始时间和结束时间.</li>
<li>Tags,key:value的集合,伴随整个Span.</li>
<li>Logs,key:value的集合,记录某个时间点的日志.</li>
<li>SpanContext.</li>
</ul>
<h3 id="tags">Tags</h3>
<p>key:value的集合,对Span的自定义标记,可以用来查询、过滤和理解追踪数据.</p>
<p>tags是伴随Span的整个生命周期,在文件<a href="https://github.com/opentracing/specification/blob/master/semantic_conventions.md">semantic_conventions.md</a>定义了常见场景中Span的常规tags.如<code>db.instance</code>表示数据库主机地址,<code>http.status_code</code>表示HTTP的响应码,<code>error</code>可以设置为<code>True</code>表示Span所代表的操作失败了.</p>
<h3 id="logs">Logs</h3>
<p>key:value的集合,可用于抓取Span的特定的日志信息以及应用程序本身的其它调试信息或输出信息.也常用于记录Span某个特定时刻或事件(和tags应用与Span的整个生命周期不同).</p>
<h3 id="spancontext">SpanContext</h3>
<p>SpanContext用于跨进程边界时携带数据,主要包含两个方面的数据:</p>
<ol>
<li>依赖于实现的状态来引用trace中不同的span.
<ul>
<li>Tracer定义的spanID和traceID.</li>
</ul>
</li>
<li>任何Baggage Items.
<ul>
<li>需要跨进程边界传播的key:value数据对.</li>
<li>其它对整个追踪访问有用的数据.</li>
</ul>
</li>
</ol>
<h3 id="举例">举例</h3>
<pre><code>    t=0            operation name: db_query               t=x

     +-----------------------------------------------------+
     | · · · · · · · · · ·    Span     · · · · · · · · · · |
     +-----------------------------------------------------+

Tags:
- db.instance:&quot;customers&quot;
- db.statement:&quot;SELECT * FROM mytable WHERE foo='bar'&quot;
- peer.address:&quot;mysql://127.0.0.1:3306/customers&quot;

Logs:
- message:&quot;Can't connect to mysql server on '127.0.0.1'(10061)&quot;

SpanContext:
- trace_id:&quot;abc123&quot;
- span_id:&quot;xyz789&quot;
- Baggage Items:
  - special_id:&quot;vsid1738&quot;
</code></pre><h2 id="tracers">Tracers</h2>
<h3 id="简介-1">简介</h3>
<p>OpenTracing提供了一个开放的、与厂商无关的标准API,用来描述分布式事务,尤其是因果关系、语义和时间.它提供了一个通用的分布式上下文传播框架,该框架由以下API原语组成:</p>
<ul>
<li>在进程间传播元数据上下文.</li>
<li>编码和解码元数据上下文之后,通过网络传输它用来进行进程间通信.</li>
<li>因果关系追踪: 父子关系、分叉和连接.</li>
</ul>
<p>OpenTracing消除了众多分布式追踪系统之间的差异.这意味着无论开发人员使用哪个分布式追踪系统,追踪代码都将保持不变.为了在应用程序中使用OpenTracing规范的追踪代码,必须部署兼容OpenTracing的追踪系统,<a href="https://opentracing.io/docs/supported-tracers/">已支持OpenTracing规范的追踪系统</a>.</p>
<h3 id="tracer接口">Tracer接口</h3>
<p>Tracer接口能创建<code>Spans</code>,还知道如何跨进程边界注入(序列化)和提取(反序列化)元数据,主要包含三个方面的能力:</p>
<ul>
<li>开启一个新的<code>Span</code>.</li>
<li>将<code>SpanContext</code>注入到<code>carrier</code>中.</li>
<li>从<code>carrier</code>中提取出<code>SpanContext</code>.</li>
</ul>
<p>以Golang语言为例:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tracer is a simple, thin interface for Span creation and SpanContext
</span><span class="c1">// propagation.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Tracer</span> <span class="kd">interface</span> <span class="p">{</span>

	<span class="c1">// Create, start, and return a new Span with the given `operationName` and
</span><span class="c1"></span>	<span class="c1">// incorporate the given StartSpanOption `opts`. (Note that `opts` borrows
</span><span class="c1"></span>	<span class="c1">// from the &#34;functional options&#34; pattern, per
</span><span class="c1"></span>	<span class="c1">// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Span with no SpanReference options (e.g., opentracing.ChildOf() or
</span><span class="c1"></span>	<span class="c1">// opentracing.FollowsFrom()) becomes the root of its own trace.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Examples:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     var tracer opentracing.Tracer = ...
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The root-span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(&#34;GetFeed&#34;)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The vanilla child span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // All the bells and whistles:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()),
</span><span class="c1"></span>	<span class="c1">//         opentracing.Tag{&#34;user_agent&#34;, loggedReq.UserAgent},
</span><span class="c1"></span>	<span class="c1">//         opentracing.StartTime(loggedReq.Timestamp),
</span><span class="c1"></span>	<span class="c1">//     )
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Inject() takes the `sm` SpanContext instance and injects it for
</span><span class="c1"></span>	<span class="c1">// propagation within `carrier`. The actual type of `carrier` depends on
</span><span class="c1"></span>	<span class="c1">// the value of `format`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see https://godoc.org/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (sans error handling):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     err := tracer.Inject(
</span><span class="c1"></span>	<span class="c1">//         span.Context(),
</span><span class="c1"></span>	<span class="c1">//         opentracing.HTTPHeaders,
</span><span class="c1"></span>	<span class="c1">//         carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrUnsupportedFormat if `format`
</span><span class="c1"></span>	<span class="c1">// is not supported by (or not known by) the implementation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrInvalidCarrier or any other
</span><span class="c1"></span>	<span class="c1">// implementation-specific error if the format is supported but injection
</span><span class="c1"></span>	<span class="c1">// fails anyway.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Extract().
</span><span class="c1"></span>	<span class="nf">Inject</span><span class="p">(</span><span class="nx">sm</span> <span class="nx">SpanContext</span><span class="p">,</span> <span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>

	<span class="c1">// Extract() returns a SpanContext instance given `format` and `carrier`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see
</span><span class="c1"></span>	<span class="c1">// https://godoc.org/golang.org/x/net/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (with StartSpan):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // ... assuming the ultimate goal here is to resume the trace with a
</span><span class="c1"></span>	<span class="c1">//     // server-side Span:
</span><span class="c1"></span>	<span class="c1">//     var serverSpan opentracing.Span
</span><span class="c1"></span>	<span class="c1">//     if err == nil {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//             rpcMethodName, ext.RPCServerOption(clientContext))
</span><span class="c1"></span>	<span class="c1">//     } else {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(rpcMethodName)
</span><span class="c1"></span>	<span class="c1">//     }
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Return values:
</span><span class="c1"></span>	<span class="c1">//  - A successful Extract returns a SpanContext instance and a nil error
</span><span class="c1"></span>	<span class="c1">//  - If there was simply no SpanContext to extract in `carrier`, Extract()
</span><span class="c1"></span>	<span class="c1">//    returns (nil, opentracing.ErrSpanContextNotFound)
</span><span class="c1"></span>	<span class="c1">//  - If `format` is unsupported or unrecognized, Extract() returns (nil,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrUnsupportedFormat)
</span><span class="c1"></span>	<span class="c1">//  - If there are more fundamental problems with the `carrier` object,
</span><span class="c1"></span>	<span class="c1">//    Extract() may return opentracing.ErrInvalidCarrier,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrSpanContextCorrupted, or implementation-specific
</span><span class="c1"></span>	<span class="c1">//    errors.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Inject().
</span><span class="c1"></span>	<span class="nf">Extract</span><span class="p">(</span><span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">SpanContext</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="设置tracer">设置Tracer</h3>
<p>实现了<code>Tracer</code>接口的对象,主要用来记录<code>Spans</code>并发布到某个位置.应用程序如何处理Tracer对象取决于开发人员:可以直接在整个应用程序中使用它,或将其存储在<code>GlobalTracer</code>中.</p>
<p>不同的Tracer实现在初始化时接收参数的方式和接收的参数有所不同,如下:</p>
<ul>
<li>应用程序的追踪组件名称.</li>
<li>分布式追踪系统的Endpoint.</li>
<li>分布式追踪系统的安全连接.</li>
<li>采样策略.</li>
</ul>
<p>一旦Tracer对象实例被创建出来,就可以用来手工创建<code>Span</code>,或传递该对象到框架或库中.</p>
<p>为了不强制用户传递<code>Tracer</code>对象,提供了一个全局的<code>GlobalTracer</code>实例来存储<code>Tracer</code>对象,在任何地方都可以通过该全局实例来获取<code>Tracer</code>对象.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">registeredTracer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tracer</span>       <span class="nx">Tracer</span>
	<span class="nx">isRegistered</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">globalTracer</span> <span class="p">=</span> <span class="nx">registeredTracer</span><span class="p">{</span><span class="nx">NoopTracer</span><span class="p">{},</span> <span class="kc">false</span><span class="p">}</span>
<span class="p">)</span>

<span class="c1">// SetGlobalTracer sets the [singleton] opentracing.Tracer returned by
</span><span class="c1">// GlobalTracer(). Those who use GlobalTracer (rather than directly manage an
</span><span class="c1">// opentracing.Tracer instance) should call SetGlobalTracer as early as
</span><span class="c1">// possible in main(), prior to calling the `StartSpan` global func below.
</span><span class="c1">// Prior to calling `SetGlobalTracer`, any Spans started via the `StartSpan`
</span><span class="c1">// (etc) globals are noops.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SetGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">globalTracer</span> <span class="p">=</span> <span class="nx">registeredTracer</span><span class="p">{</span><span class="nx">tracer</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// GlobalTracer returns the global singleton `Tracer` implementation.
</span><span class="c1">// Before `SetGlobalTracer()` is called, the `GlobalTracer()` is a noop
</span><span class="c1">// implementation that drops all data handed to it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GlobalTracer</span><span class="p">()</span> <span class="nx">Tracer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">globalTracer</span><span class="p">.</span><span class="nx">tracer</span>
<span class="p">}</span>
</code></pre></div><h3 id="开启一个新的trace">开启一个新的Trace</h3>
<p>当创建一个新的<code>Span</code>且该<code>Span</code>没有关联到一个父<code>Span</code>时,一个新的trace就开启了.当创建一个新的<code>Span</code>时,需要为其定义一个<code>operation name</code>,主要用来帮助确定<code>Span</code>与代码的关联关系.</p>
<p><code>Span</code>之间的关联关系目前支持<code>ChildOf</code>和<code>FollowsFrom</code>:</p>
<ul>
<li><code>ChildOf</code>,表示两个<code>Span</code>之间存在父子关系.子<code>Span</code>是在父<code>Span</code>内执行的一个子流程.</li>
<li><code>FollowsFrom</code>,表示两个<code>Span</code>之间是独立的,父<code>Span</code>不依赖新的<code>Span</code>的执行结果,主要用于pipiline.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ChildOfRef refers to a parent Span that caused *and* somehow depends
</span><span class="c1">// upon the new child Span. Often (but not always), the parent Span cannot
</span><span class="c1">// finish until the child Span does.
</span><span class="c1">//
</span><span class="c1">// An timing diagram for a ChildOfRef that&#39;s blocked on the new Span:
</span><span class="c1">//
</span><span class="c1">//     [-Parent Span---------]
</span><span class="c1">//          [-Child Span----]
</span><span class="c1">//
</span><span class="c1">// See http://opentracing.io/spec/
</span><span class="c1">//
</span><span class="c1">// See opentracing.ChildOf()
</span><span class="c1"></span><span class="nx">ChildOfRef</span> <span class="nx">SpanReferenceType</span> <span class="p">=</span> <span class="kc">iota</span>

<span class="c1">// FollowsFromRef refers to a parent Span that does not depend in any way
</span><span class="c1">// on the result of the new child Span. For instance, one might use
</span><span class="c1">// FollowsFromRefs to describe pipeline stages separated by queues,
</span><span class="c1">// or a fire-and-forget cache insert at the tail end of a web request.
</span><span class="c1">//
</span><span class="c1">// A FollowsFromRef Span is part of the same logical trace as the new Span:
</span><span class="c1">// i.e., the new Span is somehow caused by the work of its FollowsFromRef.
</span><span class="c1">//
</span><span class="c1">// All of the following could be valid timing diagrams for children that
</span><span class="c1">// &#34;FollowFrom&#34; a parent.
</span><span class="c1">//
</span><span class="c1">//     [-Parent Span-]  [-Child Span-]
</span><span class="c1">//
</span><span class="c1">//
</span><span class="c1">//     [-Parent Span--]
</span><span class="c1">//      [-Child Span-]
</span><span class="c1">//
</span><span class="c1">//
</span><span class="c1">//     [-Parent Span-]
</span><span class="c1">//                 [-Child Span-]
</span><span class="c1">//
</span><span class="c1">// See http://opentracing.io/spec/
</span><span class="c1">//
</span><span class="c1">// See opentracing.FollowsFrom()
</span><span class="c1"></span><span class="nx">FollowsFromRef</span>
</code></pre></div><h3 id="传播追踪信息">传播追踪信息</h3>
<p>为了在分布式系统中跨进程边界进行追踪,服务需要具备继续追踪每个被客户端注入追踪信息的请求.OpenTracing通过提供了<code>Inject</code>和<code>Extract</code>方法来实现此目标,将<code>Span</code>的上下文编码为载体.<code>Inject</code>方法可以将<code>SpanContext</code>传递到<code>carrier</code>中.举例,传递追踪信息到客户端请求中,这样下游服务就能继续进行跟踪了.<code>Extract</code>方法作用是相反的,从<code>carrier</code>中提取出<code>SpanContext</code>.
<img src="/images/tracing_extract.png" alt="跨进程追踪" title="跨进程边界追踪"></p>
<h2 id="inject和extract">Inject和Extract</h2>
<p>开发人员在添加跨进程边界的追踪代码时必须懂得OpenTracing规范中定义的<code>Tracer.Inject</code>和<code>Tracer.Extract</code>的能力.它们在概念上很强大,允许开发人员编写正确和通用的跨进程传播代码,而不用绑定到某种特定的OpenTracing实现上.</p>
<p>无论特定的OpenTracing语言或具体的实现如何,下面会简要介绍Inject和Extract的设计以及正确使用.</p>
<h3 id="用于追踪传播的全景图">用于追踪传播的全景图</h3>
<p>对于分布式追踪系统来说最困难的部分是分布式.任何追踪系统都需要一种了解许多不同进程中活动之间的因果关系的方式,不论这些进程是通过RPC框架、订阅/发布系统、通用消息队列、HTTP调用、UDP或其它方式连接的.</p>
<p>有些分布式追踪系统(2003年的<a href="http://dl.acm.org/citation.cfm?id=945454">Project5</a>,或2006年的<a href="http://www.2006.org/programme/item.php?id=2033">WAP5</a>或2014年的<a href="https://www.usenix.org/node/186168">The Mystery Machine</a>)可以推断出跨进程边界的因果关系.</p>
<h3 id="opentracing传播方案的要求">OpenTracing传播方案的要求</h3>
<p>为了使<code>Inject</code>和<code>Extract</code>方案有效,必须满足以下所有条件:</p>
<ul>
<li>使用OpenTracing在跨进程传播时必须不能依赖特定分布式追踪系统的代码.</li>
<li>实现OpenTracing规范的系统必须不能为每种已知的进程间通信机制做特殊处理,否则会有太多的工作,甚至定义不明确.</li>
<li>传播机制为了优化可扩展.</li>
</ul>
<h3 id="基本元素injectextract和carriers">基本元素:Inject,Extract和Carriers</h3>
<p>trace中的任何<code>SpanContext</code>都可以注入到OpenTracing称为<code>Carriers</code>之中,<code>Carriers</code>可以是接口或者结构,可用于进程间通信(IPC).把trace的状态从一个进程传递到另一个进程.OpenTracing规范包含两种<code>Carriesrs</code>格式,但也可以自定义格式.</p>
<p>类似的,给定一个被注入了trace的<code>Carriers</code>,可以被提取出来从而生成一个<code>SpanContext</code>实例,该实例在语义上与被注入到<code>Carriers</code>中的保持一致.</p>
<p><strong>Inject代码</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">TextMapCarrier</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Inject</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">TextMap</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
</code></pre></div><p><strong>Extract代码</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">TextMapCarrier</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">md</span> <span class="p">{</span>
    <span class="nx">carrier</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>

<span class="nx">spanctx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">TextMap</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
<span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">FullMethod</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">spanctx</span><span class="p">))</span>
</code></pre></div><h3 id="injectextract格式">Inject/Extract格式</h3>
<p>支持OpenTracing规范的所有追踪系统都必须支持两个格式:<code>text map</code>格式和<code>binary</code>格式.</p>
<ul>
<li>text map格式是一个string-&gt;string的映射.</li>
<li>binary格式是不透明的字节数组(并且可能更紧凑和高效).</li>
</ul>
<p>OpenTracing规范并没有规定怎么去存储这些<code>Carriers</code>,但前提是要找到一种方法对传播的SpanContext的trace状态进行编码(例如,在Dapper中定义了<code>trace_id</code>,<code>span_id</code>,还有采样状态掩码)以及任何key:value的Baggage Items.</p>
<p>不能指望不同的分布式追踪系统(实现了OpenTracing规范的)以兼容的方式注入和提取<code>SpanContext</code>,虽然OpenTracing对于跨整个分布式系统的跟踪的具体实现是不可知的,但对于传播双方的进程都使用相同的实现.</p>
<p><strong>一个端到端的传播例子</strong></p>
<ul>
<li>客户端进程拥有一个<code>SpanContext</code>实例,准备发起一个基于HTTP协议的RPC请求.</li>
<li>客户端调用<code>Tracer.Inject(...)</code>,传递当前的<code>SpanContext</code>实例,采用<code>text map</code>格式,把其作为参数.</li>
<li>Inject把<code>text map</code>注入到Carrier中,客户端程序把数据编码写入HTTP协议中(一般是放入headers中).</li>
<li>发起HTTP请求,数据跨进程边界传输.</li>
<li>在服务端,应用程序从HTTP协议中提取text map数据,并初始化为一个Carrier.</li>
<li>服务端程序调用<code>Tracer.Extract(...)</code>,传入text map格式的名称和上面生成的Carrier.</li>
<li>在没有数据损坏或其它错误的情况下,服务端获取了一个<code>SpanContext</code>实例,和客户端的是同一个.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>CMake语法说明</title>
			<link>https://shenbaise9527.com/posts/cmake%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</link>
			<pubDate>Sat, 28 Nov 2020 20:06:39 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/cmake%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</guid>
			<description>预定义变量 PROJECT_SOURCE_DIR 工程的根目录 PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build CMAKE_INCLUDE_PATH 环境变量,非CMake变量</description>
			<content type="html"><![CDATA[<h2 id="预定义变量">预定义变量</h2>
<ul>
<li>PROJECT_SOURCE_DIR 工程的根目录</li>
<li>PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build</li>
<li>CMAKE_INCLUDE_PATH 环境变量,非CMake变量</li>
<li>CMAKE_LIBRARY_PATH 环境变量</li>
<li>CMAKE_CURRENCT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径</li>
<li>CMAKE_CURRENT_BINARY_DIR target编译目录
<ul>
<li>使用ADD_SUBDIRECTORY(src bin)可以更改此变量的值</li>
<li>使用SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对此变量有影响,只改变最终目标文件的存储路径</li>
</ul>
</li>
<li>CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径</li>
<li>CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行</li>
<li>CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径</li>
<li>EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存储路径</li>
<li>LIBRARY_OUTPUT_PATH 重新定义链接库的存储路径</li>
<li>PROJECT_NAME 返回通过PROJECT指令定义的项目名称</li>
<li>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS  用来控制</li>
</ul>
<h2 id="系统信息">系统信息</h2>
<ul>
<li>CMAKE_MAJOR_VERSION cmake的主版本号,如2.8.6中的2</li>
<li>CMAKE_MINOR_VERSION cmake的次版本号,如2.8.6中的8</li>
<li>CMAKE_PATCH_VERSION cmake的补丁等级,如2.8.6中的6</li>
<li>CMAKE_SYSTEM 系统名称,如Linux-2.6.22</li>
<li>CMAKE_SYSTEM_NAME 不包含版本的系统名,如Linux</li>
<li>CMAKE_SYSTEM_VERSION 系统版本,如2.6.22</li>
<li>CMAKE_SYSTEM_PROCESSOR 处理器名称,如i386</li>
<li>UNIX 在所有的类UNIX平台为TRUE,包括OS x和cygwin</li>
<li>WIN32 在所有的win32平台为TRUE,包括cygwin</li>
</ul>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>
<p>PROJECT 指定工程名称,PROJECT(projectname)</p>
</li>
<li>
<p>SET 定义变量,SET(VAR [VALUE]),可以定义多个value,空格分隔</p>
</li>
<li>
<p>MESSAGE 向终端输出用户定义的信息或变量的值,MESSAGE([SEND_ERROR|STAUTS|FATAL_ERROR] &ldquo;display&rdquo;)</p>
<ul>
<li>SEND_ERROR 产生错误,生成过程被跳过</li>
<li>STATUS 输出前缀为&ndash;的信息</li>
<li>FATAL_ERROR 立即终止所有cmake过程</li>
</ul>
</li>
<li>
<p>ADD_EXECUTABLE 生成可执行文件,ADD_EXECUTABLE(bin_file_name SRC_LIST)</p>
</li>
<li>
<p>ADD_LIBRARY 生成动态库或静态库,ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUED_FROM_ALL] SRC_LIST)</p>
<ul>
<li>SHARED 动态库</li>
<li>STATIC 静态库</li>
<li>MODULE 在使用dyld的系统有效,否则等同于SHARED</li>
<li>EXCLUED_FROM_ALL 表示该库不会被默认构建</li>
</ul>
</li>
<li>
<p>SET_TARGET_PROPERTIES 设置输出的名称,设置动态库的版本和API的版本</p>
</li>
<li>
<p>CMAKE_MINIMUN_REQUIRED 声明CMake的版本要求</p>
</li>
<li>
<p>ADD_SUBDIRECTORY 添加子目录,ADD_SUBDIRECTORY(dir [binary_dir][EXCLUDE_FROM_ALL])</p>
<ul>
<li>binary_dir 指定中间二进制和目标二进制文件的存储位置</li>
<li>EXCLUDE_FROM_ALL 将这个目录中编译过程中排除</li>
</ul>
</li>
<li>
<p>INCLUDE_DIRECTORIES 向工程添加多个特定的头文件搜索路径,路径之间用空格分隔</p>
</li>
<li>
<p>LINK_DIRECTORIES 添加非标准的共享库搜索路径</p>
</li>
<li>
<p>TARGET_LINK_LIBRARIES 为target添加需要链接的共享库</p>
</li>
<li>
<p>ADD_DEFINITIONS 向C/C++编译器添加-D定义,参数之间用空格分隔</p>
</li>
<li>
<p>ADD_DEPENDENCIES 定义target依赖的其它target,确保target在构建之前,其依赖的target已构建完毕</p>
</li>
<li>
<p>AUX_SOURCE_DERICTORY 发现一个目录下的所有源代码文件并将列表存储在一个变量中</p>
</li>
<li>
<p>EXEC_PROGRAM 用于在指定目录运行某个程序(默认为当前CMakeLists.txt目录)</p>
</li>
<li>
<p>INCLUDE 用来载入CMakeLists.txt或预定义的cmake模块</p>
</li>
<li>
<p>FIND_FILE 查找文件,FIND_FILE(<!-- raw HTML omitted --> name path1 path2 &hellip;),VAR表示找到的文件全路径,包括文件名</p>
</li>
<li>
<p>FIND_LIBRARY 查找库</p>
</li>
<li>
<p>FIND_PATH 查找路径</p>
</li>
<li>
<p>FIND_FILE</p>
</li>
<li>
<p>IF 语法</p>
<blockquote>
<p>IF (expression) 判断条件是否为真
IF (not exp) 与上面相反
IF (var1 and var2) 判断2个条件是否都为真
IF (var1 or var2) 判断2个条件是否至少有1个为真
IF (COMMAND cmd) 判断cmd是否为命令并可调用
IF (EXISTS dir) 判断dir目录是否存在
IF (EXISTS file) 判断file文件是否存在
IF (file1 IS_NEWER_THAN file2) 当file1比file2新,或file1/file2中有一个不存在时为真,使用全路径
IF (IS_DIRECTORY dir) 当dir时路径时为真
IF (DEFINED var) 若var被定义,为真
IF (var MATCHES regex) 当变量var匹配正则表达式regex时,为真</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">IF</span> <span class="p">(</span><span class="s">&#34;hello&#34;</span> <span class="nx">MATCHES</span> <span class="s">&#34;ell&#34;</span><span class="p">)</span>
    <span class="nf">MESSAGE</span><span class="p">(</span><span class="s">&#34;true&#34;</span><span class="p">)</span>
<span class="nf">ENDIF</span> <span class="p">(</span><span class="s">&#34;hello&#34;</span> <span class="nx">MATCHES</span> <span class="s">&#34;ell&#34;</span><span class="p">)</span>
</code></pre></div></li>
<li>
<p>WHILE</p>
</li>
<li>
<p>FOREACH
列表格式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">FOREACH</span><span class="p">(</span><span class="nx">loop_var</span> <span class="nx">arg1</span> <span class="nx">arg2</span> <span class="o">...</span><span class="p">)</span>
  <span class="nf">COMMAND1</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
  <span class="nf">COMMAND2</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">loop_var</span><span class="p">)</span>
  
<span class="nf">AUX_SOURCE_DERICTORY</span><span class="p">(.</span> <span class="nx">SRC_LIST</span><span class="p">)</span>
<span class="nf">FOREACH</span><span class="p">(</span><span class="nx">F</span> <span class="err">$</span><span class="p">{</span><span class="nx">SRC_LIST</span><span class="p">})</span>
  <span class="nf">MESSAGE</span><span class="p">(</span><span class="err">$</span><span class="p">{</span><span class="nx">F</span><span class="p">})</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span>
</code></pre></div><p>范围格式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">FOREACH</span><span class="p">(</span><span class="nx">loop_var</span> <span class="nx">RANGE</span> <span class="nx">total</span><span class="p">)</span>
  <span class="nf">COMMAND1</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
  <span class="nf">COMMAND2</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">loop_var</span><span class="p">)</span>
  
<span class="nf">FOREACH</span><span class="p">(</span><span class="nx">VAR</span> <span class="nx">RANGE</span> <span class="mi">10</span><span class="p">)</span>
  <span class="nf">MESSAGE</span><span class="p">(</span><span class="err">$</span><span class="p">{</span><span class="nx">VAR</span><span class="p">})</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">VAR</span><span class="p">)</span>
</code></pre></div><p>范围和步进格式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">FOREACH</span><span class="p">(</span><span class="nx">loop_var</span> <span class="nx">RANGE</span> <span class="nx">start</span> <span class="nx">stop</span> <span class="p">[</span><span class="nx">step</span><span class="p">])</span>
  <span class="nf">COMMAND1</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
  <span class="nf">COMMAND2</span><span class="p">(</span><span class="nx">ARGS</span> <span class="o">...</span><span class="p">)</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">loop_var</span><span class="p">)</span>
  
<span class="nf">FOREACH</span><span class="p">(</span><span class="nx">A</span> <span class="nx">RANGE</span> <span class="mi">5</span> <span class="mi">15</span> <span class="mi">3</span><span class="p">)</span>
  <span class="nf">MESSAGE</span><span class="p">(</span><span class="err">$</span><span class="p">{</span><span class="nx">A</span><span class="p">})</span>
<span class="nf">ENDFOREACH</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span>
</code></pre></div></li>
</ul>
<h2 id="开关选项">开关选项</h2>
<ul>
<li>BUILD_SHARED_LIBS 控制默认的库编译方式.若未设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的都是静态库</li>
<li>CMAKE_C_FLAGS 设置C编译选项</li>
<li>CMAKE_CXX_FLAGS 设置C++编译选项</li>
</ul>
<h2 id="添加子文件夹">添加子文件夹</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">设置查找目录</span>
<span class="nf">set</span><span class="p">(</span><span class="nx">plugins_dir</span> <span class="err">$</span><span class="p">{</span><span class="nx">CMAKE_CURRENT_LIST_DIR</span><span class="p">}</span><span class="o">/</span><span class="nx">plugins</span><span class="o">/</span><span class="p">)</span>

<span class="err">#</span> <span class="nx">运行脚本查找对应的子目录</span><span class="p">,</span><span class="nx">并存放到变量dirs中</span>
<span class="nf">execute_process</span><span class="p">(</span>
    <span class="nx">COMMAND</span> <span class="nx">sh</span> <span class="err">$</span><span class="p">{</span><span class="nx">CMAKE_CURRENT_LIST_DIR</span><span class="p">}</span><span class="o">/</span><span class="nx">findplugin</span><span class="p">.</span><span class="nx">sh</span> <span class="err">$</span><span class="p">{</span><span class="nx">plugins_dir</span><span class="p">}</span>
    <span class="nx">OUTPUT_VARIABLE</span> <span class="nx">dirs</span><span class="p">)</span>

<span class="err">#</span> <span class="nx">把字符串变量转换为列表RPLACE_LIST</span>
<span class="nb">string</span><span class="p">(</span><span class="nx">REPLACE</span> <span class="s">&#34;\n&#34;</span> <span class="s">&#34;;&#34;</span> <span class="nx">RPLACE_LIST</span> <span class="err">$</span><span class="p">{</span><span class="nx">dirs</span><span class="p">})</span>

<span class="err">#</span> <span class="nx">循环</span><span class="p">,</span><span class="nx">把每个plugin加入到编译中</span>
<span class="nf">foreach</span> <span class="p">(</span><span class="nx">miapi</span> <span class="err">$</span><span class="p">{</span><span class="nx">RPLACE_LIST</span><span class="p">})</span>
    <span class="nf">ADD_SUBDIRECTORY</span><span class="p">(</span><span class="err">$</span><span class="p">{</span><span class="nx">plugins_dr</span><span class="p">}</span><span class="err">$</span><span class="p">{</span><span class="nx">miapi</span><span class="p">}</span> <span class="err">$</span><span class="p">{</span><span class="nx">CMAKE_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="err">$</span><span class="p">{</span><span class="nx">miapi</span><span class="p">})</span>
<span class="nf">endforeach</span><span class="p">(</span><span class="nx">miapi</span><span class="p">)</span>
</code></pre></div><h2 id="add_custom_command">add_custom_command</h2>
<p>增加定制化的构建规则到构建系统中,有两种使用方式</p>
<h3 id="增加一个定制化命令来产生一个输出">增加一个定制化命令来产生一个输出</h3>
<p>语法格式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">ADD_CUSTOM_COMMAND</span><span class="p">(</span><span class="nx">OUTPUT</span> <span class="nx">output1</span> <span class="p">[</span><span class="nx">output2</span> <span class="o">...</span><span class="p">]</span>
    <span class="nx">COMMAND</span> <span class="nx">command1</span> <span class="p">[</span><span class="nx">ARGS</span><span class="p">]</span> <span class="p">[</span><span class="nx">arg1</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">COMMAND</span> <span class="nx">command2</span> <span class="p">[</span><span class="nx">ARGS</span><span class="p">]</span> <span class="p">[</span><span class="nx">arg2</span> <span class="o">...</span><span class="p">]</span><span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">MAIN_DEPENDENCY</span> <span class="nx">depend</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">DEPENDS</span> <span class="p">[</span><span class="nx">depends</span> <span class="o">...</span><span class="p">]]</span>
    <span class="p">[</span><span class="nx">IMPLICIT_DEPENDS</span> <span class="p">&lt;</span><span class="nx">lang1</span><span class="p">&gt;</span> <span class="nx">depend1</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">WORKING_DIRECTORY</span> <span class="nx">dir</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">COMMENT</span> <span class="nx">comment</span><span class="p">]</span> <span class="p">[</span><span class="nx">VERBATIM</span><span class="p">]</span> <span class="p">[</span><span class="nx">APPEND</span><span class="p">])</span>
<span class="err">#</span> <span class="nx">不要同时在多个相互独立的目标中执行上述命令产生相同的文件</span><span class="p">,</span><span class="nx">主要是为了防止产生冲突</span><span class="p">.</span>
<span class="err">#</span> <span class="nx">如果有多条命令</span><span class="p">,</span><span class="nx">会按顺序执行</span><span class="p">.</span>
<span class="err">#</span> <span class="nx">ARGS是为了向后兼容</span><span class="p">,</span><span class="nx">使用过程中可以忽略</span>
<span class="err">#</span> <span class="nx">MAIN_DEPENDENCY完全是可选的</span><span class="p">,</span><span class="nx">是针对VS给出的一个建议</span>

<span class="err">#</span> <span class="nx">例子</span><span class="p">,</span><span class="nx">copy复制文件</span><span class="p">.</span>
<span class="nf">ADD_CUSTOM_COMMAND</span><span class="p">(</span><span class="nx">OUTPUT</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">}</span>
    <span class="nx">COMMAND</span> <span class="err">$</span><span class="p">{</span><span class="nx">CMAKE_COMMAND</span><span class="p">}</span> <span class="o">-</span><span class="nx">E</span> <span class="nx">copy</span> <span class="err">$</span><span class="p">{</span><span class="nx">src_sql_xml</span><span class="p">}</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">}</span>
    <span class="nx">COMMENT</span> <span class="s">&#34;copy ${src_sql_xml} \nto ${dst_sql_xml}&#34;</span>
    <span class="nx">DEPENDS</span> <span class="err">$</span><span class="p">{</span><span class="nx">src_sql_xml</span><span class="p">})</span>
<span class="nf">ADD_CUSTOM_TARGET</span><span class="p">(</span><span class="nx">syncxml</span> <span class="nx">ALL</span> <span class="nx">DEPENDS</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">})</span>

<span class="err">#</span> <span class="nx">例子</span><span class="p">,</span><span class="nx">copy_directory复制文件夹</span><span class="p">.</span>
<span class="nf">ADD_CUSTOM_COMMAND</span><span class="p">(</span><span class="nx">OUTPUT</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">}</span>
    <span class="nx">COMMAND</span> <span class="err">$</span><span class="p">{</span><span class="nx">CMAKE_COMMAND</span><span class="p">}</span> <span class="o">-</span><span class="nx">E</span> <span class="nx">copy_directory</span> <span class="err">$</span><span class="p">{</span><span class="nx">src_sql_xml</span><span class="p">}</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">}</span>
    <span class="nx">COMMENT</span> <span class="s">&#34;copy_directory ${src_sql_xml} \nto ${dst_sql_xml}&#34;</span>
    <span class="nx">DEPENDS</span> <span class="err">$</span><span class="p">{</span><span class="nx">src_sql_xml</span><span class="p">})</span>
<span class="nf">ADD_CUSTOM_TARGET</span><span class="p">(</span><span class="nx">syncxml</span> <span class="nx">ALL</span> <span class="nx">DEPENDS</span> <span class="err">$</span><span class="p">{</span><span class="nx">dst_sql_xml</span><span class="p">})</span>
</code></pre></div><h3 id="标记在什么时候执行命令编译前编译后链接前">标记在什么时候执行命令:编译前、编译后、链接前</h3>
<p>语法格式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">ADD_CUSTOM_COMMAND</span><span class="p">(</span><span class="nx">TARGET</span> <span class="nx">target</span>
    <span class="nx">PRE_BUILD</span> <span class="p">|</span> <span class="nx">PRE_LINK</span> <span class="p">|</span> <span class="nx">POST_BUILD</span>
    <span class="nx">COMMAND</span> <span class="nx">command1</span> <span class="p">[</span><span class="nx">ARGS</span><span class="p">]</span> <span class="p">[</span><span class="nx">args1</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">COMMAND</span> <span class="nx">command2</span> <span class="p">[</span><span class="nx">ARGS</span><span class="p">]</span> <span class="p">[</span><span class="nx">args2</span> <span class="o">...</span><span class="p">]</span><span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">WORKINGDIRECTORY</span> <span class="nx">dir</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">COMMENT</span> <span class="nx">comment</span><span class="p">]</span> <span class="p">[</span><span class="nx">VERBATIM</span><span class="p">])</span>
<span class="err">#</span> <span class="nx">PRE_BUILD</span> <span class="nx">命令将会在其它依赖项执行前执行</span><span class="p">,</span><span class="nx">只被VS7及之后的版本支持</span><span class="p">,</span><span class="nx">其它会将其等同于PRE_LINK</span>
<span class="err">#</span> <span class="nx">PRE_LINK</span> <span class="nx">命令将会在其它依赖项执行完后执行</span>
<span class="err">#</span> <span class="nx">POST_BUILD</span> <span class="nx">命令将会在目标构建完后执行</span>
<span class="err">#</span> <span class="nx">如果指定了WORKINGDIRECTORY</span><span class="p">,</span><span class="nx">命令将会在指定目录运行</span>
<span class="err">#</span> <span class="nx">如果指定了COMMENT</span><span class="p">,</span><span class="nx">命令执行前会把COMMENT的内容当做信息输出</span>
<span class="err">#</span> <span class="nx">如果指定了APPEND</span><span class="p">,</span><span class="nx">COMMANDS和DEPENDS的值会追加到第一个指定的命令中</span>
<span class="err">#</span> <span class="nx">如果指定了APPEND</span><span class="p">,</span><span class="nx">COMMENT</span><span class="err">、</span><span class="nx">WORKINGDIRECTORY和MAIN_DEPENDENCY将会被忽略</span>
<span class="err">#</span> <span class="nx">如果指定了VERBATIM</span><span class="p">,</span><span class="nx">所传递的命令参数会被适当地转义</span>
<span class="err">#</span> <span class="nx">如果指定命令的输出不是创建一个存储在磁盘上的文件</span><span class="p">,</span><span class="nx">需使用SET_SOURCE_FILE_PROPERTIES把它标记为SYMBOLIC</span>
<span class="err">#</span> <span class="nx">如果COMMAND指定了一个可执行的目标</span><span class="p">(</span><span class="nx">由ADD_EXECUTABLE创建</span><span class="p">),</span><span class="nx">则会</span>
<span class="err">#</span> <span class="nx">DEPENDS指定了该命令依赖的文件</span>
</code></pre></div><h3 id="add_custom_target">add_custom_target</h3>
<p>使用该命令增加一个没有输出的目标,使得它总是被构建</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">ADD_CUSTOM_TARGET</span><span class="p">(</span><span class="nx">Name</span> <span class="p">[</span><span class="nx">ALL</span><span class="p">]</span>
    <span class="nx">COMMAND</span> <span class="nx">command1</span> <span class="p">[</span><span class="nx">ARGS</span><span class="p">]</span> <span class="p">[</span><span class="nx">args1</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">DEPENDS</span> <span class="nx">depend</span> <span class="nx">depend</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">WORKINGDIRECTORY</span> <span class="nx">dir</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">COMMENT</span> <span class="nx">comment</span><span class="p">]</span> <span class="p">[</span><span class="nx">VERBATIM</span><span class="p">]</span>
    <span class="p">[</span><span class="nx">SOURCES</span> <span class="nx">src1</span> <span class="p">[</span><span class="nx">src2</span> <span class="o">...</span><span class="p">]])</span>
<span class="err">#</span> <span class="nx">该目标没有输出</span><span class="p">,</span><span class="nx">总是被认为过期的</span>
<span class="err">#</span> <span class="nx">如果指定了ALL</span><span class="p">,</span><span class="nx">表明目标会被添加到默认的构建目标</span><span class="p">,</span><span class="nx">使得它每次都会被运行</span>
<span class="err">#</span> <span class="nx">具体可以参见上面的例子</span>
</code></pre></div><h2 id="faq">FAQ</h2>
<ol>
<li>设置条件编译</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">option</span><span class="p">(</span><span class="nx">DEBUG_mode</span> <span class="s">&#34;ON for debug or OFF for release&#34;</span> <span class="nx">ON</span><span class="p">)</span>
<span class="nf">IF</span><span class="p">(</span><span class="nx">DEBUG_mode</span><span class="p">)</span>
    <span class="nf">add_definitions</span><span class="p">(</span><span class="o">-</span><span class="nx">DDEBUG</span><span class="p">)</span>
<span class="nf">ENDIF</span><span class="p">()</span>
</code></pre></div><ol start="2">
<li>根据OS指定编译选项
IF(WIN32) IF(APPLE) IF(UNIX)</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>makefile语法说明</title>
			<link>https://shenbaise9527.com/posts/makefile%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</link>
			<pubDate>Sat, 28 Nov 2020 20:06:12 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/makefile%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</guid>
			<description>CFLAGS 表示用于C编译器的选项. 指定头文件的路径. INCLUDES := -I./ INCLUDES += -I/usr/include INCLUDES += -I/usr/local/include INCLUDES += -I../../../3rd/curl-7.65.0/include INCLUDES += -I../../../3rd/mimetic-0.9.8/include CFLAGS := -m64 -std=c++11 -g -Wall -O3 $(INCLUDES) CXXFLAGS 表示用于C++编译器的选项,基本同CFLAGS LDFLAGS</description>
			<content type="html"><![CDATA[<h2 id="cflags">CFLAGS</h2>
<p>表示用于C编译器的选项.
指定头文件的路径.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">INCLUDES</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">I</span><span class="p">.</span><span class="o">/</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">curl</span><span class="o">-</span><span class="mf">7.65.0</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">mimetic</span><span class="o">-</span><span class="mf">0.9.8</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">m64</span> <span class="o">-</span><span class="nx">std</span><span class="p">=</span><span class="nx">c</span><span class="o">++</span><span class="mi">11</span> <span class="o">-</span><span class="nx">g</span> <span class="o">-</span><span class="nx">Wall</span> <span class="o">-</span><span class="nx">O3</span> <span class="err">$</span><span class="p">(</span><span class="nx">INCLUDES</span><span class="p">)</span>
</code></pre></div><h2 id="cxxflags">CXXFLAGS</h2>
<p>表示用于C++编译器的选项,基本同CFLAGS</p>
<h2 id="ldflags">LDFLAGS</h2>
<p>编译器会用到的一些优化参数,也可指定库文件的位置,告诉链接器从哪里寻找库文件.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">LDFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">ssl</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">curl</span><span class="o">-</span><span class="mf">7.65.0</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">mimetic</span><span class="o">-</span><span class="mf">0.9.8</span><span class="o">/</span><span class="nx">lib</span>
</code></pre></div><h2 id="libs">LIBS</h2>
<p>告诉链接器需要链接哪些文件.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">LIBS</span> <span class="p">=</span> <span class="o">-</span><span class="nx">lmimetic</span> <span class="o">-</span><span class="nx">lcurl</span> <span class="o">-</span><span class="nx">lrt</span> <span class="o">-</span><span class="nx">static</span><span class="o">-</span><span class="nx">libgcc</span> <span class="o">-</span><span class="nx">static</span><span class="o">-</span><span class="nx">libstdc</span><span class="o">++</span>
</code></pre></div><h2 id="include">include</h2>
<p>语法: include <!-- raw HTML omitted --></p>
<h2 id="wildcard">wildcard</h2>
<h1 id="隐晦规则">隐晦规则</h1>
<ol>
<li>make看到一个.o文件,就会自动把对应的.c文件加在依赖关系中,并且cc -c xx.c也会被推导.</li>
</ol>
<h1 id="伪目标">伪目标</h1>
<p>.PHONY : clean
clean :
-rm xx ${objects}
表示clean是个伪目标,在rm前面加个小减号表示当某些文件出现问题时跳过,继续往下执行.</p>
<h1 id="工作方式">工作方式</h1>
<ol>
<li>读入所有的Makefile.</li>
<li>读入被include的其它Makefile.</li>
<li>初始化文件中的变量.</li>
<li>推导隐晦规则,并分析所有规则.</li>
<li>为所有的目标文件创建依赖关系链.</li>
<li>根据依赖关系,决定哪些目标要重新生成.</li>
<li>执行生成命令.</li>
</ol>
<h1 id="书写规则">书写规则</h1>
<ol>
<li>Makefile中只应该有一个最终目标,其它目标都是被连带出来的.</li>
<li>规则语法,targets是目标,prerequisites表示目标所依赖的文件或目标,command表示生成目标文件所需要执行的命令.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">targets</span> <span class="p">:</span> <span class="nx">prerequisites</span>
    <span class="nx">command</span>
</code></pre></div><ol start="3">
<li>在规则中使用通配符,支持三种(* ? [&hellip;]),*表示任意长度的字符串,转义字符为'/'</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">clean</span> <span class="p">:</span>
    <span class="nx">rm</span> <span class="o">-</span><span class="nx">f</span> <span class="o">*</span><span class="p">.</span><span class="nx">o</span>
<span class="c1">//　上面表示删除任意已.o结尾的文件.
</span><span class="c1"></span>
<span class="c1">// 需要注意用在变量中.
</span><span class="c1"></span><span class="nx">objects</span> <span class="p">=</span> <span class="o">*</span><span class="p">.</span><span class="nx">o</span>
<span class="c1">// objects的值就是&#34;*.o&#34;,并不会被展开,若想让objects的值是所有.o文件的集合，如下书写
</span><span class="c1"></span><span class="nx">objects</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="nx">wildcard</span> <span class="o">*</span><span class="p">.</span><span class="nx">o</span><span class="p">)</span>
</code></pre></div><ol start="4">
<li>文件搜寻
VPATH: Makefile中的特殊变量,指定文件搜寻目录.
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">VPATH</span> <span class="p">=</span> <span class="nx">src</span> <span class="p">:</span> <span class="p">..</span><span class="o">/</span><span class="nx">headers</span>
<span class="c1">// make会自动去src和../headers目录搜寻依赖文件.
</span></code></pre></div><p>vpath: make的关键字,按照某种模式去搜寻目录,多个目录以:分隔.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">vpath</span> <span class="p">&lt;</span><span class="nx">pattern</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">directories</span><span class="p">&gt;</span>
<span class="c1">// 为符合pattern模式的文件指定搜索目录directories.
</span><span class="c1"></span><span class="nx">vpath</span> <span class="p">&lt;</span><span class="nx">pattern</span><span class="p">&gt;</span>
<span class="c1">// 清除pattern模式的搜寻目录.
</span><span class="c1"></span><span class="nx">vpath</span>
<span class="c1">//　清除所有已被设置好的搜寻目录.
</span><span class="c1"></span><span class="nx">vpath</span> <span class="o">*</span><span class="p">.</span><span class="nx">h</span> <span class="p">..</span><span class="o">/</span><span class="nx">headers</span>
<span class="c1">// 在../headers目录下搜索所有以.h结尾的文件.
</span></code></pre></div></li>
</ol>
<h1 id="自动变量">自动变量</h1>
<ol>
<li>&ldquo;$@&quot;,表示目前规则中所有目标的集合,主要用于有多个目标的规则中.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bigoutput</span> <span class="nx">littleoutput</span> <span class="p">:</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span>
    <span class="nx">generate</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span> <span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="nx">substr</span> <span class="nx">output</span><span class="p">,,</span><span class="err">$@</span><span class="p">)</span> <span class="p">&gt;</span> <span class="err">$@</span>
<span class="c1">//　上述规则等价于
</span><span class="c1"></span><span class="nx">bigoutput</span> <span class="p">:</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span>
    <span class="nx">generate</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span> <span class="o">-</span><span class="nx">big</span> <span class="p">&gt;</span> <span class="nx">bigoutput</span>
<span class="nx">littleoutput</span> <span class="p">:</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span>
    <span class="nx">generate</span> <span class="nx">text</span><span class="p">.</span><span class="nx">g</span> <span class="o">-</span><span class="nx">little</span> <span class="p">&gt;</span> <span class="nx">littleoutput</span>
<span class="c1">// $@表示目标的集合,就像一个数组(2个元素bigoutput、littleoutput),$@依次取出目标并执行命令.
</span></code></pre></div><ol start="2">
<li>&ldquo;$&lt;&quot;,表示所有的依赖目标集,是一个一个取出来的.</li>
<li>&ldquo;$%&quot;,仅当目标是函数库文件时(.a或.lib),表示规则中的目标成员名.
如果目标&quot;foo.a(bar.o)&quot;,那&rdquo;$%&ldquo;就是bar.o,&quot;$@&ldquo;就是foo.a</li>
<li>&ldquo;$?&quot;,所有比目标新的依赖目标的集合,以空格分隔.</li>
<li>&ldquo;$^&quot;,所有的依赖目标的集合,以空格分隔,会去除重复的.</li>
<li>&ldquo;$*&quot;,表示目标模式中&rdquo;%&ldquo;及其之前的部分.如果目标是&quot;dir/a.foo.b&rdquo;,并且目标的模式是&quot;a.%.b&rdquo;,那么值就是&quot;dir/a.foo&rdquo;</li>
</ol>
<h1 id="静态模式">静态模式</h1>
<p>更容易定义多目标的规则.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 语法.
</span><span class="c1"></span><span class="p">&lt;</span><span class="nx">targets</span> <span class="o">...</span><span class="p">&gt;</span> <span class="p">:</span> <span class="p">&lt;</span><span class="nx">target</span><span class="o">-</span><span class="nx">pattern</span><span class="p">&gt;</span> <span class="p">:</span> <span class="p">&lt;</span><span class="nx">prereq</span><span class="o">-</span><span class="nx">patterns</span> <span class="o">...</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nx">command</span><span class="p">&gt;</span>
<span class="c1">// targets: 定义了一系列的目标文件,可以有通配符.是目标的一个集合.
</span><span class="c1">// target-pattern: 指明了targets的模式,也就是目标集的模式.
</span><span class="c1">// prereq-patterns: 目标的依赖模式.对target-pattern形成的模式再进行一次依赖目标的定义.
</span><span class="c1"></span>
<span class="nx">objects</span> <span class="p">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">o</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">o</span>
<span class="nx">all</span> <span class="p">:</span> <span class="err">$</span><span class="p">(</span><span class="nx">objects</span><span class="p">)</span>
<span class="err">$</span><span class="p">(</span><span class="nx">objects</span><span class="p">)</span> <span class="p">:</span> <span class="o">%</span><span class="p">.</span><span class="nx">o</span> <span class="p">:</span> <span class="o">%</span><span class="p">.</span><span class="nx">c</span>
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="o">-</span><span class="nx">c</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">&lt;</span> <span class="o">-</span><span class="nx">o</span> <span class="err">$@</span>
<span class="c1">// 目标从objects中获取,%.o表明所有以&#34;.o&#34;结尾的目标,也就是&#34;foo.o和bar.o&#34;,这也是变量$ojbects集合的模式
</span><span class="c1">// 而依赖模式&#34;%.c&#34;则取模式&#34;%.o&#34;的&#34;%&#34;,即&#34;foo和bar&#34;,并为其加上.c后缀,则依赖的目标是&#34;foo.c和bar.c&#34;
</span><span class="c1">// $&lt;为自动化变量,表示所有的依赖目标集,即&#34;foo.c和bar.c&#34;
</span><span class="c1">// $@为自动化变量,表示目标集.
</span><span class="c1">//　上面规则等价于:
</span><span class="c1"></span><span class="nx">foo</span><span class="p">.</span><span class="nx">o</span> <span class="p">:</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">c</span>
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="o">-</span><span class="nx">c</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">c</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">o</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">o</span> <span class="p">:</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">c</span>
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="o">-</span><span class="nx">c</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">c</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">o</span>

<span class="c1">//　例子:
</span><span class="c1"></span><span class="nx">files</span> <span class="p">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">elc</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">o</span> <span class="nx">lose</span><span class="p">.</span><span class="nx">o</span>
<span class="err">$</span><span class="p">(</span><span class="nx">filter</span> <span class="o">%</span><span class="p">.</span><span class="nx">o</span><span class="p">,</span><span class="err">$</span><span class="p">(</span><span class="nx">files</span><span class="p">))</span> <span class="p">:</span> <span class="o">%</span><span class="p">.</span><span class="nx">o</span> <span class="p">:</span> <span class="o">%</span><span class="p">.</span><span class="nx">c</span>
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="o">-</span><span class="nx">c</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">&lt;</span> <span class="o">-</span><span class="nx">o</span> <span class="err">$@</span>
<span class="c1">// filter为过滤函数.
</span></code></pre></div><h1 id="变量">变量</h1>
<ol>
<li>操作符&rdquo;=&quot;,右侧变量的值可以不用提前定义.</li>
<li>操作符&rdquo;:=&quot;,右侧变量的值必须在这之前定义.</li>
<li>操作符&rdquo;?=&quot;,如果变量之前没有被定义过,那变量的值就是右侧的值;否则什么也不做.</li>
<li>变量值的替换,$(var:a=b),把变量var中所有以&quot;a&quot;子串结尾的&quot;a&quot;替换成&quot;b&quot;子串,结尾指空格或结束符</li>
<li>操作符&rdquo;+=&quot;,给变量追加值.</li>
</ol>
<h1 id="条件表达式">条件表达式</h1>
<ol>
<li>ifeq</li>
<li>ifneq</li>
<li>ifdef</li>
<li>ifndef</li>
</ol>
<h1 id="函数">函数</h1>
<ol>
<li>$(subst <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->),把字符串text中的&quot;from&quot;替换为&quot;to&quot;</li>
<li>$(patsubst <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->),查找字符串text中是否有符合模式&quot;pattern&quot;,如果匹配则以&quot;replacement&quot;替换.
&ldquo;replacement&quot;中也可以包含&rdquo;%&quot;,指&quot;pattern&quot;中那个&quot;%&ldquo;所代表的子串.</li>
<li>$(stip <!-- raw HTML omitted -->),去掉字符串string中开头和结尾的空字符.</li>
<li>$(findstring <!-- raw HTML omitted -->,<!-- raw HTML omitted -->),在字符串&quot;in&quot;中查找&quot;find&rdquo;,如果找到返回&quot;find&quot;,否则返回空字符串.</li>
<li>$(filter &lt;pattern&hellip;&gt;,<!-- raw HTML omitted -->),以&quot;pattern&quot;模式过滤&quot;text&quot;字符串中的单词,保留符合&quot;pattern&quot;的单词.可以有多个模式.
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sources</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">c</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">c</span> <span class="nx">baz</span><span class="p">.</span><span class="nx">s</span> <span class="nx">ugh</span><span class="p">.</span><span class="nx">h</span>
<span class="nx">foo</span> <span class="p">:</span> <span class="err">$</span><span class="p">(</span><span class="nx">sources</span><span class="p">)</span>
     <span class="nx">cc</span> <span class="err">$</span><span class="p">(</span><span class="nx">filter</span> <span class="o">%</span><span class="p">.</span><span class="nx">c</span> <span class="o">%</span><span class="p">.</span><span class="nx">s</span><span class="p">,</span><span class="err">$</span><span class="p">(</span><span class="nx">sources</span><span class="p">))</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">foo</span>
<span class="c1">// filter返回的是foo.c bar.c baz.s,有２个模式%.c和%.s
</span></code></pre></div></li>
<li>$(filter-out &lt;pattern&hellip;&gt;,<!-- raw HTML omitted -->),反过滤函数.</li>
<li>$(sort <!-- raw HTML omitted -->),排序函数,给&quot;list&quot;中的单词升序的方式排序.会去掉相同的单词.</li>
<li>$(word <!-- raw HTML omitted -->,<!-- raw HTML omitted -->),取字符串&quot;text&quot;中的第n个单词(从1开始).</li>
<li>$(wordlist <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->),取单词串函数,从字符串&quot;text&quot;中取从<!-- raw HTML omitted -->到<!-- raw HTML omitted -->的单词串,s和e是一个数字.</li>
<li>$(words <!-- raw HTML omitted -->),单词个数统计函数.</li>
<li>$(firstword <!-- raw HTML omitted -->),首单词函数.</li>
<li>$(dir &lt;names&hellip;&gt;),取目录函数,从文件名序列中取出目录部分.</li>
<li>$(notdir &lt;names&hellip;&gt;),取文件函数,从文件名序列中取出非目录部分.</li>
<li>$(suffix &lt;names&hellip;&gt;),取后缀函数,从文件名序列中取出各个文件名的后缀.</li>
<li>$(basename &lt;names&hellip;&gt;),取前缀函数.</li>
<li>$(addsuffix <!-- raw HTML omitted -->,&lt;names&hellip;&gt;),加后缀函数.</li>
<li>$(addprefix <!-- raw HTML omitted -->,&lt;names&hellip;&gt;),加前缀函数.</li>
<li>$(join <!-- raw HTML omitted -->,<!-- raw HTML omitted -->),连接函数,把&quot;list2&quot;中的单词对应地加到&quot;list1&quot;的单词后面.
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">$</span><span class="p">(</span><span class="nx">join</span> <span class="nx">aaa</span> <span class="nx">bbb</span><span class="p">,</span><span class="mi">111</span> <span class="mi">222</span> <span class="mi">333</span><span class="p">)</span><span class="o">-</span><span class="p">&gt;</span><span class="s">&#34;aaa111 bbb222 333&#34;</span>
</code></pre></div></li>
<li>$(foreach <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->),把参数list中的单词逐一取出放到参数var中,然后再执行<!-- raw HTML omitted -->所包含的表达式.
``` go
names := a b c d
files := $(foreach n,$(names),$(n).o)
// files的值就是a.o b.o c.o d.o
<pre><code></code></pre></li>
<li>$(if <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->),else是可选的.</li>
<li>$(call <!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->,<!-- raw HTML omitted -->&hellip;),用参数依次取代&quot;expression&quot;中的变量.</li>
<li>$(origin <!-- raw HTML omitted -->),变量&quot;variable&quot;是从哪来的.
undefined: 表示该变量未定义.
default: 表示是默认定义的.
environment: 表示是环境变量.
file: 表示该变量定义在Makefile中
command line: 表示是被命令行定义的
override: 表示是被override指示符重新定义的
automatic:　表示是自动化变量</li>
</ol>
<h1 id="隐含规则">隐含规则</h1>
<ol>
<li>编译c程序的隐含规则,<!-- raw HTML omitted -->.o会自动推导为<!-- raw HTML omitted -->.c,命令是$(CC) -c $(CPPFLAGS) $(CFLAGS)</li>
<li>编译C++的隐含规则,<!-- raw HTML omitted -->.o会自动推导为<!-- raw HTML omitted -->.cc,命令是$(CXX) -c $(CPPFLAGS) $(CFLAGS)</li>
<li>链接Object文件的隐含规则,$(CC) $(LDFLAGS) <!-- raw HTML omitted -->.o $(LOADLIBES) $(LDLIBS)</li>
</ol>
<h2 id="变量-1">变量</h2>
<ol>
<li>CC,C语言编译程序,默认命令是&quot;cc&quot;</li>
<li>CXX,C++语言编译程序,默认命令是&quot;g++&quot;</li>
<li>RM,删除文件命令,默认命令是&quot;rm -f&quot;</li>
<li>CFLAGS,C语言编译器参数</li>
<li>CXXFLAGS,C++语言编译器参数</li>
<li>CPPFLAGS,C预处理器参数</li>
<li>LDFLAGS,链接器参数,如&quot;ld&quot;</li>
</ol>
<h1 id="模式规则">模式规则</h1>
<p>使用模式规则定义一个隐含规则.</p>
<h2 id="介绍">介绍</h2>
<p>模式规则中,至少在规则的目标定义中要包含&quot;%&quot;,否则就是一般的规则.目标中的&quot;%&ldquo;定义表示对文件名的匹配.
例子: %.o : %.c; <!-- raw HTML omitted --></p>
<h2 id="示例">示例</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="p">.</span><span class="nx">o</span> <span class="p">:</span> <span class="o">%</span><span class="p">.</span><span class="nx">c</span> 
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="o">-</span><span class="nx">c</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="nx">CPPFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">&lt;</span> <span class="o">-</span><span class="nx">o</span> <span class="err">$@</span>
<span class="c1">// $&lt; 表示依赖目标
</span><span class="c1">// $@ 表示目标
</span></code></pre></div><p>一个完整的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">SOURCE</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="nx">wildcard</span> <span class="o">*</span><span class="p">.</span><span class="nx">cpp</span><span class="p">)</span>
<span class="nx">OBJS</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="nx">patsubst</span> <span class="o">%</span><span class="p">.</span><span class="nx">cpp</span><span class="p">,</span><span class="o">%</span><span class="p">.</span><span class="nx">o</span><span class="p">,</span><span class="err">$</span><span class="p">(</span><span class="nx">SOURCE</span><span class="p">))</span>
<span class="nx">EXENAME</span> <span class="o">:=</span> <span class="nx">mail_agent</span>
<span class="nx">TARGET</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="nx">EXENAME</span><span class="p">)</span>
<span class="nx">CC</span> <span class="o">:=</span> <span class="nx">g</span><span class="o">++</span>
 
<span class="nx">INCLUDES</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">I</span><span class="p">.</span><span class="o">/</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">curl</span><span class="o">-</span><span class="mf">7.65.0</span><span class="o">/</span><span class="nx">include</span>
<span class="nx">INCLUDES</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">I</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">mimetic</span><span class="o">-</span><span class="mf">0.9.8</span><span class="o">/</span><span class="nx">include</span>
 
<span class="nx">LDFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">ssl</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">curl</span><span class="o">-</span><span class="mf">7.65.0</span><span class="o">/</span><span class="nx">lib</span>
<span class="nx">LDFLAGS</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">mimetic</span><span class="o">-</span><span class="mf">0.9.8</span><span class="o">/</span><span class="nx">lib</span>
 
<span class="nx">LIBS</span> <span class="p">=</span> <span class="o">-</span><span class="nx">lmimetic</span> <span class="o">-</span><span class="nx">lcurl</span> <span class="o">-</span><span class="nx">lrt</span> <span class="o">-</span><span class="nx">static</span><span class="o">-</span><span class="nx">libgcc</span> <span class="o">-</span><span class="nx">static</span><span class="o">-</span><span class="nx">libstdc</span><span class="o">++</span>
<span class="nx">CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">m64</span> <span class="o">-</span><span class="nx">std</span><span class="p">=</span><span class="nx">c</span><span class="o">++</span><span class="mi">11</span> <span class="o">-</span><span class="nx">g</span> <span class="o">-</span><span class="nx">Wall</span> <span class="o">-</span><span class="nx">O3</span> <span class="err">$</span><span class="p">(</span><span class="nx">INCLUDES</span><span class="p">)</span>
<span class="nx">CXXFLAGS</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="nx">CFLAGS</span><span class="p">)</span>
 
<span class="err">$</span><span class="p">(</span><span class="nx">TARGET</span><span class="p">)</span> <span class="p">:</span> <span class="err">$</span><span class="p">(</span><span class="nx">OBJS</span><span class="p">)</span>
    <span class="err">$</span><span class="p">(</span><span class="nx">CC</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="nx">CXXFLAGS</span><span class="p">)</span> <span class="o">-</span><span class="nx">o</span> <span class="err">$@</span> <span class="err">$</span><span class="p">(</span><span class="nx">OBJS</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="nx">LDFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="nx">LIBS</span><span class="p">)</span>
 
<span class="p">.</span><span class="nx">PHONY</span> <span class="p">:</span> <span class="nx">clean</span>
<span class="nx">clean</span><span class="p">:</span>
    <span class="o">-</span><span class="nx">rm</span> <span class="err">$</span><span class="p">(</span><span class="nx">OBJS</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="nx">TARGET</span><span class="p">)</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>MySQL的orderby分析</title>
			<link>https://shenbaise9527.com/posts/mysql%E7%9A%84orderby%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 24 Nov 2020 20:50:44 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/mysql%E7%9A%84orderby%E5%88%86%E6%9E%90/</guid>
			<description>数据准备 /*mysql版本*/ Server version: 5.7.27-log MySQL Community Server (GPL) /*创建表t*/ CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE=InnoDB; /*数据分布*</description>
			<content type="html"><![CDATA[<h2 id="数据准备">数据准备</h2>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*mysql版本*/</span>
<span class="n">Server</span> <span class="k">version</span><span class="p">:</span> <span class="mi">5</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">27</span><span class="o">-</span><span class="n">log</span> <span class="n">MySQL</span> <span class="n">Community</span> <span class="n">Server</span> <span class="p">(</span><span class="n">GPL</span><span class="p">)</span>

<span class="cm">/*创建表t*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">city</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">addr</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">city</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">city</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="cm">/*数据分布*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">t</span> <span class="k">group</span> <span class="k">by</span> <span class="n">city</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-----------+----------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">city</span>      <span class="o">|</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----------+----------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">beijing</span>   <span class="o">|</span>     <span class="mi">5590</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">gongan</span>    <span class="o">|</span>     <span class="mi">5398</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">guangzhou</span> <span class="o">|</span>     <span class="mi">5557</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span>  <span class="o">|</span>     <span class="mi">5505</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">ouchi</span>     <span class="o">|</span>     <span class="mi">5402</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">shanghai</span>  <span class="o">|</span>     <span class="mi">5375</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">shenzhen</span>  <span class="o">|</span>     <span class="mi">5591</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">wuhan</span>     <span class="o">|</span>     <span class="mi">5582</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----------+----------+
</span><span class="c1"></span><span class="mi">8</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><h2 id="带条件orderby过程分析">带条件orderby过程分析</h2>
<p>主要针对sql语句<code>select city, name, age from t where city='hangzhou' order by name limit 1000</code>来分析.</p>
<h3 id="全字段排序">全字段排序</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span>          <span class="o">|</span> <span class="n">city</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span><span class="p">;</span> <span class="k">Using</span> <span class="n">filesort</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>通过执行计划可以看出，<code>rows</code>扫描行数为5505，符合预期。<code>Using index condition</code>(索引下推,Index Condition Pushdown)使用了索引<code>city</code>来遍历。<code>Using filesort</code>使用了排序.</p>
<p>开启optimizer_trace，来跟踪执行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*打开optimizer_trace，只对本线程有效*/</span>
<span class="k">set</span> <span class="n">optimizer_trace</span><span class="o">=</span><span class="s1">&#39;enabled=on&#39;</span><span class="p">;</span>

<span class="cm">/*@a保存Innodb_rows_read的初始值*/</span>
<span class="k">select</span> <span class="n">variable_value</span> <span class="k">into</span> <span class="o">@</span><span class="n">a</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">session_status</span> <span class="k">where</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;Innodb_rows_read&#39;</span><span class="p">;</span>

<span class="cm">/*执行sql语句*/</span>
<span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>

<span class="cm">/*查看optimizer_trace输出*/</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">OPTIMIZER_TRACE</span><span class="err">\</span><span class="k">G</span>
<span class="cm">/*截图部分结果*/</span>
            <span class="s2">&#34;filesort_execution&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">],</span>
            <span class="s2">&#34;filesort_summary&#34;</span><span class="p">:</span> <span class="err">{</span>
              <span class="s2">&#34;rows&#34;</span><span class="p">:</span> <span class="mi">5505</span><span class="p">,</span>
              <span class="s2">&#34;examined_rows&#34;</span><span class="p">:</span> <span class="mi">5505</span><span class="p">,</span>
              <span class="s2">&#34;number_of_tmp_files&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
              <span class="s2">&#34;sort_buffer_size&#34;</span><span class="p">:</span> <span class="mi">262000</span><span class="p">,</span>
              <span class="s2">&#34;sort_mode&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;sort_key, packed_additional_fields&gt;&#34;</span>
            <span class="err">}</span>

<span class="cm">/*@b保存Innodb_rows_read的当前值*/</span>
<span class="k">select</span> <span class="n">variable_value</span> <span class="k">into</span> <span class="o">@</span><span class="n">b</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">session_status</span> <span class="k">where</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;Innodb_rows_read&#39;</span><span class="p">;</span>

<span class="cm">/*计算Innodb_rows_read的差值*/</span>
<span class="k">select</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="o">|</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">5506</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>optimizer_trace结果分析：</p>
<ul>
<li>optimizer_trace结果中的<code>number_of_tmp_files</code>可以看到使用了临时文件来排序.说明排序过程中内存放不下所有待排序数据,需要使用外部排序(一般采用归并排序).</li>
<li>Mysql把待排序的数据分成了9份,每一份单独排序存放在临时文件中,最后把这9个有序文件再合并成一个有序的大文件.</li>
<li>若<code>number_of_tmp_files</code>为0,表示排序是在内存中完成的.Mysql通过参数<code>sort_buffer_size</code>来定义排序缓存的大小,若<code>sort_buffer_size</code>越小,需要分成的份数就越多.</li>
<li>optimizer_trace结果中的<code>examined_rows</code>表示参与排序的行数.</li>
<li>optimizer_trace结果中的<code>sort_mode</code>里的<code>packed_additional_fields</code>表示对字符串进行了紧凑处理,针对varchar字段是按照实际长度来分配空间的.</li>
<li><code>packed_additional_fields</code>也表明排序采用的是全字段排序,即排序时包含所有查询字段(先把city、name和age字段查询出来放入到临时文件中,然后再根据name排序).Mysql通过参数<code>max_length_for_sort_data</code>来控制排序字段的长度,默认是1024.</li>
</ul>
<p>整个排序过程:</p>
<ol>
<li>根据参数<code>max_length_for_sort_data</code>来判断,放入sort_buffer的字段(字段为city、name和age).</li>
<li>从索引<code>city</code>中找到满足条件的主键id.</li>
<li>根据主键id到主键索引中取出整行数据,取city、name、age三个字段的值,存入sort_buffer中.</li>
<li>从索引<code>city</code>中获取下一个满足条件的主键id.</li>
<li>循环3、4直到city不满足条件为止.</li>
<li>对sort_buffer中的数据按照字段name做排序.</li>
<li>排序完成sort_buffer内存空间就会被释放.</li>
</ol>
<p><code>Innodb_rows_read</code>的差值为什么是5506而不是5505？</p>
<p>因为在查询<code>OPTIMIZER_TRACE</code>表时，需要用到临时表，而临时表的存储引擎默认是InnoDB(通过参数<code>internal_tmp_disk_storage_engine</code>来控制的)，再把数据从临时表取出来时，会让Innodb_rows_read的值加1</p>
<h3 id="rowid排序">rowid排序</h3>
<p>若查询的字段很多,总长度超过了<code>max_length_for_sort_data</code>所规定的长度,排序的过程是如何的?</p>
<p>修改参数<code>set max_length_for_sort_data=16;</code>,查询的三个字段的总长度为为36,则可触发上面说的情况.然后再来看看排序的过程.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*@a保存Innodb_rows_read的初始值*/</span>
<span class="k">select</span> <span class="n">variable_value</span> <span class="k">into</span> <span class="o">@</span><span class="n">a</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">session_status</span> <span class="k">where</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;Innodb_rows_read&#39;</span><span class="p">;</span>

<span class="cm">/*执行sql语句*/</span>
<span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>

<span class="cm">/*查看optimizer_trace输出*/</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">OPTIMIZER_TRACE</span><span class="err">\</span><span class="k">G</span>
<span class="cm">/*截图部分结果*/</span>
            <span class="s2">&#34;filesort_execution&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">],</span>
            <span class="s2">&#34;filesort_summary&#34;</span><span class="p">:</span> <span class="err">{</span>
              <span class="s2">&#34;rows&#34;</span><span class="p">:</span> <span class="mi">5505</span><span class="p">,</span>
              <span class="s2">&#34;examined_rows&#34;</span><span class="p">:</span> <span class="mi">5505</span><span class="p">,</span>
              <span class="s2">&#34;number_of_tmp_files&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
              <span class="s2">&#34;sort_buffer_size&#34;</span><span class="p">:</span> <span class="mi">261760</span><span class="p">,</span>
              <span class="s2">&#34;sort_mode&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;sort_key, rowid&gt;&#34;</span>
            <span class="err">}</span>

<span class="cm">/*@b保存Innodb_rows_read的当前值*/</span>
<span class="k">select</span> <span class="n">variable_value</span> <span class="k">into</span> <span class="o">@</span><span class="n">b</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">session_status</span> <span class="k">where</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;Innodb_rows_read&#39;</span><span class="p">;</span>

<span class="cm">/*计算Innodb_rows_read的差值*/</span>
<span class="k">select</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="o">|</span> <span class="o">@</span><span class="n">b</span><span class="o">-@</span><span class="n">a</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">6506</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>optimizer_trace结果分析:</p>
<ul>
<li>依然会采用外部排序,使用了9个临时文件来排序</li>
<li><code>sort_mode</code>变更为<code>rowid</code>,表明排序时的列只有要排序的列(name字段)和主键id.根据name排序完后还要根据对应的主键id去获取字段的值.</li>
<li>rowid排序比全字段排序会多了回表操作,必定会影响排序的性能.</li>
<li><code>select @b-@a</code>的结果为6506,比之前的多了1000,为什么?
<ul>
<li>全字段排序时回表是在引擎层内部自动完成的,server层并不感知,server层只是调用了5505次引擎的读接口获取city、name、age的值,然后在server层完成排序,所以是5505次读.</li>
<li>rowid排序时server层会先调用5505次引擎的读接口获取name、id的值,然后在server层完成排序,然后取前1000条记录中的id调用引擎的读接口获取对应的city、name、age的值,所以是6505次读.</li>
</ul>
</li>
</ul>
<p>整个排序过程:</p>
<ol>
<li>根据参数<code>max_length_for_sort_data</code>来判断,放入sort_buffer的字段(字段为name和主键id).</li>
<li>从索引<code>city</code>中找到满足条件的主键id.</li>
<li>根据主键id到主键索引中取出整行数据,取id和name字段的值,存入sort_buffer中.</li>
<li>从索引<code>city</code>中获取下一个满足条件的主键id.</li>
<li>循环3、4直到city不满足条件为止.</li>
<li>对sort_buffer中的数据按照字段name做排序.</li>
<li>再根据排序结果中的主键id去主键索引中获取city、name和age字段的值.</li>
</ol>
<h3 id="利用索引有序的特性">利用索引有序的特性</h3>
<p><code>order by name</code>需要排序是因为<code>name</code>字段是无序的,如果为有序的,<code>order by</code>又是怎样处理的?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*增加city+name的索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city_name</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">34</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="cm">/*查看执行计划*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>  <span class="o">|</span> <span class="k">key</span>       <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name</span> <span class="o">|</span> <span class="n">city_name</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看到执行计划Extra中只有<code>Using index condition</code>,使用索引<code>city_name</code>而不用再排序了.虽然不用再排序,但仍然需要回表操作来获取city、name和age的值.</p>
<p>如果使用了覆盖索引,该查询语句又会是怎样的列?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*增加city+name+age的索引,覆盖所有查询字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city_name_age</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">32</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="cm">/*查看执行计划*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>                <span class="o">|</span> <span class="k">key</span>       <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name</span><span class="p">,</span><span class="n">city_name_age</span> <span class="o">|</span> <span class="n">city_name</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+-----------+---------+-------+------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>从执行计划中可以看出仍然是使用的索引<code>city_name</code>,为什么不使用索引<code>city_name_age</code>来避免回表操作列?</p>
<p>强制使用索引<code>city_name_age</code>来看看具体情况.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">force</span> <span class="k">index</span> <span class="p">(</span><span class="n">city_name_age</span><span class="p">)</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>           <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">9940</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>从执行计划中可以看出使用覆盖索引(Extra中的<code>Using index</code>就是覆盖索引).<strong>但rows为什么是9940?</strong></p>
<p>再来看看使用<code>order by name, age</code>的情况.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>                <span class="o">|</span> <span class="k">key</span>           <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name</span><span class="p">,</span><span class="n">city_name_age</span> <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+------------------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>这时和预期是一样的,使用了索引city_name_age(覆盖索引<code>Using index</code>).</p>
<p>再来看看当把索引<code>city_name</code>删除后的情况.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*删除索引city_name*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">drop</span> <span class="k">index</span> <span class="n">city_name</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+--------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>      <span class="o">|</span> <span class="k">key</span>           <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+--------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name_age</span> <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+--------------------+---------------+---------+-------+------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看到查询使用了索引<code>city_name_age</code>(覆盖索引<code>Using index</code>),避免了回表操作.</p>
<p><strong>注意,针对<code>order by name</code>,在使用索引<code>city_name</code>和<code>city_name_age</code>时在语义上是有细微差异的,两个查询返回的结果可能并不一样,这是两个索引的排序规则不一样导致的.</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">force</span> <span class="k">index</span> <span class="p">(</span><span class="n">city_name_age</span><span class="p">)</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">5</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">city</span>     <span class="o">|</span> <span class="n">name</span> <span class="o">|</span> <span class="n">age</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>   <span class="mi">8</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">10</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">10</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">10</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">13</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="mi">5</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span>  <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span> <span class="k">limit</span> <span class="mi">5</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">city</span>     <span class="o">|</span> <span class="n">name</span> <span class="o">|</span> <span class="n">age</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">82</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">57</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">29</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">86</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">16</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------+-----+
</span><span class="c1"></span><span class="mi">5</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看出查询结果明显不一样.</p>
<p><strong>但如何解释同时存在索引<code>city_name</code>和<code>city_name_age</code>时,查询为什么不优先使用索引<code>city_name_age</code>来避免回表操作,而强制使用<code>city_name_age</code>时explain中rows为什么会是9940?</strong></p>
<h2 id="不带条件的orderby分析">不带条件的orderby分析</h2>
<p>针对语句<code>select * from t order by city limit 1000</code>,会使用索引吗?如果会是哪个索引?</p>
<p>针对语句<code>select * from t order by city limit 10000</code>列?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">order</span> <span class="k">by</span> <span class="n">city</span> <span class="k">limit</span> <span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="n">city</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">1000</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">order</span> <span class="k">by</span> <span class="n">city</span> <span class="k">limit</span> <span class="mi">10000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>          <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">44064</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="n">filesort</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>从执行计划中可以看出,语句1是有使用索引<code>city</code>且不用排序.而语句2是全表扫描且使用了排序(Extra的<code>Using filesort</code>).</p>
<p>当把limit从1000改成10000时查询为什么造成这种差异?</p>
<ul>
<li>使用索引<code>city</code>是需要进行回表操作的,当limit数据量大时优化器认为回表操作代价太大,还不如直接全表扫描.</li>
<li>针对回表操作,从索引<code>city</code>中获取到的id不是有序的,回表会造成随机读,这也是优化器认为代价太大的原因(Mysql其实有提供MRR机制来优化这种情况),还不如直接全表扫描,使用顺序读.</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>可以通过合理的创建索引来避免<code>order by</code>排序,提高查询性能.</li>
<li>当排序不可避免时,有两个系统参数<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>会对排序过程产生影响.</li>
<li>当排序不可避免时,尽量使用<code>sort_buffer</code>内存+全字段排序,这样性能最好.可以考虑优化上面两个参数.</li>
<li>Mysql设计思想之一:当内存足够时,就要多利用内存,尽量减少磁盘访问.</li>
<li>Mysql设计思想之一:尽量避免磁盘随机IO.</li>
<li><code>Using filesort</code>表示需要排序.</li>
<li><code>Using where; Using index</code>表示使用覆盖索引,需要的数据都在索引列中,不需要回表.</li>
<li><code>Using index condition</code>表示索引下推来过滤条件,但需要回表查询数据.</li>
<li><code>Using where</code>表示使用索引的情况下,需要回表查询数据.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL锁机制分析</title>
			<link>https://shenbaise9527.com/posts/mysql%E9%94%81%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 24 Nov 2020 20:50:10 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/mysql%E9%94%81%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
			<description>全局锁 全局锁就是对整个数据库实例加锁.MySQL提供了命令Flush tables with read lock(FTWRL),可使整库处于只读状态,其它线程的数据更新语</description>
			<content type="html"><![CDATA[<h2 id="全局锁">全局锁</h2>
<p>全局锁就是对整个数据库实例加锁.MySQL提供了命令<code>Flush tables with read lock</code>(FTWRL),可使整库处于只读状态,其它线程的数据更新语句(数据的增删改)、数据定义语句(DDL)和更新类事务的提交语句都会被阻塞.</p>
<p>全局锁的典型使用场景是做全库的逻辑备份.使用FTWRL可确保不会有其它线程对数据库做更新,然后再对整个库做备份,这样可以保证数据库的数据逻辑一致性.但让整库只读,是危险操作:</p>
<ol>
<li>如果在主库上备份,那么在备份期间都不能执行更新,业务基本上停摆.</li>
<li>如果在从库上备份,那么在备份期间不能执行主库同步过来的binlog,会主从延迟.</li>
</ol>
<p>在针对InnoDB引擎的表做全库备份时,可以采用可重复读隔离级别下来进行备份,不会对其它线程的操作造成堵塞,还可以保证数据的逻辑一致性.是基于一致性视图+MVCC来实现的.</p>
<p>可以使用官方工具mysqldump,使用参数<code>-single-transaction</code>时,会在可重复读隔离级别下启动一个事务,确保拿到一致性视图.但该方法只适用于所有的表都使用事务引擎的库.</p>
<p>使用命令<code>set global readonly=true</code>也可使整库处于只读状态,但这个操作更加的危险.</p>
<ol>
<li>在有些系统中,readonly的值会被用来做其它逻辑,比如判断一个库是主库还是备库.修改该值影响面更广.</li>
<li>在异常处理机制上有差异.执行FTWRL后客户端异常断开,MySQL会自动释放这个全局锁,使数据库恢复到正常状态.而readonly修改后会一直有效,使库一直处于只读状态,风险更高.</li>
</ol>
<p>ps: 在从库上如果用户有超级权限,readonly是失效的.</p>
<h2 id="表级锁">表级锁</h2>
<p>MySQL里表级别的锁有两种,表锁和元数据锁(meta data lock,简称MDL锁)</p>
<h3 id="表锁">表锁</h3>
<p>加锁语法为<code>lock tables ... read/write</code>,解锁语句为<code>unlock tables</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session1
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">lock</span> <span class="n">tables</span> <span class="n">t</span> <span class="k">read</span><span class="p">,</span> <span class="n">t1</span> <span class="k">write</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">city</span>   <span class="o">|</span> <span class="n">name</span> <span class="o">|</span> <span class="n">age</span> <span class="o">|</span> <span class="n">addr</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="n">gongan</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">80</span> <span class="o">|</span> <span class="n">test</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s1">&#39;gongan&#39;</span><span class="p">,</span> <span class="s1">&#39;guanguan&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">);</span>
<span class="n">ERROR</span> <span class="mi">1099</span> <span class="p">(</span><span class="n">HY000</span><span class="p">):</span> <span class="k">Table</span> <span class="s1">&#39;t&#39;</span> <span class="n">was</span> <span class="n">locked</span> <span class="k">with</span> <span class="n">a</span> <span class="k">READ</span> <span class="k">lock</span> <span class="k">and</span> <span class="n">can</span><span class="s1">&#39;t be updated
</span><span class="s1">mysql&gt; insert into t1 values(101, 101, 101);
</span><span class="s1">Query OK, 1 row affected (0.00 sec)
</span><span class="s1">
</span><span class="s1">mysql&gt; select * from t2 limit 1;
</span><span class="s1">ERROR 1100 (HY000): Table &#39;</span><span class="n">t2</span><span class="s1">&#39; was not locked with LOCK TABLES
</span><span class="s1">mysql&gt; insert into t2 values(1001, 1001, 1001);
</span><span class="s1">ERROR 1100 (HY000): Table &#39;</span><span class="n">t2</span><span class="s1">&#39; was not locked with LOCK TABLES
</span></code></pre></div><ul>
<li>针对表<code>t</code>读锁,表<code>t1</code>为写锁.本线程两个表的查询操作都正常,表<code>t1</code>插入正常,但针对表<code>t</code>的插入操作报错.</li>
<li>本线程只能操作表<code>t</code>和表<code>t1</code>,操作其它表都会报错.</li>
<li>本线程只能读表<code>t</code>,写会报错.</li>
<li>本线程能读写表<code>t1</code>.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session2
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">city</span>   <span class="o">|</span> <span class="n">name</span> <span class="o">|</span> <span class="n">age</span> <span class="o">|</span> <span class="n">addr</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="n">gongan</span> <span class="o">|</span> <span class="o">??</span>   <span class="o">|</span>  <span class="mi">80</span> <span class="o">|</span> <span class="n">test</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+------+-----+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t2</span> <span class="k">values</span><span class="p">(</span><span class="mi">1001</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">1001</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">03</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- block
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s1">&#39;gongan&#39;</span><span class="p">,</span> <span class="s1">&#39;guanguan&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">);</span>
</code></pre></div><ul>
<li>其它线程能正常读表<code>t</code>,但写表<code>t</code>时被阻塞</li>
<li>其它线程能正常读写其它表.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session3(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><ul>
<li>其它线程读表<code>t1</code>时被阻塞.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session4(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t1</span> <span class="k">values</span><span class="p">(</span><span class="mi">102</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">102</span><span class="p">);</span>
</code></pre></div><ul>
<li>其它线程写表<code>t1</code>时被阻塞.</li>
</ul>
<h3 id="元数据锁">元数据锁</h3>
<p>MySQL5.5版本之后的功能,会自动加锁、解锁.主要是为了解决DDL和DML并发的问题.DML时会加MDL读锁,DDL时会加MDL写锁,读读之间不互斥,读写、写写之间互斥.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session1
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session2
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">add</span> <span class="n">f</span> <span class="nb">int</span><span class="p">;</span>

<span class="c1">-- session3
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><ol>
<li>在session1提交事务之前,session2和session3都被阻塞了.</li>
<li>session1是获取了表<code>t1</code>的MDL读锁,但由于事务未提交,导致该MDL读锁未被释放.</li>
<li>session2是给表<code>t1</code>增加列,需要MDL写锁,由于读写互斥,导致该操作被堵塞.</li>
<li>session3是读表<code>t1</code>,需要MDL读锁,但之前已经有MDL写锁在等待了,也导致获取不到MDL读锁,从而被堵塞.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session1
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session2
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">add</span> <span class="n">f</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">4</span> <span class="k">min</span> <span class="mi">23</span><span class="p">.</span><span class="mi">27</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session3
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span> <span class="k">min</span> <span class="mi">20</span><span class="p">.</span><span class="mi">25</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>session1提交之后,session2和session3才执行完,但注意session3在session2之前执行,也就是session3先获取到了MDL读锁.</p>
<p><strong>当有多个线程在等待MDL锁时,获取锁的规则是什么?会由哪个线程得到锁?读锁优先还是写锁优先?</strong></p>
<p><em><strong>MDL锁是在需要的时候由MySQL自动加的,但要等待事务被提交后才会被释放.</strong></em></p>
<h2 id="行锁">行锁</h2>
<p>全局锁和表级锁是在server层实现的,而行锁是由引擎层实现的,这里主要关注InnoDB的行锁.行锁是自动加的.</p>
<h3 id="两阶段协议锁">两阶段协议锁</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>可以看到session A未提交,会导致session B阻塞.当session A在<code>commit</code>提交之后,session B才能开始执行.</p>
<p>行锁是在需要的时候由InnoDB自动加上,但直到事务结束时锁才会被释放.这就是两阶段协议锁.</p>
<h3 id="死锁和死锁检测">死锁和死锁检测</h3>
<p>在并发系统中当不同的线程出现循环资源依赖,就会导致这些线程都进入无限等待的状态,称为死锁.如下session A和session B就出现了循环资源依赖,导致死锁.</p>
<table>
<thead>
<tr>
<th style="text-align:left">session A</th>
<th style="text-align:left">session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">begin;update t2 set a = 2 where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">update t2 set a = 3 where id = 2;</td>
</tr>
<tr>
<td style="text-align:left">update t2 set a = 4 where id = 2;</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">update t2 set a = 5 where id = 1;</td>
</tr>
</tbody>
</table>
<p>在InnoDB中,当处于锁等待状态时,就有可能会触发死锁检测,是参数<code>innodb_deadlock_detect</code>控制的.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 默认值为on,表示开启死锁检测.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_deadlock%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Variable_name</span>          <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">innodb_deadlock_detect</span> <span class="o">|</span> <span class="k">ON</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">------------------------+-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>每个新来的被堵住的线程,都要判断会不会由于自己的加入导致了死锁,这是一个时间复杂度为O(n)的操作.假设有1000个线程要同时更新同一行,那么死锁检测操作就是100万量级的,这期间会消耗大量的CPU资源.注意死锁检测只会检测相关联的线程.比如当前session A在等待session B,而session B在等待session C;session D在等待session E.当session F加入需要等待session A时,只会检测F-&gt;A-&gt;B-&gt;C,D和E是不会检测的.</p>
<p><em><strong>怎么解决由热点行更新导致的性能问题?</strong></em></p>
<p><em><strong>若在事务中需要锁多个行,把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放.</strong></em></p>
<p>另外需要注意的是,当等待锁一定时间后,会出现超时现象,是参数<code>innodb_lock_wait_timeout</code>控制的.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 等待锁超时.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">ERROR</span> <span class="mi">1205</span> <span class="p">(</span><span class="n">HY000</span><span class="p">):</span> <span class="k">Lock</span> <span class="n">wait</span> <span class="n">timeout</span> <span class="n">exceeded</span><span class="p">;</span> <span class="n">try</span> <span class="n">restarting</span> <span class="k">transaction</span>

<span class="c1">-- 锁等待超时时间,默认为50s.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_lock_wait_timeout&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">--------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Variable_name</span>            <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">innodb_lock_wait_timeout</span> <span class="o">|</span> <span class="mi">50</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">--------------------------+-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>死锁时可以通过<code>show engine innodb status</code>命令查看</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">engine</span> <span class="n">innodb</span> <span class="n">status</span><span class="err">\</span><span class="k">G</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
  <span class="k">Type</span><span class="p">:</span> <span class="n">InnoDB</span>
  <span class="n">Name</span><span class="p">:</span> 
<span class="n">Status</span><span class="p">:</span> 
<span class="o">=====================================</span>
<span class="mi">2020</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">14</span> <span class="mi">14</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">16</span> <span class="mi">0</span><span class="n">x7fa8507f8700</span> <span class="n">INNODB</span> <span class="n">MONITOR</span> <span class="k">OUTPUT</span>
<span class="o">=====================================</span>
<span class="n">Per</span> <span class="k">second</span> <span class="n">averages</span> <span class="n">calculated</span> <span class="k">from</span> <span class="n">the</span> <span class="k">last</span> <span class="mi">26</span> <span class="n">seconds</span>
<span class="c1">-----------------
</span><span class="c1"></span><span class="n">BACKGROUND</span> <span class="n">THREAD</span>
<span class="c1">-----------------
</span><span class="c1"></span><span class="n">srv_master_thread</span> <span class="n">loops</span><span class="p">:</span> <span class="mi">521</span> <span class="n">srv_active</span><span class="p">,</span> <span class="mi">0</span> <span class="n">srv_shutdown</span><span class="p">,</span> <span class="mi">3098384</span> <span class="n">srv_idle</span>
<span class="n">srv_master_thread</span> <span class="n">log</span> <span class="n">flush</span> <span class="k">and</span> <span class="n">writes</span><span class="p">:</span> <span class="mi">3098905</span>
<span class="c1">----------
</span><span class="c1"></span><span class="n">SEMAPHORES</span>
<span class="c1">----------
</span><span class="c1"></span><span class="n">OS</span> <span class="n">WAIT</span> <span class="nb">ARRAY</span> <span class="n">INFO</span><span class="p">:</span> <span class="n">reservation</span> <span class="k">count</span> <span class="mi">6262</span>
<span class="n">OS</span> <span class="n">WAIT</span> <span class="nb">ARRAY</span> <span class="n">INFO</span><span class="p">:</span> <span class="n">signal</span> <span class="k">count</span> <span class="mi">28687</span>
<span class="n">RW</span><span class="o">-</span><span class="n">shared</span> <span class="n">spins</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rounds</span> <span class="mi">27977</span><span class="p">,</span> <span class="n">OS</span> <span class="n">waits</span> <span class="mi">2270</span>
<span class="n">RW</span><span class="o">-</span><span class="n">excl</span> <span class="n">spins</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rounds</span> <span class="mi">159415</span><span class="p">,</span> <span class="n">OS</span> <span class="n">waits</span> <span class="mi">2170</span>
<span class="n">RW</span><span class="o">-</span><span class="n">sx</span> <span class="n">spins</span> <span class="mi">4327</span><span class="p">,</span> <span class="n">rounds</span> <span class="mi">34223</span><span class="p">,</span> <span class="n">OS</span> <span class="n">waits</span> <span class="mi">205</span>
<span class="n">Spin</span> <span class="n">rounds</span> <span class="n">per</span> <span class="n">wait</span><span class="p">:</span> <span class="mi">27977</span><span class="p">.</span><span class="mi">00</span> <span class="n">RW</span><span class="o">-</span><span class="n">shared</span><span class="p">,</span> <span class="mi">159415</span><span class="p">.</span><span class="mi">00</span> <span class="n">RW</span><span class="o">-</span><span class="n">excl</span><span class="p">,</span> <span class="mi">7</span><span class="p">.</span><span class="mi">91</span> <span class="n">RW</span><span class="o">-</span><span class="n">sx</span>
<span class="c1">-- 死锁信息
</span><span class="c1">------------------------
</span><span class="c1"></span><span class="n">LATEST</span> <span class="n">DETECTED</span> <span class="n">DEADLOCK</span>
<span class="c1">------------------------
</span><span class="c1"></span><span class="mi">2020</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">14</span> <span class="mi">12</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">34</span> <span class="mi">0</span><span class="n">x7fa8507f8700</span>
<span class="o">***</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">TRANSACTION</span><span class="p">:</span>
<span class="k">TRANSACTION</span> <span class="mi">3667</span><span class="p">,</span> <span class="n">ACTIVE</span> <span class="mi">7</span> <span class="n">sec</span> <span class="n">starting</span> <span class="k">index</span> <span class="k">read</span>
<span class="n">mysql</span> <span class="n">tables</span> <span class="k">in</span> <span class="n">use</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locked</span> <span class="mi">1</span>
<span class="k">LOCK</span> <span class="n">WAIT</span> <span class="mi">2</span> <span class="k">lock</span> <span class="n">struct</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">heap</span> <span class="k">size</span> <span class="mi">1136</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="k">lock</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">MySQL</span> <span class="n">thread</span> <span class="n">id</span> <span class="mi">73</span><span class="p">,</span> <span class="n">OS</span> <span class="n">thread</span> <span class="n">handle</span> <span class="mi">140361007904512</span><span class="p">,</span> <span class="n">query</span> <span class="n">id</span> <span class="mi">1776328</span> <span class="n">localhost</span> <span class="n">web</span> <span class="n">updating</span>
<span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">10</span>
<span class="o">***</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">WAITING</span> <span class="k">FOR</span> <span class="n">THIS</span> <span class="k">LOCK</span> <span class="k">TO</span> <span class="n">BE</span> <span class="k">GRANTED</span><span class="p">:</span>
<span class="n">RECORD</span> <span class="n">LOCKS</span> <span class="k">space</span> <span class="n">id</span> <span class="mi">43</span> <span class="n">page</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">n</span> <span class="n">bits</span> <span class="mi">80</span> <span class="k">index</span> <span class="k">c</span> <span class="k">of</span> <span class="k">table</span> <span class="o">`</span><span class="n">web</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="n">trx</span> <span class="n">id</span> <span class="mi">3667</span> <span class="n">lock_mode</span> <span class="n">X</span> <span class="n">waiting</span>
<span class="n">Record</span> <span class="k">lock</span><span class="p">,</span> <span class="n">heap</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">PHYSICAL</span> <span class="n">RECORD</span><span class="p">:</span> <span class="n">n_fields</span> <span class="mi">2</span><span class="p">;</span> <span class="n">compact</span> <span class="n">format</span><span class="p">;</span> <span class="n">info</span> <span class="n">bits</span> <span class="mi">0</span>
 <span class="mi">0</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>
 <span class="mi">1</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>

<span class="o">***</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">TRANSACTION</span><span class="p">:</span>
<span class="k">TRANSACTION</span> <span class="mi">3668</span><span class="p">,</span> <span class="n">ACTIVE</span> <span class="mi">12</span> <span class="n">sec</span> <span class="n">inserting</span>
<span class="n">mysql</span> <span class="n">tables</span> <span class="k">in</span> <span class="n">use</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locked</span> <span class="mi">1</span>
<span class="mi">5</span> <span class="k">lock</span> <span class="n">struct</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">heap</span> <span class="k">size</span> <span class="mi">1136</span><span class="p">,</span> <span class="mi">3</span> <span class="k">row</span> <span class="k">lock</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">undo</span> <span class="n">log</span> <span class="n">entries</span> <span class="mi">1</span>
<span class="n">MySQL</span> <span class="n">thread</span> <span class="n">id</span> <span class="mi">72</span><span class="p">,</span> <span class="n">OS</span> <span class="n">thread</span> <span class="n">handle</span> <span class="mi">140360881768192</span><span class="p">,</span> <span class="n">query</span> <span class="n">id</span> <span class="mi">1776329</span> <span class="n">localhost</span> <span class="n">web</span> <span class="k">update</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="o">***</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">HOLDS</span> <span class="n">THE</span> <span class="k">LOCK</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
<span class="n">RECORD</span> <span class="n">LOCKS</span> <span class="k">space</span> <span class="n">id</span> <span class="mi">43</span> <span class="n">page</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">n</span> <span class="n">bits</span> <span class="mi">80</span> <span class="k">index</span> <span class="k">c</span> <span class="k">of</span> <span class="k">table</span> <span class="o">`</span><span class="n">web</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="n">trx</span> <span class="n">id</span> <span class="mi">3668</span> <span class="k">lock</span> <span class="k">mode</span> <span class="n">S</span>
<span class="n">Record</span> <span class="k">lock</span><span class="p">,</span> <span class="n">heap</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">PHYSICAL</span> <span class="n">RECORD</span><span class="p">:</span> <span class="n">n_fields</span> <span class="mi">2</span><span class="p">;</span> <span class="n">compact</span> <span class="n">format</span><span class="p">;</span> <span class="n">info</span> <span class="n">bits</span> <span class="mi">0</span>
 <span class="mi">0</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>
 <span class="mi">1</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>

<span class="o">***</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">WAITING</span> <span class="k">FOR</span> <span class="n">THIS</span> <span class="k">LOCK</span> <span class="k">TO</span> <span class="n">BE</span> <span class="k">GRANTED</span><span class="p">:</span>
<span class="n">RECORD</span> <span class="n">LOCKS</span> <span class="k">space</span> <span class="n">id</span> <span class="mi">43</span> <span class="n">page</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">n</span> <span class="n">bits</span> <span class="mi">80</span> <span class="k">index</span> <span class="k">c</span> <span class="k">of</span> <span class="k">table</span> <span class="o">`</span><span class="n">web</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="n">trx</span> <span class="n">id</span> <span class="mi">3668</span> <span class="n">lock_mode</span> <span class="n">X</span> <span class="n">locks</span> <span class="n">gap</span> <span class="k">before</span> <span class="n">rec</span> <span class="k">insert</span> <span class="n">intention</span> <span class="n">waiting</span>
<span class="n">Record</span> <span class="k">lock</span><span class="p">,</span> <span class="n">heap</span> <span class="k">no</span> <span class="mi">4</span> <span class="n">PHYSICAL</span> <span class="n">RECORD</span><span class="p">:</span> <span class="n">n_fields</span> <span class="mi">2</span><span class="p">;</span> <span class="n">compact</span> <span class="n">format</span><span class="p">;</span> <span class="n">info</span> <span class="n">bits</span> <span class="mi">0</span>
 <span class="mi">0</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>
 <span class="mi">1</span><span class="p">:</span> <span class="n">len</span> <span class="mi">4</span><span class="p">;</span> <span class="n">hex</span> <span class="mi">8000000</span><span class="n">a</span><span class="p">;</span> <span class="k">asc</span>     <span class="p">;;</span>

<span class="o">***</span> <span class="n">WE</span> <span class="n">ROLL</span> <span class="n">BACK</span> <span class="k">TRANSACTION</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><h3 id="锁等待分析">锁等待分析</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A,开启事务,在di=1加行锁.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session B(block),等待session A的锁.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>

<span class="c1">-- session C,查看阻塞情况.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">processlist</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+-----------+------+---------+------+------------+--------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Id</span> <span class="o">|</span> <span class="k">User</span> <span class="o">|</span> <span class="k">Host</span>      <span class="o">|</span> <span class="n">db</span>   <span class="o">|</span> <span class="n">Command</span> <span class="o">|</span> <span class="n">Time</span> <span class="o">|</span> <span class="k">State</span>      <span class="o">|</span> <span class="n">Info</span>                                             <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+-----------+------+---------+------+------------+--------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">68</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">localhost</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">Sleep</span>   <span class="o">|</span>  <span class="mi">104</span> <span class="o">|</span>            <span class="o">|</span> <span class="k">NULL</span>                                             <span class="o">|</span>
<span class="o">|</span> <span class="mi">69</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">localhost</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">Query</span>   <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span> <span class="k">statistics</span> <span class="o">|</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">70</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">localhost</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">Query</span>   <span class="o">|</span>    <span class="mi">0</span> <span class="o">|</span> <span class="n">starting</span>   <span class="o">|</span> <span class="k">show</span> <span class="n">processlist</span>                                 <span class="o">|</span>
<span class="o">|</span> <span class="mi">71</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">localhost</span> <span class="o">|</span> <span class="n">web</span>  <span class="o">|</span> <span class="n">Sleep</span>   <span class="o">|</span> <span class="mi">3724</span> <span class="o">|</span>            <span class="o">|</span> <span class="k">NULL</span>                                             <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+-----------+------+---------+------+------------+--------------------------------------------------+
</span><span class="c1"></span><span class="mi">4</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- 从下面可以看出69在等待68的锁.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sys</span><span class="p">.</span><span class="n">innodb_lock_waits</span> <span class="k">where</span> <span class="n">locked_table</span><span class="o">=</span><span class="s1">&#39;`web`.`t2`&#39;</span><span class="err">\</span><span class="k">G</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                <span class="n">wait_started</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">13</span> <span class="mi">16</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">31</span>
                    <span class="n">wait_age</span><span class="p">:</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">02</span>
               <span class="n">wait_age_secs</span><span class="p">:</span> <span class="mi">2</span>
                <span class="n">locked_table</span><span class="p">:</span> <span class="o">`</span><span class="n">web</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">t2</span><span class="o">`</span>
                <span class="n">locked_index</span><span class="p">:</span> <span class="k">PRIMARY</span>
                 <span class="n">locked_type</span><span class="p">:</span> <span class="n">RECORD</span>
              <span class="n">waiting_trx_id</span><span class="p">:</span> <span class="mi">421836271774456</span>
         <span class="n">waiting_trx_started</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">13</span> <span class="mi">16</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">31</span>
             <span class="n">waiting_trx_age</span><span class="p">:</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">02</span>
     <span class="n">waiting_trx_rows_locked</span><span class="p">:</span> <span class="mi">1</span>
   <span class="n">waiting_trx_rows_modified</span><span class="p">:</span> <span class="mi">0</span>
                 <span class="n">waiting_pid</span><span class="p">:</span> <span class="mi">69</span>
               <span class="n">waiting_query</span><span class="p">:</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span>
             <span class="n">waiting_lock_id</span><span class="p">:</span> <span class="mi">421836271774456</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span>
           <span class="n">waiting_lock_mode</span><span class="p">:</span> <span class="n">S</span>
             <span class="n">blocking_trx_id</span><span class="p">:</span> <span class="mi">3553</span>
                <span class="n">blocking_pid</span><span class="p">:</span> <span class="mi">68</span>
              <span class="n">blocking_query</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">blocking_lock_id</span><span class="p">:</span> <span class="mi">3553</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span>
          <span class="n">blocking_lock_mode</span><span class="p">:</span> <span class="n">X</span>
        <span class="n">blocking_trx_started</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">13</span> <span class="mi">16</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span><span class="mi">07</span>
            <span class="n">blocking_trx_age</span><span class="p">:</span> <span class="mi">00</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">26</span>
    <span class="n">blocking_trx_rows_locked</span><span class="p">:</span> <span class="mi">1</span>
  <span class="n">blocking_trx_rows_modified</span><span class="p">:</span> <span class="mi">1</span>
     <span class="n">sql_kill_blocking_query</span><span class="p">:</span> <span class="n">KILL</span> <span class="n">QUERY</span> <span class="mi">68</span>
<span class="n">sql_kill_blocking_connection</span><span class="p">:</span> <span class="n">KILL</span> <span class="mi">68</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">3</span> <span class="n">warnings</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">06</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>在MySQL5.7及之后版本可以通过<code>sys.innodb_lock_waits</code>表获取锁占用情况.</p>
<h3 id="幻读">幻读</h3>
<h4 id="什么是幻读">什么是幻读?</h4>
<ol>
<li>在一个事务内,前后看到的数据不一致,不一致特指后面看到的数据行数多了,这就是幻读(幻读特指新插入的行).</li>
<li>在读已提交隔离级别下,是允许存在幻读现象的.</li>
<li>在可重复读隔离级别下,MySQL是不存在幻读现象的.</li>
<li>在可重复读隔离级别下,普通的查询都是快照读,是不能看到别的事务插入的数据,因此必须是针对当前读的语句.</li>
</ol>
<h4 id="幻读有什么问题">幻读有什么问题?</h4>
<p>在可重复隔离级别下,如果允许幻读会出现什么现象?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 隔离级别为可重复读.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">@@</span><span class="n">transaction_isolation</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="o">@@</span><span class="n">transaction_isolation</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="k">REPEATABLE</span><span class="o">-</span><span class="k">READ</span>         <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t2</span> <span class="k">set</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session B,假定此处不会block
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t2</span> <span class="k">values</span><span class="p">(</span><span class="mi">1002</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1002</span><span class="p">);</span>

<span class="c1">-- session A,提交事务
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>如上所示的流程,假如session A只是对a=4这行加了行锁.</p>
<p>session B的事务是先提交,session A的事务是后提交.此时数据库的数据为(4, 4, 5)和(1002, 4, 1002).但在binlog中先是session B的操作,然后是session A的操作,该binlog同步到从库上开始执行,会得到什么结果?</p>
<p>session B先执行,插入一行数据(1002, 4, 1002),然后更新a=4的行,从库的数据为(4, 4, 5)和(1002, 4, 5),此时主库和从库的数据不一致了.</p>
<p>session A本来是想更新所有a=4的行的,但在这之后session B插入了一行a=4的数据,导致session A的语义被破坏了.</p>
<p><em><strong>主从数据不一致和语义被破坏,这就是幻读的问题.</strong></em></p>
<p>实际上InnoDB在可重复读级别下是不会出现幻读的现象的,上面的sql语句,session B的<code>insert</code>操作会被阻塞,直到session A的事务提交后才能执行.</p>
<h4 id="如何解决幻读">如何解决幻读?</h4>
<p>通过上例,只是加行锁,无法阻止幻读的出现.InnoDB是通过加间隙锁(Gap Lock),来锁住a=4的间隙,这样可以阻塞别的线程的插入操作.</p>
<p>间隙锁,锁的就是两个值之间的间隙,以上例session A来说,会锁住(3, 4)和(4, 5)的间隙.这样再插入session B的数据,会落入到(4, 5)间隙,导致被阻塞.</p>
<p>间隙锁一般是针对可重复隔离级别的.读已提交一般情况下只有行锁(说明该隔离级别会出现幻读的现象).</p>
<p>间隙锁的引入会导致锁的范围变大,这样其实会影响并发度的.</p>
<p><em><strong>需要注意,间隙锁之间是不互斥的,不同的session之间可以锁住同样的间隙</strong></em></p>
<h4 id="next-key-lock">Next-key lock</h4>
<p>行锁+间隙锁合称为next-key lock,每个next-key lock都是前开后闭区间.</p>
<h3 id="innodb加锁规则可重复读隔离级别">InnoDB加锁规则(可重复读隔离级别)</h3>
<ol>
<li>原则一: 加锁的基本单位是next-key lock,是前开后闭区间.</li>
<li>原则二: 查找过程中访问到的对象才会加锁.</li>
<li>优化一: 索引上的等值查询,给唯一索引加锁的时候,next-key lock会退化为行锁.</li>
<li>优化二: 索引上的等值查询,向右遍历时且最后一个值不满足等值条件的时候,next-key lock会退化为间隙锁.</li>
<li>bug一: 唯一索引上的范围查询会访问到不满足条件的第一个值为止.</li>
</ol>
<p>数据准备.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 创建表t.
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="k">c</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">d</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="k">c</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span>

<span class="c1">-- 插入数据.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span>  <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">6</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">6</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div><h4 id="等值查询间隙锁">等值查询间隙锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session B(block).
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>

<span class="c1">-- session C.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div><ol>
<li>session A在主键索引上加锁,根据规则一加锁为(5, 10],根据优化二退化为间隙锁(5, 10)</li>
<li>session B要插入id=8,落在间隙锁(5, 10)之间,被阻塞.</li>
<li>session C更新id=10的行,根据规则一加锁为(5, 10],根据优化一退化为行锁(10),锁不冲突,可以更新成功.</li>
</ol>
<h4 id="非唯一索引等值锁">非唯一索引等值锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session B
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1">-- session C(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</code></pre></div><ol>
<li>session A在索引c上加锁,根据规则一为(0, 5]和(5, 10],根据优化二退化为(0, 5]和(5, 10).注意该语句是使用了覆盖索引,所以并没有在主键索引上加锁.</li>
<li>session B是在主键索引上加锁,根据优化一退化为行锁(5),和session A并不冲突,可以更新成功.</li>
<li>session C要再索引c上插入c=7的行,落在了(5, 10)之间,被session A阻塞.</li>
</ol>
<p><strong>注意:语句中使用的是<code>lock in share mode</code>,是读锁且使用了覆盖索引,并不需要访问主键索引.但如果使用的是<code>for update</code>,又是什么效果列?</strong></p>
<h4 id="主键索引范围锁">主键索引范围锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="k">and</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">11</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- block
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>

<span class="c1">--session C (block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
</code></pre></div><ol>
<li>session A在主键索引上加锁,满足条件的第一行是id=10,则加锁(5, 10],但根据优化一退化为行锁(10);范围查询要继续查找,则加锁(10, 15],由于是范围查询没有适用的优化规则.故加锁范围为[10, 15]</li>
<li>session B第一条插入id=8,不在锁的范围,可以插入成功.第二条插入id=13,在锁的范围,被阻塞.</li>
<li>session C更新id=15的行,在锁的范围,被阻塞.</li>
</ol>
<h4 id="非唯一索引范围锁">非唯一索引范围锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span><span class="o">&gt;=</span><span class="mi">10</span> <span class="k">and</span> <span class="k">c</span><span class="o">&lt;</span><span class="mi">11</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="c1">-- session C(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
</code></pre></div><ol>
<li>session A在索引c上加锁,满足条件的第一行是c=10,则加锁(5, 10],注意c是非唯一索引没有优化规则;范围查询要继续查找,则加锁(10, 15],由于是范围查询没有适用的优化规则.故加锁范围为(5, 15].</li>
<li>session B要插入c=8的行,在锁的范围内,被阻塞.</li>
<li>session C要更新c=15的行,在锁的范围内,被阻塞.</li>
</ol>
<h4 id="唯一索引范围bug">唯一索引范围bug</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">id</span><span class="o">&gt;</span><span class="mi">10</span> <span class="k">and</span> <span class="n">id</span><span class="o">&lt;=</span><span class="mi">15</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>

<span class="c1">--session C(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div><ol>
<li>session A在主键索引上加锁,按照原则一,加锁(10, 15],但InnoDB会扫描到第一个不满足条件的行为止,这里也就是id=20，由于是范围扫描,所以还会加锁(15, 20].但(15, 20]是完全没必要的,可以认为是bug.</li>
<li>session B要更新id=20的行,在锁的范围内,被阻塞.</li>
<li>session C要插入id=16的行,在锁的范围内,被阻塞.</li>
</ol>
<h4 id="非唯一索引上存在相同键">非唯一索引上存在相同键</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 插入新行,c=10的有两行数据.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- 可以看到索引c的顺序.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">order</span> <span class="k">by</span> <span class="k">c</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">0</span> <span class="o">|</span>    <span class="mi">0</span> <span class="o">|</span>    <span class="mi">0</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span>    <span class="mi">5</span> <span class="o">|</span>    <span class="mi">5</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">30</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>   <span class="mi">30</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">25</span> <span class="o">|</span>   <span class="mi">25</span> <span class="o">|</span>   <span class="mi">25</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">7</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">delete</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">2</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

<span class="c1">--session C
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
<span class="k">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div><ol>
<li>session A是在索引c上加锁,满足条件的第一行为(id=10,c=10),则加锁((id=5,c=5),(id=10,c=10)],非唯一索引没有优化规则.第一行为(id=30,c=10),则加锁((id=10,c=10),(id=30,c=10)],继续查找到(id=15,c=15)结束,根据优化规则二,退化为间隙锁((id=30,c=10),(id=15,c=15))</li>
<li>session B插入c=12的行,在锁的范围内,被阻塞.</li>
<li>session C更新c=15的行,不再锁的范围内,可正常更新.</li>
</ol>
<h4 id="limit语句加锁">limit语句加锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">delete</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">10</span> <span class="k">limit</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">2</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B(正常)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>session A是在索引c上加锁,由于有<code>limit 2</code>在读取到满足条件的两行数据后就不会再继续查找,所以加锁范围相比上节的例子会变小,加锁范围为((id=5,c=5),(id=10,c=10)]和((id=10,c=10),(id=30,c=10)]
session B要插入c=12的行,不在加锁范围内,可正常插入.</p>
<p><strong>在不改变语义的前提下,删除数据的时候尽量加limit,可有效降低加锁范围</strong></p>
<h4 id="死锁">死锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">0</span> <span class="o">|</span>    <span class="mi">0</span> <span class="o">|</span>    <span class="mi">0</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span>    <span class="mi">5</span> <span class="o">|</span>    <span class="mi">5</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>   <span class="mi">10</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">25</span> <span class="o">|</span>   <span class="mi">25</span> <span class="o">|</span>   <span class="mi">25</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">6</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">10</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">t</span> <span class="k">set</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="k">where</span> <span class="k">c</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>

<span class="c1">--session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">12</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">--session B(死锁,回滚)
</span><span class="c1"></span><span class="n">ERROR</span> <span class="mi">1213</span> <span class="p">(</span><span class="mi">40001</span><span class="p">):</span> <span class="n">Deadlock</span> <span class="k">found</span> <span class="k">when</span> <span class="n">trying</span> <span class="k">to</span> <span class="k">get</span> <span class="k">lock</span><span class="p">;</span> <span class="n">try</span> <span class="n">restarting</span> <span class="k">transaction</span>
</code></pre></div><ol>
<li>首先session A的加锁范围为next-key lock(5, 10]和间隙锁(10, 15)</li>
<li>session B的update语句被阻塞,其加锁逻辑为:先加间隙锁(5, 10),然后是行锁(10).由于间隙锁之间是不冲突的,有冲突的是行锁(10),导致sesssion B的阻塞.</li>
<li>此时session A拥有(5, 10]和(10, 15)的锁,session B拥有(5, 10)的锁且在等待行锁(10).</li>
<li>最后session A插入c=8的新行,落在间隙(5, 10)中,该间隙锁session B也拥有导致阻塞.</li>
<li>此时会进行死锁检测,发现session B在等待session A的行锁,而session A又在等待session B的间隙锁,导致死锁.</li>
</ol>
<h4 id="order-by加锁">order by加锁</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- session A
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span><span class="o">&gt;=</span><span class="mi">15</span> <span class="k">and</span> <span class="k">c</span><span class="o">&lt;=</span><span class="mi">20</span> <span class="k">order</span> <span class="k">by</span> <span class="k">c</span> <span class="k">desc</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>   <span class="mi">20</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>   <span class="mi">15</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- session B(block)
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div><ol>
<li>session A由于是倒序,第一个访问的是索引c上最右边的c=20的行,会加间隙锁(20, 25)和next-key lock(15, 20],继续遍历到c=10才会停下来,则next-key lock(5, 10].故整个锁的范围是索引c上的(5, 25),主键索引上id=15和id=20的两个行锁.</li>
<li>session B要插入c=6的行,落在了间隙锁(5, 25)中,所以被阻塞.</li>
</ol>
<h3 id="innodb加锁规则读已提交隔离级别">InnoDB加锁规则(读已提交隔离级别)</h3>
<ol>
<li>主要是行锁(只有在外键场景下会有间隙锁)</li>
<li>在语句执行过程中加的行锁,在语句执行完成后,就会把不满足条件的行的行锁释放掉,不需要等待事务提交.</li>
</ol>
<p>在读已提交下锁的范围更小,锁的时间更短.</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL的join分析</title>
			<link>https://shenbaise9527.com/posts/mysql%E4%B9%8Bjoin/</link>
			<pubDate>Tue, 24 Nov 2020 20:47:44 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/mysql%E4%B9%8Bjoin/</guid>
			<description>问题 使用join时驱动表、被驱动表是如何选择的?影响因素有哪些? 如何优化? 数据准备 /*创建表*/ CREATE TABLE `t1` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`)</description>
			<content type="html"><![CDATA[<h2 id="问题">问题</h2>
<ol>
<li>使用join时驱动表、被驱动表是如何选择的?影响因素有哪些?</li>
<li>如何优化?</li>
</ol>
<h2 id="数据准备">数据准备</h2>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*创建表*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">a</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">b</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">a</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="cm">/*创建存储过程*/</span>
<span class="k">delimiter</span> <span class="p">;;</span>
<span class="k">create</span> <span class="k">procedure</span> <span class="n">idata</span><span class="p">()</span>
<span class="k">begin</span>
    <span class="k">declare</span> <span class="n">i</span> <span class="nb">int</span><span class="p">;</span>
    <span class="k">set</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">1000</span><span class="p">)</span> <span class="k">do</span>
        <span class="k">insert</span> <span class="k">into</span> <span class="n">t2</span> <span class="k">values</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">set</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span> <span class="n">while</span><span class="p">;</span>
<span class="k">end</span><span class="p">;;</span>
<span class="k">delimiter</span> <span class="p">;</span>

<span class="cm">/*执行*/</span>
<span class="k">call</span> <span class="n">idata</span><span class="p">();</span>

<span class="cm">/*创建表t1*/</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">like</span> <span class="n">t2</span><span class="p">;</span>

<span class="cm">/*插入数据*/</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">t1</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div><h2 id="index-nested-loop-joinnlj">Index Nested-Loop Join(NLJ)</h2>
<p>join时能用上被驱动表的索引,称之为<code>Index Nested-Loop Join</code>,简称为NLJ</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>      <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>     <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="n">web</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+-------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>从上面的结果可以看出,驱动表是表<code>t1</code>,被驱动表是表<code>t2</code>.驱动表是全表扫描,而被驱动表是用的索引<code>a</code>.</p>
<p>语句执行过程是:</p>
<ol>
<li>从表<code>t1</code>中读入一行数据R.</li>
<li>从R取出字段<code>a</code>的值,去表<code>t2</code>里查找.</li>
<li>取出表<code>t2</code>中满足条件的行,跟R组成一行,作为结果集的一部分.</li>
<li>重复执行步骤1到3,直到表<code>t1</code>的末尾,循环结束.</li>
</ol>
<p>假定驱动表有N行,被驱动表有M行,每扫描一行驱动表,使用字段a的值去被驱动表的索引树a上查找,然后再回表到被驱动表的主键索引树,则被驱动表要扫描2*$log_2{M}$.则总的扫描行数为N+N*2*$log_2{M}$.显然N对扫描行数的影响更大,因此在这种情况下应该使用小表为驱动表.</p>
<p>但如果被驱动表没有索引列?</p>
<h2 id="block-nested-loop-joinbnl">Block Nested-Loop Join(BNL)</h2>
<p>join时被驱动表没有索引时,称之为<code>Block Nested-Loop Join</code>,简称为BNL</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*使用straight_join强行指定驱动表为t1*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="n">straight_join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>                                               <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">1000</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Block</span> <span class="n">Nested</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>从上面的Extra字段的值<code>Using join buffer (Block Nested Loop)</code>可以看出,采用的正是BNL.</p>
<p>语句执行过程是:</p>
<ol>
<li>把表<code>t1</code>的数据读入线程内存<code>join_buffer</code>中</li>
<li>扫描表<code>t2</code>,把每一行取出,跟<code>join_buffer</code>中的数据比对,满足<code>join</code>条件的,作为结果集的一部分.</li>
</ol>
<p>整个过程表<code>t1</code>和表<code>t2</code>都是全表扫描,扫描行数为1000+100=1100,由于<code>join_buffer</code>中的数据时无序的,对表<code>t2</code>里的每一行都要做100次判断,总判断次数为1000*100=10万次.判读次数是纯内存操作,相比读表会快上不少,整个过程就是扫描1100行+10万次内存操作.</p>
<p><em><strong>在这种情况下,不论选择哪个表为驱动表其实是没有差异的.</strong></em></p>
<p><code>join_buffer</code>的大小是由参数<code>join_buffer_size</code>来控制的,默认大小为256k.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;join%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">------------------+--------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Variable_name</span>    <span class="o">|</span> <span class="n">Value</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">------------------+--------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">join_buffer_size</span> <span class="o">|</span> <span class="mi">262144</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">------------------+--------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">26</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>如果表<code>t1</code>的数据量很大,导致<code>join_buffer</code>放不下了,整个过程又会是怎么样的?</p>
<p>策略很简单,就是分段放入,分次比较.详见<a href="https://dev.mysql.com/doc/internals/en/join-buffer-size.html">官网说明</a>
Basic information about the join buffer cache:</p>
<ul>
<li>The size of each join buffer is determined by the value of the join_buffer_size system variable.</li>
<li>This buffer is <strong>used only when the join is of type ALL or index (in other words, when no possible keys can be used)</strong>.</li>
<li>A join buffer is never allocated for the first non-const table, even if it would be of type ALL or index.</li>
<li>The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.</li>
<li>Accepted row combinations of tables before the ALL/index are stored in the cache and are used to compare against each read row in the ALL table.</li>
<li>We only store the used columns in the join buffer, not the whole rows.</li>
</ul>
<p>Assume you have the following join:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">Table</span> <span class="n">name</span> <span class="k">Type</span>
<span class="n">t1</span>         <span class="n">range</span>
<span class="n">t2</span>         <span class="k">ref</span>
<span class="n">t3</span>         <span class="k">ALL</span>
</code></pre></div><p>The Join is then done as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="o">-</span> <span class="n">While</span> <span class="k">rows</span> <span class="k">in</span> <span class="n">t1</span> <span class="n">matching</span> <span class="n">range</span>
 <span class="o">-</span> <span class="k">Read</span> <span class="n">through</span> <span class="k">all</span> <span class="k">rows</span> <span class="k">in</span> <span class="n">t2</span> <span class="n">according</span> <span class="k">to</span> <span class="n">reference</span> <span class="k">key</span>
  <span class="o">-</span> <span class="n">Store</span> <span class="n">used</span> <span class="n">fields</span> <span class="k">from</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="k">in</span> <span class="k">cache</span>
  <span class="o">-</span> <span class="k">If</span> <span class="k">cache</span> <span class="k">is</span> <span class="k">full</span> 
    <span class="o">-</span> <span class="k">Read</span> <span class="n">through</span> <span class="k">all</span> <span class="k">rows</span> <span class="k">in</span> <span class="n">t3</span> 
      <span class="o">-</span> <span class="n">Compare</span> <span class="n">t3</span> <span class="k">row</span> <span class="n">against</span> <span class="k">all</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="n">combinations</span> <span class="k">in</span> <span class="k">cache</span> 
        <span class="o">-</span> <span class="k">If</span> <span class="k">row</span> <span class="n">satisfies</span> <span class="k">join</span> <span class="n">condition</span><span class="p">,</span> <span class="n">send</span> <span class="n">it</span> <span class="k">to</span> <span class="n">client</span> 
    <span class="o">-</span> <span class="n">Empty</span> <span class="k">cache</span> 

<span class="o">-</span> <span class="k">Read</span> <span class="n">through</span> <span class="k">all</span> <span class="k">rows</span> <span class="k">in</span> <span class="n">t3</span>
 <span class="o">-</span> <span class="n">Compare</span> <span class="n">t3</span> <span class="k">row</span> <span class="n">against</span> <span class="k">all</span> <span class="n">stored</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="n">combinations</span> <span class="k">in</span> <span class="k">cache</span>
   <span class="o">-</span> <span class="k">If</span> <span class="k">row</span> <span class="n">satisfies</span> <span class="k">join</span> <span class="n">condition</span><span class="p">,</span> <span class="n">send</span> <span class="n">it</span> <span class="k">to</span> <span class="n">client</span>
</code></pre></div><p>假设驱动表的行数是N,需要分K段才能完成算法流程,被驱动表数据行数是M.显然N越大,K就会越大,K=$\lambda$*N,$\lambda$取值范围为(0,1).此算法扫描的行数为N+$\lambda$*N*M,内存判断次数为N*M,在N和M确定的情况下,N小些,扫描行数的算式会更小些,可见此时应小表当驱动表.参数$\lambda$才是影响扫描行数的关键因素,这个值应该越小越好.在N固定时若<code>join_buffer_size</code>越大,能放入的行数越多,该值就会越小.</p>
<p>若join语句很慢,可尝试把<code>join_buffer_size</code>改大点.</p>
<p>以上两个join算法都应该尽量使用小表作为驱动表,但什么是小表列?</p>
<h2 id="什么是小表">什么是小表?</h2>
<p>先来看看两组sql语句</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*Q1,此时放入join_buffer的数据是100行*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="n">straight_join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span> <span class="k">where</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">50</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>                                               <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>   <span class="mi">50</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Block</span> <span class="n">Nested</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*Q2,此时放入join_buffer的数据是50行*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="n">straight_join</span> <span class="n">t1</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span> <span class="k">where</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">50</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>   <span class="mi">50</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span>                                        <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Block</span> <span class="n">Nested</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*Q3,此时放入join_buffer的数据是100行,但只需包含t1.b这一个字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="n">straight_join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span> <span class="k">where</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>                                               <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Block</span> <span class="n">Nested</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*Q4,此时放入join_buffer的数据是100行,但需包含表t2的所有字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="n">straight_join</span> <span class="n">t1</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span> <span class="k">where</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span>                                        <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Block</span> <span class="n">Nested</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><ul>
<li>针对语句Q1和Q2来说,Q2放入<code>join_buffer</code>的数据只有50行,相对来说此时t2是小表,应该为驱动表.</li>
<li>针对语句Q3和Q4来说,放入<code>join_buffer</code>的行数是一样的,但Q3只需要放入表t1的一个字段,相对来说此时t1是小表,应该为驱动表.</li>
</ul>
<p><strong>在决定哪个表为驱动表时,应该要两个表按照各自的条件过滤,然后计算参与join的各个字段的总数据量,数据量小的那个表就是小表,应该为驱动表.</strong></p>
<h2 id="优化">优化</h2>
<h3 id="multi-range-readmrr优化">Multi-Range Read(MRR)优化</h3>
<p>MRR优化的主要目的是使用顺序读盘.</p>
<p>在查询过程中使用非主键索引时需要进行回表操作去主键索引树中获取相关字段的值.在非主键索引树中获取的主键ID不是有序的,当循环回表时会触发主键索引树的磁盘随机读取,而这是最耗时的操作.</p>
<p>而MRR优化过程:</p>
<ol>
<li>从非主键索引中把符合的主键ID先全部读取出来,放入<code>read_rnd_buffer</code>中</li>
<li>把<code>read_rnd_buffer</code>中的主键ID排序</li>
<li>根据排序后的主键ID去主键索引树中查找记录</li>
</ol>
<p><code>read_rnd_buffer</code>是由参数<code>read_rnd_buffer_size</code>控制的,默认为256k</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;read_rnd%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------------------+--------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Variable_name</span>        <span class="o">|</span> <span class="n">Value</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----------------------+--------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">read_rnd_buffer_size</span> <span class="o">|</span> <span class="mi">262144</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------------------+--------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>当<code>read_rnd_buffer</code>满时,就会执行步骤2和3,然后清空<code>read_rnd_buffer</code>,之后继续找非主键索引的下个记录,并继续循环.</p>
<p>MRR能提升性能的核心在于,在非主键索引上是一个范围查询,可以有足够的主键ID,这样排序后,再去主键索引查找数据,才能体现出顺序性的优势.</p>
<p>若想稳定地使用MRR优化,需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>(官方文档:优化器在判断消耗时,会更倾向不使用MRR,把mrr_cost_based设置为off,就是固定使用MRR).</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*开启MRR*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="n">optimizer_switch</span><span class="o">=</span><span class="s2">&#34;mrr_cost_based=off&#34;</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*使用了MRR*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t2</span> <span class="k">where</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                            <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>  <span class="mi">101</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span><span class="p">;</span> <span class="k">Using</span> <span class="n">MRR</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">04</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p><em><strong>需要注意,当未使用MRR优化时,查询返回的记录是按照索引<code>a</code>来排序的,但使用了MRR优化时,返回的记录若<code>read_rnd_buffer</code>未满时是按照主键ID来排序的;若满记录就不是有序的了.</strong></em></p>
<h3 id="batched-key-accessbka">Batched Key Access(BKA)</h3>
<p>BKA算法是基于MRR对NLJ算法做的优化.</p>
<p>从驱动表中取出数据放入到<code>join_buffer</code>中,然后按照被驱动表的索引键排序,顺序去被驱动表查找相关数据.相比于NLJ的过程,BKA使用了MRR优化的思路,在被驱动表中是顺序读取,避免随机读取.</p>
<p>要启用BKA,需要设置参数.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*启动BKA,要先启动MRR*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="n">optimizer_switch</span><span class="o">=</span><span class="s1">&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*NLJ已被优化为BKA*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+----------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>      <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                                  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+----------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>     <span class="o">|</span>  <span class="mi">100</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span>                            <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t2</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="n">web</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">join</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">Batched</span> <span class="k">Key</span> <span class="k">Access</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+----------+------+----------+----------------------------------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><h3 id="bnl算法的性能问题">BNL算法的性能问题</h3>
<p>基于BNL算法时,由于<code>join_buffer</code>容量有限,如果驱动表是大表时需要进行分段处理,这样会导致被驱动表进行多次扫描,如果被驱动表是一个大的冷数据库,除了导致IO压力大外,还有什么其它影响?</p>
<p>从磁盘读取数据后是放入到<code>Buffer Pool</code>里的,而<code>Buffer Pool</code>的容量也是有限的,当空间不够时会淘汰一些老数据页来容纳新的数据页,淘汰算法InnoDB引擎使用的是变种LRU算法.</p>
<p>把<code>Buffer Pool</code>按照3:5的比例划分为old和young区域,从磁盘读取的数据先放入到old区域,如果超过1秒该数据页还在old区域且还有被访问就会被移入到young区域,在old和young区域都是LRU算法来淘汰老数据的.</p>
<p>若被驱动表的数据量小于old区域(即整个表能全部放入到old区域),由于需要多次扫描被驱动表,而时间间隔可能超过1秒,这会导致这部分数据会被移入到young区域.</p>
<p>若被驱动表的数据量超过了old区域,在遍历的过程中会涉及到淘汰old区域的数据来存放该表的数据,这样会导致业务正常访问的数据没有机会放入到young区域(没有超过1秒就被淘汰出old了).</p>
<p>以上两种情况都会对<code>Buffer Pool</code>的正常运作产生影响.</p>
<p>BNL算法对系统的影响主要包括:</p>
<ul>
<li>可能会多次扫描被驱动表,占用磁盘IO.</li>
<li>判断join条件需要执行M*N次对比,如果大表就会占用CPU资源.</li>
<li>可能会导致<code>Buffer Pool</code>的热数据被淘汰,影响内存命中率.</li>
</ul>
<p>优化策略:</p>
<ul>
<li>在被驱动表建索引,把BNL转化为BKA.</li>
<li>若被驱动表不适合加索引,可使用临时表(<code>create temporary</code>),把被驱动表满足条件的记录放入临时表,给临时表加索引,仍然转化为BKA.</li>
<li>hash join,但目前MySQL不支持,在<code>join_buffer</code>中支持hash,被驱动表的数据可以通过hash查找能快速定位,而不用再去执行M*N次比对了.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL索引(InnoDB引擎)</title>
			<link>https://shenbaise9527.com/posts/mysql%E4%B9%8Binnodb%E7%B4%A2%E5%BC%95/</link>
			<pubDate>Tue, 24 Nov 2020 20:43:33 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/mysql%E4%B9%8Binnodb%E7%B4%A2%E5%BC%95/</guid>
			<description>B+树 基于N叉树(每个父节点有N个子节点,子节点的值从左到右按照从小到大的顺序排列),非叶子节点只存储索引值,叶子节点储存索引值和数据,所有</description>
			<content type="html"><![CDATA[<h2 id="b树">B+树</h2>
<p>基于N叉树(每个父节点有N个子节点,子节点的值从左到右按照从小到大的顺序排列),非叶子节点只存储索引值,叶子节点储存索引值和数据,所有叶子节点采用链表串起来.</p>
<p>InnoDB采用的就是B+树,表的数据都是以索引的形式存放的,称为索引组织表.针对每个InnoDB引擎的表,都必须存在索引,当建表时没有显示声明索引,InnoDB会默认创建,如下<code>表t1</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*mysql版本*/</span>
<span class="n">Server</span> <span class="k">version</span><span class="p">:</span> <span class="mi">5</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">27</span><span class="o">-</span><span class="n">log</span> <span class="n">MySQL</span> <span class="n">Community</span> <span class="n">Server</span> <span class="p">(</span><span class="n">GPL</span><span class="p">)</span>

<span class="cm">/*创建表t,没有显示声明索引*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">city</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">addr</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
</code></pre></div><p>由于数据全部存储在叶子节点上,则每次查询都必须到叶子节点,其查找时间复杂度稳定,只和树高有关.
假如树高为4,N为1200,则这棵B+树能存储17亿多的数据量,整棵树的高度能维持在非常小的范围内,同时在内存里缓存前面若干层的节点,则极大的降低访问磁盘的次数,提高查询效率.</p>
<p>B+树的树高是由数据页大小和索引列的大小来决定的,而数据页大小是由参数<code>innodb_page_size</code>(默认为16k)的值决定;比如以一个<code>bigint</code>类型的字段为主键,则索引的大小为8字节(<code>bigint</code>大小)+6字节(指针大小,mysql里指针占6字节).则N的大小为16k/14字节,大约为1170.索引字段越小一个数据页能存放的数据就越多,N就会越大.</p>
<h2 id="索引分类">索引分类</h2>
<h3 id="主键索引">主键索引</h3>
<p>也被称为聚簇索引(clustered index),每个表都必须有且仅有一个主键索引(当没有显示声明主键索引时,InnoDB会默认创建一个以rowid为主键的索引),索引对应的字段的值唯一且不允许有空值.</p>
<p>主键索引的B+树的叶子节点的数据页里存放的是整行数据,且只有在主键索引的B+树中才有完整的数据.</p>
<h3 id="非主键索引">非主键索引</h3>
<p>又叫二级索引(secondary index),可以有多个,可分为唯一索引(索引对应的字段的值必须是唯一的,但允许为空值)和普通索引(对字段没什么限制,可重复可为空),对应的B+树的叶子节点的数据页里存放的是对应的主键值.</p>
<p>需要注意:当使用二级索引查询时只能获取到主键值和索引所对应列的值,要获取其它字段的值就只能根据主键值再去主键索引中查找,这个操作称为回表.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*mysql版本*/</span>
<span class="n">Server</span> <span class="k">version</span><span class="p">:</span> <span class="mi">5</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">27</span><span class="o">-</span><span class="n">log</span> <span class="n">MySQL</span> <span class="n">Community</span> <span class="n">Server</span> <span class="p">(</span><span class="n">GPL</span><span class="p">)</span>

<span class="cm">/*创建表t*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">city</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">addr</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">city</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">city</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span>

<span class="cm">/*根据普通索引city来查询,此时需要进行回表操作,来获取其它字段的值*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">city</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">;</span>

<span class="cm">/*根据主键索引来查询,直接在主键索引B+树上查找*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div><h2 id="索引维护">索引维护</h2>
<p>索引必然是有序的.当做增删改操作时,必须要进行必要的维护操作,来保持索引的有序性.在InnoDB中,读写都是以数据页为单位的(默认为16k),数据都是存放在数据页里的,当插入新值时为了保持索引的有序性,可能要把新值插入到数据页的中间位置,但如果此时数据页已满时会怎么样?</p>
<p>页分裂:当数据页已满时,引擎会申请一个新的数据页,然后挪动原数据页的一部分数据到新的数据页中.在这种情况下,插入性能是会受到影响的.另外数据页的空间利用率也会降低大约50%.</p>
<p>同理在删除数据时,有可能引发页合并(有分裂就有合并,是分裂的逆过程).</p>
<p>注意:</p>
<ul>
<li>当新数据要插入到某个数据页的首位置,而此时该数据页已满,为了避免页分裂,会优先去找前一个数据页是否还有空余,若有就把新数据插入到前一个数据页的末尾位置.</li>
<li>当新数据要插入到某个数据页的尾位置,而此时该数据页已满,为了避免页分裂,会优先去找后一个数据页是否还有空余,若有就把新数据插入到后一个数据页的首位置.</li>
</ul>
<p>为什么一般建议采用自增ID为主键?</p>
<ul>
<li>自增ID自带有序性,每次插入都是追加操作,不涉及到挪动其它记录,也不会触发叶子节点的分裂.</li>
<li>每个二级索引的叶子节点上都是主键的值,而自增ID若是整型(int)为4字节,若是长整型(bigint)为8字节,主键长度越小,二级索引的叶子节点就越小,占用的空间也就越小.</li>
</ul>
<h2 id="索引优化">索引优化</h2>
<h3 id="覆盖索引">覆盖索引</h3>
<p>为什么需要回表,是因为要去主键索引树中获取相应字段的值.但如果想要查询的字段是索引列的一部分列?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*仍以表t为例,先新加个索引,包含city和name字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city_name</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

<span class="cm">/*通过city来查询name*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">name</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="o">=</span> <span class="s1">&#39;hangzhou&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>  <span class="o">|</span> <span class="k">key</span>       <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name</span> <span class="o">|</span> <span class="n">city_name</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+-----------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*通过city来查询name和age*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="o">=</span> <span class="s1">&#39;hangzhou&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span>  <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city</span><span class="p">,</span><span class="n">city_name</span> <span class="o">|</span> <span class="n">city</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+----------------+------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>第一个查询采用的是索引city_name,Extra为<code>Using index</code>,表示是覆盖索引,需要查询的字段已包含在索引列中,不需要回表.</p>
<p>第二个查询采用的是索引city,Extra为<code>NULL</code>,则需要进行回表,去主键索引中获取相应字段的值.</p>
<p>覆盖索引能减少回表次数,即减少树的搜索次数,可显著提升性能.</p>
<h3 id="前缀索引">前缀索引</h3>
<ul>
<li>联合索引的最左N个字段.</li>
<li>字符串索引的最左M个字符.</li>
</ul>
<p>联合索引的值是按照索引定义里出现的字段顺序来排列的,比如表<code>t</code>的索引<code>city_name</code>是按照字段<code>city</code>和<code>name</code>的顺序排列的.
还是以表<code>t</code>为例,创建由字段<code>city</code>、<code>name</code>和<code>age</code>组成的联合索引.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*创建索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city_name_age</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>

<span class="cm">/*根据字段city和name来查询,使用了索引city_name_age*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="o">=</span> <span class="s1">&#39;hangzhou&#39;</span> <span class="k">and</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;zhou&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>           <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>         <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="n">city_name_age</span> <span class="o">|</span> <span class="mi">100</span>     <span class="o">|</span> <span class="n">const</span><span class="p">,</span><span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+---------------+---------+-------------+------+----------+-------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>联合索引的字段顺序如何安排?</p>
<ul>
<li>如果通过调整顺序,可以少维护一个索引,则这个顺序是需要优先考虑的.</li>
<li>索引空间的大小.比如表t对<code>name</code>和<code>age</code>字段添加索引,基于空间考虑,应该增加一个(name,age)的联合索引和一个(age)的单索引,这时因为字段name比字段age大.</li>
</ul>
<p>字符串索引,适用于模糊查询.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*在字符串字段city上新建索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city</span><span class="p">(</span><span class="n">city</span><span class="p">);</span>

<span class="cm">/*模糊查询*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="k">like</span> <span class="s1">&#39;h%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">city</span>          <span class="o">|</span> <span class="n">city</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看出<code>like 'h%'</code>模糊查询使用了索引<code>city</code>来快速查找.但如果是针对<code>like '%h%'</code>之类的模糊查询列?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*使用前后都模糊匹配模式,查询所有字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="k">like</span> <span class="s1">&#39;%h%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">43868</span> <span class="o">|</span>    <span class="mi">11</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*使用前后都模糊匹配模式,查询id字段*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="k">like</span> <span class="s1">&#39;%h%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="n">city</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">43868</span> <span class="o">|</span>    <span class="mi">11</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>针对查询<code>select * from t where city like '%h%'</code>,使用的是全表扫描.</p>
<p>针对查询<code>select id from t where city like '%h%'</code>,使用的索引<code>city</code>,看rows字段也是全索引扫描,由于只需要获取字段<code>id</code>,故优化器认为顺序扫描索引<code>city</code>比主键索引的代价小.</p>
<p><em><strong>针对索引,一种是通过索引来快速查找,而另一种是通过索引来顺序遍历.</strong></em></p>
<p>**注意:**针对字段<code>city</code>和<code>age</code>的联合索引,也是适用于<code>city like 'h%'</code>的模糊查询.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*在字段city和age上新建联合索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">city_age</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>

<span class="cm">/*利用联合索引的最左字段city的最左M个字符*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="k">like</span> <span class="s1">&#39;hang%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>      <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">city_age</span>      <span class="o">|</span> <span class="n">city_age</span> <span class="o">|</span> <span class="mi">50</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>联合索引(非主键索引)中的字段和主键索引所包含的字段有重复时,在非主键索引树中该字段不会出现多次.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*新建表geek*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">geek</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">a</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">b</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="k">c</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">d</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">b</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">ca</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">cb</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">b</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span>
</code></pre></div><p>如上<code>geek</code>表中有3个索引,字段<code>a</code>和<code>b</code>组成的主键索引、字段<code>c</code>和<code>a</code>组成的普通索引、字段<code>c</code>和<code>b</code>组成的普通索引.</p>
<ul>
<li>在<code>ca</code>索引树中,叶子节点包含的字段顺序为<code>c</code>、<code>a</code>和<code>b</code>.并不是<code>c</code>、<code>a</code>、<code>a</code>和<code>b</code>.</li>
<li>在<code>cb</code>索引树中,叶子节点包含的字段顺序为<code>c</code>、<code>b</code>和<code>a</code>.并不是<code>c</code>、<code>b</code>、<code>a</code>和<code>b</code>.</li>
</ul>
<h3 id="索引下推">索引下推</h3>
<p>针对前缀索引中的联合索引(<code>city</code>和<code>age</code>),适用于<code>city</code>的模糊查询,那如果查询条件再加上<code>age</code>会如何?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*在city字段上模糊匹配,在age上精确匹配*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">city</span> <span class="k">like</span> <span class="s1">&#39;hang%&#39;</span> <span class="k">and</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>      <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">city_age</span>      <span class="o">|</span> <span class="n">city_age</span> <span class="o">|</span> <span class="mi">54</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">5505</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看到仍然会使用索引<code>city_age</code>,Extra字段里的<code>Using index condition</code>表示使用了索引下推.通过字段<code>city</code>快速定位记录后,再直接利用索引中age字段的值来进行过滤.</p>
<p>这是MySQL5.6版本引入的<strong>索引下推优化(index condition pushdown)</strong>,可以在索引查找过程中,对索引包含的字段先做判断,直接过滤不满足条件的记录,减少回表次数,提高性能.</p>
<h2 id="索引选择">索引选择</h2>
<p>主要是针对普通索引和唯一索引的选择.</p>
<p>在选择的前提是要能满足业务的需求,比如业务上需要保证唯一性,但应用层并不一定能保证,需要数据库层面来保证,就必须选择唯一索引.
又比如身份证号,在业务应用层面已经保证了唯一性,并不需要数据库层面来保证,就可以选择普通索引,当然也可以选择唯一索引.</p>
<p>在普通索引和唯一索引都能保证业务正确的前提下,如何评估该选择普通索引还是唯一索引列?下面主要从查询和更新两方面来进行评估.</p>
<h3 id="查询">查询</h3>
<p>仍然以表<code>t</code>为例,针对字段<code>name</code>,分别创建唯一索引和普通索引时,其查找过程是如何的?针对查询语句:<code>select * from t where name='guanguan';</code>.</p>
<ul>
<li>对于普通索引而言,查找到第一条满足条件的记录后,需要继续查找下一条记录,直到碰到第一个不满足条件的记录.</li>
<li>对于唯一索引而言,由于索引定义了唯一性,查找到第一个满足条件的记录后,就会停止继续检索.</li>
</ul>
<p>上述两个查找过程的性能差异,几乎微乎其微.InnoDB读写都是基于数据页的,当要去磁盘查找某一记录时,是会把该记录所在的数据页整体读入内存的.对于普通索引的继续查找只是一次指针寻找和一次判断,对于现代CPU来说,影响微乎其微.</p>
<p>可见对于查询来说,普通索引和唯一索引之间的差异几乎微乎其微.</p>
<h3 id="更新">更新</h3>
<p>在比较更新的差异之前，先引入概念<code>change buffer</code>,这也是InnoDB对更新操作所作出的优化.</p>
<p>当需要更新一个数据页时,如果该数据页在内存中,就直接更新内存的数据.但如果该数据页不在内存中,在不影响数据一致性的前提下,引擎会把这些更新操作缓存到<code>change buffer</code>中,这样就暂时不需要把磁盘数据读入到内存中,减少了磁盘随机读取,提升了更新性能.</p>
<p>在必要时,会把<code>change buffer</code>中的数据应用到原始数据页中,得到新的数据页,这个过程称为<code>merge</code>.</p>
<p>那<code>change buffer</code>中的数据什么时候应用到原始数据页中列?</p>
<ul>
<li>当原始数据页被加载到Buffer pool时,会执行<code>merge</code>.</li>
<li>后台有线程定期会执行<code>merge</code>.</li>
<li>当MySQL正常关闭时,也会执行<code>merge</code>.</li>
</ul>
<p><code>change buffer</code>优化的前提是要不影响数据一致性,而对于唯一索引,由于需要判断是否唯一,就必须先把磁盘数据加载到内存中来进行判断,由于数据页已经在内存中了,直接更新内存就行了,所以该优化对唯一索引是不起作用的.因此<code>change buffer</code>优化只是对普通索引有效.</p>
<p><code>change buffer</code>优化实际上是延迟了更新操作,当一个数据页上对应的更新操作在<code>change buffer</code>中越多,其收益是越大的.但如果针对先更新然后马上就查询的场景,这个优化可能会起到反作用.该场景下随机IO的次数不会少,反而增加了<code>change buffer</code>的维护代价.</p>
<p><code>change buffer</code>用的是buffer pool里的内存,其大小可以通过参数<code>innodb_change_buffer_max_size</code>来动态设置,表示<code>change buffer</code>的大小最多只能占用buffer pool的比例.</p>
<p>另外是否启用<code>change buffer</code>或对哪些操作启用,是通过参数<code>innodb_change_buffering</code>来控制的,该参数默认是<code>all</code>,有以下几种选择:</p>
<ul>
<li>all: 默认值.开启buffer inserts、delete-marking operations、purges</li>
<li>nono: 不开启</li>
<li>inserts: 只对buffer insert操作(对insert和update有效)开启</li>
<li>deletes: 只对delete-marking操作开启</li>
<li>changes: 只对buffer insert和delete-marking操作开启</li>
<li>purges: 只对在后台执行的物理删除操作开启.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;%innodb_change_buffer%&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Variable_name</span>                 <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">innodb_change_buffer_max_size</span> <span class="o">|</span> <span class="mi">25</span>    <span class="o">|</span>
<span class="o">|</span> <span class="n">innodb_change_buffering</span>       <span class="o">|</span> <span class="k">all</span>   <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p><code>change buffer</code>是会持久化的,保存在系统表空间(<code>ibdata1</code>)</p>
<ul>
<li>数据库空闲时,后台有线程定时持久化</li>
<li>当数据库缓冲池空间不够时</li>
<li>当数据库正常关闭时</li>
<li>redo log写满时</li>
</ul>
<p>注意:</p>
<ul>
<li><code>change buffer</code>也是通过B+树来存储的,键是表空间ID.</li>
<li><code>change buffer</code>的变更也是会记录redo日志的(<strong>既然记录到redo中了,为什么还要持久化到系统表空间?</strong>).</li>
<li><code>change buffer</code>节省的主要是随机读磁盘的IO消耗.</li>
</ul>
<p>再来谈谈更新时,普通索引和唯一索引的差异:</p>
<ul>
<li>当数据页在内存中时,唯一索引会校验下唯一性,通过后再更新内存;而普通索引直接更新内存即可.</li>
<li>当数据页不在内存中时,唯一索引会先通过磁盘随机读把数据加载到内存中,然后再校验唯一性,通过后再更新内存;而普通索引是直接把更新操作记录到<code>change buffer</code>中.</li>
</ul>
<p>从更新来说,普通索引更具有优势.</p>
<h2 id="为什么会选错索引">为什么会选错索引?</h2>
<h3 id="现象分析">现象分析</h3>
<p>当一个表有多个索引,查询究竟走哪个索引?优化器是通过什么因素来决定使用哪个索引的?先看个例子.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*创建表t1*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">a</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">b</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">a</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">b</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">b</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="cm">/*创建存储过程插入数据*/</span>
<span class="k">delimiter</span> <span class="p">;;</span>
<span class="k">create</span> <span class="k">procedure</span> <span class="n">idata</span><span class="p">()</span> 
<span class="k">begin</span>
  <span class="k">declare</span> <span class="n">i</span> <span class="nb">int</span><span class="p">;</span>
  <span class="k">declare</span> <span class="n">j</span> <span class="nb">int</span><span class="p">;</span>
  <span class="k">set</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">do</span> 
    <span class="k">set</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
    <span class="n">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="mi">10000</span><span class="p">)</span> <span class="k">do</span> 
      <span class="k">insert</span> <span class="k">into</span> <span class="n">t1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">10000</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">10000</span><span class="p">);</span> 
      <span class="k">set</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> 
    <span class="k">end</span> <span class="n">while</span><span class="p">;</span>
    <span class="k">commit</span><span class="p">;</span>
    <span class="k">set</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">end</span> <span class="n">while</span><span class="p">;</span>
  <span class="k">end</span><span class="p">;;</span>
<span class="k">delimiter</span> <span class="p">;</span>

<span class="cm">/*调用存储过程,插入数据到表中*/</span>
<span class="k">call</span> <span class="n">idata</span><span class="p">();</span>

<span class="cm">/*查询使用索引a,符合预期*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">10001</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>上面例子中,查询使用索引<code>a</code>,符合预期,说明优化器选择了正确的索引.</p>
<p>再来看看另一种场景,事务隔离级别为<code>REPEATABLE-READ</code>.</p>
<table>
<thead>
<tr>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t1; call idata();</td>
</tr>
<tr>
<td></td>
<td>explain select * from t1 where a between 10000 and 20000;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody>
</table>
<p>session A:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">10001</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">start</span> <span class="k">transaction</span> <span class="k">with</span> <span class="n">consistent</span> <span class="n">snapshot</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>session B:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">delete</span> <span class="k">from</span> <span class="n">t1</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">100000</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">72</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">call</span> <span class="n">idata</span><span class="p">();</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="mi">93</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">100015</span> <span class="o">|</span>    <span class="mi">37</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>session B此时选择的是全表扫描,开启慢查询日志,再来看看查询的具体信息.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="n">long_query_time</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">force</span> <span class="k">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>

<span class="cm">/*慢查询日志,设置慢查询时间为0秒,即打印所有语句*/</span>
<span class="k">set</span> <span class="n">long_query_time</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="o">#</span> <span class="n">Time</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">16</span><span class="n">T06</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">528132</span><span class="n">Z</span>
<span class="o">#</span> <span class="k">User</span><span class="o">@</span><span class="k">Host</span><span class="p">:</span> <span class="n">web</span><span class="p">[</span><span class="n">web</span><span class="p">]</span> <span class="o">@</span> <span class="n">localhost</span> <span class="p">[]</span>  <span class="n">Id</span><span class="p">:</span>    <span class="mi">57</span>
<span class="o">#</span> <span class="n">Query_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">038091</span>  <span class="n">Lock_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000289</span> <span class="n">Rows_sent</span><span class="p">:</span> <span class="mi">10001</span>  <span class="n">Rows_examined</span><span class="p">:</span> <span class="mi">100000</span>
<span class="k">SET</span> <span class="k">timestamp</span><span class="o">=</span><span class="mi">1592288931</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">#</span> <span class="n">Time</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">16</span><span class="n">T06</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span><span class="mi">01</span><span class="p">.</span><span class="mi">998170</span><span class="n">Z</span>
<span class="o">#</span> <span class="k">User</span><span class="o">@</span><span class="k">Host</span><span class="p">:</span> <span class="n">web</span><span class="p">[</span><span class="n">web</span><span class="p">]</span> <span class="o">@</span> <span class="n">localhost</span> <span class="p">[]</span>  <span class="n">Id</span><span class="p">:</span>    <span class="mi">57</span>
<span class="o">#</span> <span class="n">Query_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">015590</span>  <span class="n">Lock_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000345</span> <span class="n">Rows_sent</span><span class="p">:</span> <span class="mi">10001</span>  <span class="n">Rows_examined</span><span class="p">:</span> <span class="mi">10001</span>
<span class="k">SET</span> <span class="k">timestamp</span><span class="o">=</span><span class="mi">1592288941</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">force</span> <span class="k">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
</code></pre></div><ul>
<li>第一个查询语句的Rows_examined为100000行,走的是全表扫描,耗时38毫秒.</li>
<li>第二个查询语句的Rows_examined为10001行,走的是索引a,耗时15毫秒.
很显然,针对第一个查询语句,优化器选错了索引.</li>
</ul>
<p>那么到底优化器选择索引的逻辑是什么列?</p>
<p><em><strong>优化器选择索引的目的,是找到一个最优执行方案,用最小的代价去执行语句.</strong></em></p>
<p>在数据库里面,扫描行数是影响执行代价的因素之一.扫描行数越少,意味这访问磁盘数据的次数越少,消耗CPU资源越少.但扫描行数并不是唯一的判断标准,优化器还会结合是否使用临时表、是否排序等因素进行综合判断.</p>
<p><strong>那扫描行数是怎么判断的?</strong>
在执行语句之前,数据库并不能直到满足条件的记录到底有多少条?只能根据统计信息来估算.这个统计信息就是索引的区分度.一个索引上不同的值越多,这个索引的区分度就越好.一个索引上不同的值得个数,称之为基数(cardinality),基数越大,说明索引的区分度越好.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*查看索引基数*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="k">index</span> <span class="k">from</span> <span class="n">t1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span><span class="c1"></span><span class="o">|</span> <span class="k">Table</span> <span class="o">|</span> <span class="n">Non_unique</span> <span class="o">|</span> <span class="n">Key_name</span> <span class="o">|</span> <span class="n">Seq_in_index</span> <span class="o">|</span> <span class="k">Column_name</span> <span class="o">|</span> <span class="k">Collation</span> <span class="o">|</span> <span class="k">Cardinality</span> <span class="o">|</span> <span class="n">Sub_part</span> <span class="o">|</span> <span class="n">Packed</span> <span class="o">|</span> <span class="k">Null</span> <span class="o">|</span> <span class="n">Index_type</span> <span class="o">|</span> <span class="k">Comment</span> <span class="o">|</span> <span class="n">Index_comment</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span> <span class="k">PRIMARY</span>  <span class="o">|</span>            <span class="mi">1</span> <span class="o">|</span> <span class="n">id</span>          <span class="o">|</span> <span class="n">A</span>         <span class="o">|</span>      <span class="mi">100015</span> <span class="o">|</span>     <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>   <span class="o">|</span>      <span class="o">|</span> <span class="n">BTREE</span>      <span class="o">|</span>         <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span> <span class="n">a</span>        <span class="o">|</span>            <span class="mi">1</span> <span class="o">|</span> <span class="n">a</span>           <span class="o">|</span> <span class="n">A</span>         <span class="o">|</span>      <span class="mi">100015</span> <span class="o">|</span>     <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>   <span class="o">|</span> <span class="n">YES</span>  <span class="o">|</span> <span class="n">BTREE</span>      <span class="o">|</span>         <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span> <span class="n">b</span>        <span class="o">|</span>            <span class="mi">1</span> <span class="o">|</span> <span class="n">b</span>           <span class="o">|</span> <span class="n">A</span>         <span class="o">|</span>      <span class="mi">100015</span> <span class="o">|</span>     <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>   <span class="o">|</span> <span class="n">YES</span>  <span class="o">|</span> <span class="n">BTREE</span>      <span class="o">|</span>         <span class="o">|</span>               <span class="o">|</span>
<span class="o">+</span><span class="c1">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span><span class="c1"></span><span class="mi">3</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>索引的基数都是通过采样统计得来的,针对表做精确统计代价太大,只能是采样统计了.默认选择N个数据页,统计这些页面上的不同值,得到一个平均值,然后乘以这个索引的页面数,就得到了索引的基数.而数据表是会持续更新的,当变更的行数超过1/M时,会自动触发重新做一次索引统计.</p>
<p>InnoDB有两种存储索引统计的方式,通过参数<code>innodb_stats_persistent</code>的值来选择:</p>
<ul>
<li>设置为on的时候,统计信息会持久化存储,默认的N是20,M是10</li>
<li>设置为off的时候,统计信息存储在内存中,默认的N是8,M是16</li>
</ul>
<p>从<code>show index</code>结果可以看到,索引基数都是一样的,优化器还要判断这个语句本身要扫描多少行?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">100015</span> <span class="o">|</span>    <span class="mi">37</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">force</span> <span class="k">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">37116</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>可以看到两个查询语句预计的扫描行数(rows字段),第一个语句的预估是正确的,rows的值是100015;但第二个语句的rows值是37116,偏差就大了(实际上rows应该是10001行).是这个偏差误导了优化器的判断.</p>
<p>第一个语句走的是主键索引,不需要回表;而第二个语句走的是普通索引,是需要回表查询的,回表的代价也是优化器需要考虑的.优化器认为直接扫描主键索引更快.</p>
<p>既然是统计信息不准确,那就需要修正,使用命令<code>analyze table t1</code>.可以看到修正之后,索引就选择正确了.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">analyze</span> <span class="k">table</span> <span class="n">t1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">--------+---------+----------+----------+
</span><span class="c1"></span><span class="o">|</span> <span class="k">Table</span>  <span class="o">|</span> <span class="n">Op</span>      <span class="o">|</span> <span class="n">Msg_type</span> <span class="o">|</span> <span class="n">Msg_text</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------+---------+----------+----------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">web</span><span class="p">.</span><span class="n">t1</span> <span class="o">|</span> <span class="k">analyze</span> <span class="o">|</span> <span class="n">status</span>   <span class="o">|</span> <span class="n">OK</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">--------+---------+----------+----------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">10001</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>再来看看另外一个语句:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="p">(</span><span class="n">a</span> <span class="k">between</span> <span class="mi">1</span> <span class="k">and</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">and</span> <span class="p">(</span><span class="n">b</span> <span class="k">between</span> <span class="mi">50000</span> <span class="k">and</span> <span class="mi">100000</span><span class="p">)</span> <span class="k">order</span> <span class="k">by</span> <span class="n">b</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                              <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span>           <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">50007</span> <span class="o">|</span>     <span class="mi">1</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span><span class="p">;</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>优化器选择了索引b,rows为50007行,扫描行数的估计值不准确,有选错了索引.</p>
<h3 id="选择异常的处理">选择异常的处理</h3>
<ol>
<li>在语句中使用<code>force index</code>强制选择一个索引.</li>
<li>考虑修改语句,引导MySQL使用我们期望的索引,把上面例子中的<code>order by b limit 1</code>换成<code>order by b, a limit 1</code>试试,看执行计划是怎样的.</li>
<li>在某些场景下,可以新建一个更适合的索引来供优化器选择,或者删掉误用的索引.</li>
</ol>
<h3 id="思考">思考</h3>
<p>第一个例子中是通过session A和session B的配合,来复现选错了索引的情况,如果单独执行session B的语句,会出现什么情况?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">delete</span> <span class="k">from</span> <span class="n">t1</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">100000</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">55</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">call</span> <span class="n">idata</span><span class="p">();</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="mi">41</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>  <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">t1</span>    <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">a</span>             <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span> <span class="mi">5</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">10001</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="n">condition</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>索引选择正确,为什么会出现这种差异?session A是马上开启一个一致性读视图,并没有其它操作,是因为什么造成了统计信息的错误?</p>
<p>当session A开启了一致性视图之后,session B的删除是不能直接把数据删除的.这样每一行数据会存在两个版本(<code>MVCC机制</code>),索引a上的数据其实是有两份的.但对于使用主键索引时,rows是直接按照表的行数来估计的,而表的行数,优化器是直接用<code>show table status</code>中的Rows值.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="k">table</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">&#39;t1&#39;</span><span class="err">\</span><span class="k">G</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">Name</span><span class="p">:</span> <span class="n">t1</span>
         <span class="n">Engine</span><span class="p">:</span> <span class="n">InnoDB</span>
        <span class="k">Version</span><span class="p">:</span> <span class="mi">10</span>
     <span class="n">Row_format</span><span class="p">:</span> <span class="k">Dynamic</span>
           <span class="k">Rows</span><span class="p">:</span> <span class="mi">100256</span>
 <span class="n">Avg_row_length</span><span class="p">:</span> <span class="mi">36</span>
    <span class="n">Data_length</span><span class="p">:</span> <span class="mi">3686400</span>
<span class="n">Max_data_length</span><span class="p">:</span> <span class="mi">0</span>
   <span class="n">Index_length</span><span class="p">:</span> <span class="mi">3178496</span>
      <span class="n">Data_free</span><span class="p">:</span> <span class="mi">15728640</span>
 <span class="n">Auto_increment</span><span class="p">:</span> <span class="mi">300001</span>
    <span class="n">Create_time</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">16</span> <span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">46</span>
    <span class="n">Update_time</span><span class="p">:</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">16</span> <span class="mi">15</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">39</span>
     <span class="n">Check_time</span><span class="p">:</span> <span class="k">NULL</span>
      <span class="k">Collation</span><span class="p">:</span> <span class="n">utf8_unicode_ci</span>
       <span class="n">Checksum</span><span class="p">:</span> <span class="k">NULL</span>
 <span class="n">Create_options</span><span class="p">:</span> 
        <span class="k">Comment</span><span class="p">:</span> 
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><h2 id="如何给字符串字段加索引">如何给字符串字段加索引?</h2>
<p>在字符串字段上加索引,是可以指定只取前几个字节的,如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*city全字段加索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">index1</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">48</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="cm">/*city字段前6个字节加索引*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">alter</span> <span class="k">table</span> <span class="n">t</span> <span class="k">add</span> <span class="k">index</span> <span class="n">index2</span><span class="p">(</span><span class="n">name</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="k">rows</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">48</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div><p>针对索引index2,占用的空间更小,这是前缀索引的优势,但带来的损失是可能会增加额外的记录扫描次数.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*先插入数据*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s1">&#39;zhangyi&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s1">&#39;zhanger&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s1">&#39;zhangsan&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s1">&#39;zhangsi&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s1">&#39;zhangwu&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="cm">/*查询*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;zhangsi&#39;</span><span class="p">;</span>
<span class="o">+</span><span class="c1">--------+----------+---------+-----+------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span>     <span class="o">|</span> <span class="n">city</span>     <span class="o">|</span> <span class="n">name</span>    <span class="o">|</span> <span class="n">age</span> <span class="o">|</span> <span class="n">addr</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------+----------+---------+-----+------+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">128004</span> <span class="o">|</span> <span class="n">hangzhou</span> <span class="o">|</span> <span class="n">zhangsi</span> <span class="o">|</span>  <span class="mi">20</span> <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------+----------+---------+-----+------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">07</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>查询如果使用的是索引index1</p>
<ol>
<li>在索引树上能直接定位到索引值为<code>zhangsi</code>的记录,取得主键ID的值</li>
<li>然后回表查询整行记录</li>
<li>继续取下一个索引值,发现已不满足条件,循环结束.</li>
</ol>
<p>查询如果使用的是索引index2</p>
<ol>
<li>在索引树上先定位到<code>zhang</code>的记录,取主键ID的值</li>
<li>然后回表获取字段<code>name</code>的值发现不满足条件,丢弃</li>
<li>继续取下一个索引值,值仍为<code>zhang</code>,取出主键ID的值</li>
<li>重复步骤2,若满足条件就把行放入记录集中</li>
<li>直到索引值不为<code>zhang</code>,循环结束.</li>
</ol>
<p>使用索引index2,总共会有5次回表,扫描了5次.使用前缀索引,导致查询语句读数据的次数变多了.如果索引index2设置为<code>name(6)</code>列?此时只需要扫描2次了.</p>
<p><em><strong>使用前缀索引,定义好长度,就可以做到既节省空间,又不用额外增加太多的查询成本.</strong></em></p>
<p>建立索引时要关注索引的区分度,区分度越高越好.可以通过统计索引上有多少个不同的值来判断要使用多长的前缀.从如下sql可以看出,可以选用<code>name(4)</code>来作为索引.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*统计各个长度的前缀数量*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">name</span><span class="p">)</span> <span class="k">as</span> <span class="n">L</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="k">as</span> <span class="n">L4</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="k">as</span> <span class="n">L5</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="k">as</span> <span class="n">L6</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="k">as</span> <span class="n">L7</span> <span class="n">f</span>
<span class="n">rom</span> <span class="n">t</span><span class="p">;</span><span class="o">+</span><span class="c1">-----+-----+-----+-----+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="n">L</span>   <span class="o">|</span> <span class="n">L4</span>  <span class="o">|</span> <span class="n">L5</span>  <span class="o">|</span> <span class="n">L6</span>  <span class="o">|</span> <span class="n">L7</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-----+-----+-----+-----+
</span><span class="c1"></span><span class="o">|</span> <span class="mi">149</span> <span class="o">|</span> <span class="mi">145</span> <span class="o">|</span> <span class="mi">145</span> <span class="o">|</span> <span class="mi">148</span> <span class="o">|</span> <span class="mi">149</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-----+-----+-----+-----+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">52</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p><em><strong>当使用前缀索引时,会导致覆盖索引无效(无论前缀使用多少位).</strong></em></p>
<p>以<code>select id, name from t where name = 'zhangsi'</code>为例,如果使用索引index2(就算使用<code>name(16)</code>为索引),获取主键ID的值后还必须回表,然后判断name的值是否满足条件,这就导致覆盖索引无效了.</p>
<h2 id="索引失效">索引失效</h2>
<h3 id="条件字段函数操作">条件字段函数操作</h3>
<p>如果在<code>where</code>条件查询的字段上使用函数为如何?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*创建交易流水表*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">tradelog</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">tradeid</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="k">operator</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">t_modified</span><span class="o">`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">tradeid</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">tradeid</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">t_modified</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">t_modified</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span>

<span class="cm">/*整个表模拟了10万行数据*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">tradelog</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="o">|</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="o">|</span>   <span class="mi">100000</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>

<span class="cm">/*在字段t_modified使用month函数*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="k">where</span> <span class="k">month</span><span class="p">(</span><span class="n">t_modified</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+--------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>        <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+--------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">tradelog</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="n">t_modified</span> <span class="o">|</span> <span class="mi">6</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">100194</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+--------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>查询语句是统计所有7月份的流水,从Extra可以看出是使用了索引<code>t_modified</code>,从rows看是索引全扫描.使用函数<code>month</code>之后,获取到的值并不是有序的,所以无法利用索引的有序性来快速查找,只能是全索引扫描.</p>
<p>为了能利用索引的快速定位能力,就需要把上面的sql改造成按照字段本身的范围查询</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*按照范围来查询,利用索引特性快速定位*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="k">where</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">t_modified</span> <span class="o">&gt;=</span> <span class="s1">&#39;2016-07-01&#39;</span> <span class="k">and</span> <span class="n">t_modified</span> <span class="o">&lt;</span> <span class="s1">&#39;2016-08-01&#39;</span><span class="p">)</span> <span class="k">or</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">t_modified</span> <span class="o">&gt;=</span> <span class="s1">&#39;2017-07-01&#39;</span> <span class="k">and</span> <span class="n">t_modified</span> <span class="o">&lt;</span> <span class="s1">&#39;2017-08-01&#39;</span><span class="p">)</span> <span class="k">or</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">t_modified</span> <span class="o">&gt;=</span> <span class="s1">&#39;2018-07-01&#39;</span> <span class="k">and</span> <span class="n">t_modified</span> <span class="o">&lt;</span> <span class="s1">&#39;2018-08-01&#39;</span><span class="p">);</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>        <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">tradelog</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">range</span> <span class="o">|</span> <span class="n">t_modified</span>    <span class="o">|</span> <span class="n">t_modified</span> <span class="o">|</span> <span class="mi">6</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">5605</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>再来看看一个非常简单的加法操作,也是全表扫描,无法利用主键索引.</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="k">where</span> <span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">tradelog</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">100194</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p><em><strong>在索引字段上使用函数会导致无法利用索引的快速定位能力,不管是什么函数,都会导致优化器认为无法使用索引快速定位.</strong></em></p>
<h3 id="隐式类型转换">隐式类型转换</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="k">where</span> <span class="n">tradeid</span> <span class="o">=</span> <span class="mi">6981747220</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">tradelog</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="n">tradeid</span>       <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">100194</span> <span class="o">|</span>    <span class="mi">10</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">3</span> <span class="n">warnings</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>字段<code>tradeid</code>上是有索引的,而上面的语句直接走的主键全表扫描,为什么没有使用<code>tradeid</code>索引?</p>
<p>在表中字段<code>tradeid</code>的定义是<code>varchar(32)</code>,为字符串类型.而<code>where</code>里等号右边是个整数,当两边类型不一致时,MySQL是如何处理的?</p>
<p>当字符串与数字进行比较时,是把字符串转化为数字还是把数字转换为字符串?</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="s2">&#34;10&#34;</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="o">|</span> <span class="s2">&#34;10&#34;</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="o">|</span>        <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+
</span><span class="c1"></span><span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>上面<code>select &quot;10&quot; &gt; 9</code>返回1,说明是把字符串转换为数字了.</p>
<p>实际上语句<code>select * from tradelog where tradeid = 6981747220</code>相当于被转化为了<code>select * from tradelog where CAST(tradeid AS signed int) = 6981747220</code>,这条语句就触发了上面说的:对索引字段做函数操作,优化器放弃走树搜索功能.</p>
<h3 id="隐式字符编码转换">隐式字符编码转换</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="cm">/*新建交易明细表*/</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">trade_detail</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">tradeid</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">trade_step</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">step_info</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">tradeid</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">tradeid</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span>

<span class="cm">/*关联查询*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="n">l</span><span class="p">,</span> <span class="n">trade_detail</span> <span class="n">d</span> <span class="k">where</span> <span class="n">d</span><span class="p">.</span><span class="n">tradeid</span><span class="o">=</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span> <span class="k">and</span> <span class="n">l</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">100002</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span>   <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">l</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span><span class="p">,</span><span class="n">tradeid</span> <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>        <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">d</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>            <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>   <span class="mi">11</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>驱动表为表<code>tradelog</code>,被驱动表为表<code>trade_detail</code>.查询对表<code>tradelog</code>是走的主键索引,但表<code>trade_detail</code>却是全表扫描,但在其字段<code>tradeid</code>是存在索引的,为何?</p>
<p>对比发现,表<code>tradelog</code>的字符集是<code>utf8mb4</code>,而表<code>trade_detail</code>的字符集是<code>utf8</code>,字符集不一样时查询时如何处理的?字符集<code>utf8mb4</code>是<code>utf8</code>的超集,MySQL会把<code>utf8</code>字符串转换为<code>utf8mb4</code>字符集,然后再做比较.查询语句会转化为如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="n">l</span><span class="p">,</span> <span class="n">trade_detail</span> <span class="n">d</span> <span class="k">where</span> <span class="k">convert</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">tradeid</span> <span class="k">USING</span> <span class="n">utf8mb4</span><span class="p">)</span><span class="o">=</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span> <span class="k">and</span> <span class="n">l</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">100002</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span>   <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">l</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span><span class="p">,</span><span class="n">tradeid</span> <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>        <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">d</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>            <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>   <span class="mi">11</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>转化后的语句对表<code>trade_detail</code>的索引上的字段做了函数操作,此时优化器是会放弃树搜索功能的,就导致做了全表扫描.</p>
<p>再来看看如下语句:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">l</span><span class="p">.</span><span class="k">operator</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="n">l</span><span class="p">,</span> <span class="n">trade_detail</span> <span class="n">d</span> <span class="k">where</span> <span class="n">d</span><span class="p">.</span><span class="n">tradeid</span><span class="o">=</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span> <span class="k">and</span> <span class="n">d</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">d</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">l</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="n">tradeid</span>       <span class="o">|</span> <span class="n">tradeid</span> <span class="o">|</span> <span class="mi">131</span>     <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><p>驱动表为表<code>trade_detail</code>,被驱动表为表<code>tradelog</code>.这个语句里两个表都有用到索引,但驱动表用的是主键索引,而被驱动表用的是索引<code>tradeid</code>.语句在转化时是针对驱动表的<code>tradeid</code>字段,所以被驱动表可以用上索引<code>tradeid</code>.</p>
<p>针对字符集不一样的情况下的优化:</p>
<ul>
<li>修改表结构,把字符集设置成一样.</li>
<li>修改sql语句,可以主动把驱动表的字符集修改为被驱动表的字符集,使得可以使用被驱动表的索引.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tradelog</span> <span class="n">l</span><span class="p">,</span> <span class="n">trade_detail</span> <span class="n">d</span> <span class="k">where</span> <span class="n">d</span><span class="p">.</span><span class="n">tradeid</span><span class="o">=</span><span class="k">convert</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span> <span class="k">using</span> <span class="n">utf8</span><span class="p">)</span> <span class="k">and</span> <span class="n">l</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">100002</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">l</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">d</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="n">tradeid</span>       <span class="o">|</span> <span class="n">tradeid</span> <span class="o">|</span> <span class="mi">99</span>      <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">4</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
</span><span class="c1"></span><span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>golang数据类型</title>
			<link>https://shenbaise9527.com/posts/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
			<pubDate>Sun, 22 Nov 2020 11:41:27 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
			<description>主要包含基本的内建类型(布尔类型、数值类型和字符串类型)和复合类型(array、slice、map、channel、function、str</description>
			<content type="html"><![CDATA[<p>主要包含基本的内建类型(布尔类型、数值类型和字符串类型)和复合类型(array、slice、map、channel、function、struct、interface)</p>
<h2 id="基本数据类型">基本数据类型</h2>
<h3 id="布尔类型">布尔类型</h3>
<p>类型标记为bool，值为true/false，零值为false，<strong>值类型，可定义为常量</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 变量定义的几种方式
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">bflag</span> <span class="kt">bool</span>
<span class="nx">bflag</span> <span class="p">=</span> <span class="kc">true</span>

<span class="kd">var</span> <span class="nx">bflag1</span> <span class="kt">bool</span> <span class="p">=</span> <span class="kc">true</span>
<span class="kd">var</span> <span class="nx">bflag2</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c1">// 短变量声明,只能用于函数内部
</span><span class="c1"></span><span class="nx">bflag3</span> <span class="o">:=</span> <span class="kc">true</span>
</code></pre></div><h3 id="整数类型">整数类型</h3>
<p>类型标记为<strong>int/uint、int8/uint8、int16/uint16、int32/uint32、int64/uint64、byte、rune</strong>，零值为0，<strong>值类型，可定义为常量</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">标记符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int/uint</td>
<td style="text-align:left">有符号/无符号整数,依赖于CPU平台机器字大小,32或64bit</td>
</tr>
<tr>
<td style="text-align:left">int8/uint8</td>
<td style="text-align:left">有符号/无符号整数,8bit</td>
</tr>
<tr>
<td style="text-align:left">int16/uint16</td>
<td style="text-align:left">有符号/无符号整数,16bit</td>
</tr>
<tr>
<td style="text-align:left">int32/uint32</td>
<td style="text-align:left">有符号/无符号整数,32bit</td>
</tr>
<tr>
<td style="text-align:left">int64/uint64</td>
<td style="text-align:left">有符号/无符号整数,64bit</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">等价于uint8,一般用于强调数值是一个原始的数据而不是一个小的整数</td>
</tr>
<tr>
<td style="text-align:left">rune</td>
<td style="text-align:left">等价于int32,表示一个Unicode码点</td>
</tr>
</tbody>
</table>
<p>其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255</p>
<p>rune专门用来存储Unicode编码的单个字符，有5种表示方式：</p>
<ol>
<li>该rune字面量所对应的字符，比如&rsquo;a'、'-'，这个字符必须是Unicode编码规范所支持的</li>
<li>使用“\x”为前导后跟2位十六进制数，表示宽度为1字节</li>
<li>使用“\”为前导后跟3位八进制数，表示的范围与上一个表示法相同</li>
<li>使用“\u”为前导后跟4位十六进制数，表示宽度为2字节的值</li>
<li>使用“\U”为前导后跟8位十六进制数，表示宽度为4字节的值
<strong>还支持一类特殊的字符序列&mdash;-转义符</strong></li>
</ol>
<p>Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">*</span>      <span class="o">/</span>      <span class="o">%</span>      <span class="o">&lt;&lt;</span>       <span class="o">&gt;&gt;</span>     <span class="o">&amp;</span>       <span class="o">&amp;^</span>
<span class="o">+</span>      <span class="o">-</span>      <span class="p">|</span>      <span class="p">^</span>
<span class="o">==</span>     <span class="o">!=</span>     <span class="p">&lt;</span>      <span class="o">&lt;=</span>       <span class="p">&gt;</span>      <span class="o">&gt;=</span>
<span class="o">&amp;&amp;</span>
<span class="o">||</span>
</code></pre></div><p>整数的bit位操作符</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">&amp;</span>      <span class="nx">位运算</span> <span class="nx">AND</span>
<span class="p">|</span>      <span class="nx">位运算</span> <span class="nx">OR</span>
<span class="p">^</span>      <span class="nx">位运算</span> <span class="nx">XOR</span>
<span class="o">&amp;^</span>     <span class="nx">位清空</span> <span class="p">(</span><span class="nx">AND</span> <span class="nx">NOT</span><span class="p">)</span>
<span class="o">&lt;&lt;</span>     <span class="nx">左移</span>
<span class="o">&gt;&gt;</span>     <span class="nx">右移</span>
</code></pre></div><blockquote>
<p><strong>注意：</strong> ++/- -只能后置，且是语句不是表达式，不能进行赋值，即i++是合法，++i和j=i++都是非法的</p>
</blockquote>
<h3 id="浮点数类型">浮点数类型</h3>
<p>类型标记为<strong>float32/float64</strong>，零值为0，<strong>值类型，可定义为常量</strong></p>
<p>浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。</p>
<p>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（<strong>注意：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差</strong>）。</p>
<h3 id="复数类型">复数类型</h3>
<p>类型标记为<strong>complex64/complex128</strong>，<strong>值类型，可定义为常量</strong></p>
<h3 id="字符串类型">字符串类型</h3>
<p>类型标记为<strong>string</strong>，零值为&quot;&quot;，<strong>值类型，可定义为常量</strong></p>
<p>一个字符串是一个不可改变的字节序列</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;x&#39;</span> <span class="c1">// 非法，字符串是只读的
</span></code></pre></div><p>字符串在Go语言内存模型中用一个2字长的数据结构表示。它包含一个指向字符串存储数据的指针和一个长度数据。因为string类型是不可变的，对于多字符串共享同一个存储数据是安全的。切分操作会得到一个新的2字长结构字符串，但是指向同一个字节序列，切分时不涉及内存分配或复制操作。</p>
<h3 id="常量特别说明">常量特别说明</h3>
<p>常量只能是布尔类型、整数类型、浮点数类型、复数类型、字符串</p>
<p>常量生成器<strong>itoa</strong>，常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式</p>
<p>无类型常量：
Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是<strong>无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</strong>。
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 不需要类型转换
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>

<span class="c1">// 需要类型转换,Pi64定义了具体类型
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">Pi64</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">Pi64</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex128</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
</code></pre></div><h2 id="复合数据类型">复合数据类型</h2>
<h3 id="数组array">数组(array)</h3>
<p>固定长度的特定类型元素组成的序列，<strong>值类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>

<span class="c1">// 含有100个元素的数组，最后一个元素被初始化为-1，其余的为0
</span><span class="c1"></span><span class="nx">d</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">99</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

<span class="c1">// 支持切片操作
</span></code></pre></div><h3 id="切片slice">切片(slice)</h3>
<p>变长的序列，序列中每个元素都有相同的类型，一个slice类型一般写作[]T，其中T代表slice中元素的类型。
<strong>零值为nil，引用类型</strong></p>
<p>元素的底层存储结构为数组，一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度指目前slice中已有元素的数目；长度不能超过容量，容量指目前slice最多能存放的元素个数。内置的len和cap函数分别返回slice的长度和容量。</p>
<p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。</p>
<p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>    <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="kc">nil</span>        <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>    <span class="c1">// len(s) == 0, s != nil
</span></code></pre></div><p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
<span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</code></pre></div><p>当调用内置的append函数向slice追加元素时，如果元素数量超过容量，会引发扩容操作，此时slice的指针所指向的数组会发生变更</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// intslice为nil
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">intslice</span> <span class="p">[]</span><span class="kt">int64</span>
	
	<span class="c1">// intslice的长度和容量为4
</span><span class="c1"></span>	<span class="nx">intslice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intslice</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">intslice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">intslice</span><span class="p">))</span> <span class="c1">// output:4 4
</span><span class="c1"></span>	
	<span class="c1">// intslice会扩充，长度和容量变为8
</span><span class="c1"></span>	<span class="nx">intslice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intslice</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">intslice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">intslice</span><span class="p">))</span> <span class="c1">// output:8 8
</span><span class="c1"></span>	
	<span class="c1">// 通过切片操作赋值给is1，此时is1和intslice底层指向同一个数组
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="o">:=</span> <span class="nx">intslice</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 2 4
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33]
</span><span class="c1"></span>	
	<span class="c1">// is1追加一个元素，长度未超过容量，不会引起扩容，此时修改is1中的元素会影响intslice
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">is1</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 3 4
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33 99]
</span><span class="c1"></span>	<span class="c1">// intslice[3]也被修改为99了
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">intslice</span><span class="p">)</span> <span class="c1">// output: [11 22 33 99 55 66 77 88]
</span><span class="c1"></span>	
	<span class="c1">// 继续追加元素，超过了容量，引起扩容，is1和intslice此时底层指向不同的数组，对is1的操作不会影响intslice
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">is1</span><span class="p">,</span> <span class="mi">990</span><span class="p">,</span> <span class="mi">991</span><span class="p">,</span> <span class="mi">992</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 6 8
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33 99 990 991 992]
</span><span class="c1"></span>	<span class="c1">// intslice并未被修改
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">intslice</span><span class="p">)</span> <span class="c1">// output: [11 22 33 99 55 66 77 88]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>遍历切片时可以直接采用下标也可以采用for-range的方式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int32</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>

	<span class="c1">// 针对切片的第一种遍历方式,直接采用下标访问
</span><span class="c1"></span>	<span class="nx">ssLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ssLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ss</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>

	<span class="c1">// 针对切片的第二种遍历方式,使用for-range,也是采用下标访问
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ss</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">))</span>
	<span class="c1">// 针对切片的第三种遍历方式,也是使用for-range,但采用索引+值的方式,下文中索引使用了_(忽略该参数)
</span><span class="c1"></span>	<span class="c1">// 需要注意value是个局部变量,生命周期归属这个for循环
</span><span class="c1"></span>	<span class="c1">// 迭代时只会改变value所对应的值,value本身只会被声明一次,即在整个for循环内其地址是不会改变的
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="cm">/* 注意和下面的go func方式进行比较
</span><span class="cm">		   此种方式在https://goplay.space/上一直输出的是5(即切片中的最后一个元素)
</span><span class="cm">		   但在本地windows下用vscode输出的结果是变化的,有时全部输出5,有时输出4和5...
</span><span class="cm">		   此种方式存在竞态
</span><span class="cm">		   使用go tool vet 可以进行检测：loop variable value captured by func literal
</span><span class="cm">		*/</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 此种方式在vscode上会直接显示告警 loop variable value captured by func literal
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="c1">// 此种方式会把切片中的元素打印一遍
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="字典map">字典(map)</h3>
<p>map在底层是用哈希表实现的，哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p><strong>零值为nil，引用类型</strong></p>
<p>一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法。</p>
<p>可以通过内置函数make或字面值创建map</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 通过内置make来创建
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="c1">// 通过字面值创建,并初始化了2个元素
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">&#34;alice&#34;</span><span class="p">:</span>   <span class="mi">31</span><span class="p">,</span>
    <span class="s">&#34;charlie&#34;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 通过key的下标进行访问对应的value
</span><span class="c1"></span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">32</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">])</span> <span class="c1">// &#34;32&#34;
</span><span class="c1"></span>
<span class="c1">// 通过key来访问value时，若key不存在，也不会报错，而是会返回value对应的零值
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">])</span> <span class="c1">// &#34;0&#34;,bob并不存在于ages中,返回value的零值(0)
</span><span class="c1"></span><span class="nx">age</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span>  <span class="c1">// age=0
</span><span class="c1"></span>
<span class="c1">// 若key存在则ok为true;若key不存在则ok为false。可通过这种方式来判断key是不是存在
</span><span class="c1">// 判断一个元素是否存在必须采用此种方式，不能通过比较零值
</span><span class="c1"></span><span class="nx">age</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span>

<span class="c1">// 通过内置delete函数来删除元素
</span><span class="c1"></span><span class="nb">delete</span><span class="p">(</span><span class="nx">ages</span><span class="p">,</span> <span class="s">&#34;alice&#34;</span><span class="p">)</span>

<span class="c1">// 空的map
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</code></pre></div><blockquote>
<p>**注意：**向一个nil值的map存入元素将导致一个panic异常</p>
</blockquote>
<p>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作。禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="c1">// compile error: cannot take address of map element
</span></code></pre></div><p>遍历map中全部的key/value对，可以使用range风格的for循环实现，和之前的slice遍历语法类似</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// name和age对应map中的key、value，迭代顺序是不确定的
</span><span class="c1"></span><span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ages</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\t%d\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</p>
<p>hash结构中直接使用的Bucket数组，而不是Bucket*指针的数据，是一段连续的内存空间。</p>
<p>每个bucket中存放最多8个key/value对, 如果多于8个，那么会申请一个新的bucket，并将它与之前的bucket链起来(<strong>称为溢出链overflow</strong>)，溢出链的Bucket的空间是使用mallocgc分配的。</p>
<p>hash结构采用的可扩展哈希的算法。由hash值mod当前hash表大小决定某一个值属于哪个桶，而hash表大小是2的指数(2^B)。每次扩容，会增大到上次大小的两倍。结构体中有一个buckets和一个oldbuckets是用来实现增量扩容的。正常情况下直接使用buckets，而oldbuckets为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</p>
<p>按key的类型采用相应的hash算法得到key的hash值。将hash值的低位当作hmap结构体中buckets数组的index，找到key所在的bucket。将hash的高8位存储在了bucket的tophash中。**注意，这里高8位不是用来当作key/value在bucket内部的offset的，而是作为一个主键，在查找时对tophash数组的每一项进行顺序匹配的。**先比较hash值高位与bucket的tophash[i]是否相等，如果相等则再比较bucket的第i个的key与所给的key是否相等。如果相等，则返回其对应的value，反之，在overflow buckets中按照上述方法继续寻找。</p>
<blockquote>
<p>**注意：**Bucket中key/value的放置顺序，是将keys放在一起，values放在一起，为什么不将key和对应的value放在一起呢？如果那么做，存储结构将变成key1/value1/key2/value2… 设想如果是这样的一个map[int64]int8，考虑到字节对齐，会浪费很多存储空间。不得不说通过上述的一个小细节，可以看出Go在设计上的深思熟虑。</p>
</blockquote>
<p>Go语言使用的是增量扩容。假设扩容之前容量为X，扩容之后容量为Y，对于某个哈希值hash，一般情况下(hash mod X)不等于(hash mod Y)，所以扩容之后要重新计算每一项在哈希表中的新位置。当hash表扩容之后，需要将那些旧的pair重新哈希到新的table上(源代码中称之为evacuate)， 这个工作并没有在扩容之后一次性完成，而是逐步的完成（在insert和remove时每次搬移1-2个pair），主要是为了缩短map容器的响应时间，避免扩容时阻塞(本质上还是将总的扩容时间分摊到了每一次哈希操作上面)。</p>
<blockquote>
<p>**注意：**如果key或value小于128字节，则它们的值是直接使用的bucket作为存储的。否则bucket中存储的是指向实际key/value数据的指针，</p>
</blockquote>
<h3 id="通道channel">通道(channel)</h3>
<p>类型标记为chan，它在栈上只是一个指针，实际的数据都是由指针所指向的堆上面。<strong>零值为nil，引用类型</strong></p>
<p>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 通过内置make函数创建chan
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 先声明，再创建
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 通过内置close函数关闭chan，此操作不是必须的，当没有被引用时，GC会回收
</span><span class="c1"></span><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</code></pre></div><p>channel创建时默认时双向的，但Go语言也提供了单向的channel，分别表示用于只发送或只接收的channel。类型<strong>chan&lt;- int</strong>表示一个只发送int的channel，只能发送不能接收。相反，类型**&lt;-chan int**表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向）这种限制将在编译期检测。</p>
<p>Go语言提供了无缓冲的channels和带缓冲的channels，在使用make创建时看是否提供了第二个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 无缓冲channel
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 带缓冲channel,容量为100
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">// 读channel时可忽略读取到的值
</span><span class="c1"></span><span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></div><ul>
<li>读或写一个nil的channel的操作会永远阻塞</li>
<li>读一个已关闭的channel会立刻返回一个channel元素类型的零值</li>
<li>写一个已关闭的channel会导致panic</li>
<li>无缓冲channel是同步的，若发送者和接受者不是同时存在，则读或写将被阻塞</li>
<li>有缓冲channel是异步的，当容量为满时写将被阻塞，当容量为空时读将被阻塞</li>
</ul>
<p>select-case 多路复用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="p">}()</span>

	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Commencing countdown. Please return to abort.&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
		<span class="cm">/* case后必须是channel变量的操作
</span><span class="cm">		   若不存在default分支且所有channel都未触发时，select将阻塞
</span><span class="cm">		   若存在default分支且所有channel都未触发时，会立即执行default分支
</span><span class="cm">		   若只有1个channel触发时，会立即执行对应的case分支代码
</span><span class="cm">		   若同时多个channel触发时，会随机选择执行其中一个对应的case分支代码
</span><span class="cm">		*/</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lauch aborted!&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">abort</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lauching.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 读取channel时可返回2个参数，ok表示是否读取成功，当fileSize被关闭时会立即返回false
</span><span class="c1"></span><span class="nx">fileSize</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
<span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSize</span>
</code></pre></div><p>for-range 迭代，可循环获取channel上的数据，若channel上没有数据会被阻塞。当channel被close后for-range结束循环迭代</p>
<h3 id="函数function">函数(function)</h3>
<p>类型标记为func，函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。<strong>零值为nil，引用类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">body</span>
<span class="p">}</span>

<span class="c1">// 当涉及多参数返回时，需要注意返回值类型是必须的，返回值命名是可选的（所有返回值要么都有命名，要么都没有）
</span><span class="c1">// 命名的返回值可以在函数内部作为变量来使用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="c1">// 以下2种声明是错误的
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>
</code></pre></div><p>函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p>
<p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// squares返回一个匿名函数。
</span><span class="c1">// 该匿名函数每次被调用时都会返回下一个数的平方。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">squares</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">++</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">squares</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;4&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;9&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;16&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><blockquote>
<p>**注意：**Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义</p>
</blockquote>
<h3 id="方法">方法</h3>
<p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;math&#34;</span>

<span class="c1">// 结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// 函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Point结构的一个方法,
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nf">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。可以任意的选择接收器的名字。</p>
<p>在方法调用过程中，接收器参数一般会在方法名之前出现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义Point类型的变量
</span><span class="c1"></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

<span class="c1">// 通过变量调用方法
</span><span class="c1"></span><span class="nx">r</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</code></pre></div><p>也可以采用指针来声明方法，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 方法的接收器类型是*Point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nf">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。</li>
<li>不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到。Point{1, 2}.ScaleBy(2)是非法的，编译会报错</li>
</ul>
<h3 id="结构体struct">结构体(struct)</h3>
<p>类型标记为struct，<strong>零值为结构中各成员变量所对应的零值，值类型</strong>
结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义了结构体Employee
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>        <span class="kt">int</span>
    <span class="nx">Name</span>      <span class="kt">string</span>
    <span class="nx">Address</span>   <span class="kt">string</span>
    <span class="nx">DoB</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">Position</span>  <span class="kt">string</span>
    <span class="nx">Salary</span>    <span class="kt">int</span>
    <span class="nx">ManagerID</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// 声明变量，类型为Employee
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">dilbert</span> <span class="nx">Employee</span>
</code></pre></div><p>dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 直接对每个成员赋值
</span><span class="c1"></span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">-=</span> <span class="mi">5000</span>

<span class="c1">// 对成员取地址，然后通过指针访问
</span><span class="c1"></span><span class="nx">position</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Position</span>
<span class="o">*</span><span class="nx">position</span> <span class="p">=</span> <span class="s">&#34;Senior &#34;</span> <span class="o">+</span> <span class="o">*</span><span class="nx">position</span>

<span class="c1">// 点操作符也可以和指向结构体的指针一起工作：
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">employeeOfTheMonth</span> <span class="o">*</span><span class="nx">Employee</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">dilbert</span>
<span class="nx">employeeOfTheMonth</span><span class="p">.</span><span class="nx">Position</span> <span class="o">+=</span> <span class="s">&#34; (proactive team player)&#34;</span>
</code></pre></div><blockquote>
<p>**注意：**结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p>
</blockquote>
<p>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 严格按照结构体定义的成员顺序
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>

<span class="c1">// 以成员名字和相应的值来初始化，可以包含部分或全部的成员，成员出现的顺序不重要
</span><span class="c1"></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// 初始化全部成员
</span><span class="c1"></span><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span> <span class="c1">// 初始化其中一个成员，其它成员默认为对应的零值
</span><span class="c1"></span>
<span class="c1">// 以上2种方式不能混用
</span></code></pre></div><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用= =或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员</p>
<p>Go语言提供的不同寻常的结构体嵌入机制，让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Circle</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span> <span class="c1">// 匿名嵌套
</span><span class="c1"></span>    <span class="nx">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Wheel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Circle</span> <span class="c1">// 匿名嵌套
</span><span class="c1"></span>    <span class="nx">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// 基于匿名嵌入的特性，可以直接访问叶子属性而不需要给出完整的路径
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Wheel</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>            <span class="c1">// 等价于w.Circle.Point.X = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>            <span class="c1">// 等价于w.Circle.Point.Y = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Radius</span> <span class="p">=</span> <span class="mi">5</span>       <span class="c1">// 等价于w.Circle.Radius = 5
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Spokes</span> <span class="p">=</span> <span class="mi">20</span>

<span class="c1">// 结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">}</span>                       <span class="c1">// compile error: unknown fields
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// compile error: unknown fields
</span><span class="c1"></span>
<span class="c1">// 正确的做法
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span>
    <span class="nx">Circle</span><span class="p">:</span> <span class="nx">Circle</span><span class="p">{</span>
        <span class="nx">Point</span><span class="p">:</span>  <span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
        <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="c1">// NOTE: 逗号是必须要的
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员。</p>
<p>但是在包外部，因为circle和point没有导出不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>
<p>目前描述的匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。匿名成员并不要求是结构体类型，其实任何命名的类型都可以作为结构体的匿名成员。</p>
<p><strong>简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心</strong></p>
<h3 id="接口interface">接口(interface)</h3>
<p>接口类型是一种抽象的类型，类型标记为interface，<strong>零值为nil，引用类型</strong></p>
<p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p>
<p>**依赖于接口而不是实现，优先使用组合而不是继承，这是程序抽象的基本原则。**但是长久以来以C++为代表的“面向对象”语言曲解了这些原则，让人们走入了误区。为什么要将方法和数据绑死？为什么要有多重继承这么变态的设计？面向对象中最强调的应该是对象间的消息传递，却为什么被演绎成了封装继承和多态。面向对象是否实现程序程序抽象的合理途径，又或者是因为它存在我们就认为它合理了。历史原因，中间出现了太多的错误。不管怎么样，Go的interface给我们打开了一扇新的窗。</p>
<blockquote>
<p>关于C++和面向对象的发展可以参考下孟岩的文章&ndash;<a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎</a></p>
</blockquote>
<p>interface实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。</p>
<blockquote>
<p>**注意：**空接口和带方法的接口底层结构略有不同，带方法的接口除了包含类型信息还需要包含具体类型中已实现的方法</p>
</blockquote>
<p>一个不包含任何值的nil接口和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。具体可参考官方文档，<a href="https://golang.google.cn/doc/faq#nil_error">国内链接</a> <a href="http://golang.org/doc/faq#nil_error">国外链接</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>  <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">Student</span>
	<span class="kd">var</span> <span class="nx">it</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="c1">// 此时it为nil.output: nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">it</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;non nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 赋值后it本身不为nil了,其类型字段指向了*Student,其值指向的是nil.output: non nil
</span><span class="c1"></span>	<span class="nx">it</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="k">if</span> <span class="nx">it</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;non nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 引用官方文档的例子，无论条件怎么变化始终会返回一个non-nil的error
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">returnsError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">MyError</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nf">bad</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">ErrBad</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span> <span class="c1">// Will always return a non-nil error.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>空的interface可以被当作任意类型来使用，它使得Go语言拥有了一定的动态性，但却又不损失静态语言在类型安全方面拥有的编译时检查的优势。</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL基于GTID复制</title>
			<link>https://shenbaise9527.com/posts/mysql%E5%9F%BA%E4%BA%8Egtid%E5%A4%8D%E5%88%B6/</link>
			<pubDate>Mon, 09 Nov 2020 21:27:12 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/mysql%E5%9F%BA%E4%BA%8Egtid%E5%A4%8D%E5%88%B6/</guid>
			<description>开启GTID. # 启用gtid模式,每个事务有个唯一的id,全局事务ID,事务提交时分配,基于gtid来复制. gtid_mode=ON # 开启gtid的一些安全限制.</description>
			<content type="html"><![CDATA[<h2 id="开启gtid">开启GTID.</h2>
<pre><code># 启用gtid模式,每个事务有个唯一的id,全局事务ID,事务提交时分配,基于gtid来复制.
gtid_mode=ON

# 开启gtid的一些安全限制.
enforce_gtid_consistency=ON

# gtid生成方式,默认为自动.
# gtid_next=AUTOMATIC

# 从库启动复制,master_auto_position=1表示开启基于GTID的复制.
CHANGE MASTER TO MASTER_HOST='xxx', MASTER_PORT=3306, MASTER_USER='user_name', MASTER_PASSWORD='password', MASTER_AUTO_POSITION=1;
start slave;
</code></pre><h2 id="并行复制参数">并行复制参数.</h2>
<pre><code># 并行复制类型,默认值为DATABASE,即按库来并行复制,LOGICAL_CLOCK为根据同时进入prepare和commit来并行复制.
slave_parallel_type=LOGICAL_CLOCK

# 并行复制线程数.
slave_parallel_workers=8

# 并行复制策略,默认值为COMMIT_ORDER,即按照上面的prepare和commit来并行;
# WRITESET对事务中的每一行计算hash,组合成writeset,如果两个事务没有更新相同行,writeset会没有交集可并行.
# WRITESET直接记录在binlog,不需要解析event,对binlog的格式没要求,5.7.22版本的新功能,binlog协议不向上兼容.
# WRITESET_SESSION,即在WRITESET基础上多了个约束,主库上同一线程先后执行的事务,在备库也要保证相同的顺序.
binlog_transaction_dependency_tracking=WRITESET
transaction_write_set_extraction=XXHASH64

# 记录writeset的容量,不需要修改,复制时可以并发的事务数大概为该值的一半.
#binlog_transaction_dependency_history_size=25000

# slave把从master接收到的binlog记录到自己的binlog中,主要用于级联复制的场景.
log_slave_updates=ON
</code></pre><h2 id="gtid的限制">GTID的限制.</h2>
<ol>
<li>从复制时报错,error: 1032
<code>select * from performance_schema.replication_applier_status_by_worker</code>可以查询从复制时的错误.
error: 1032,主删除数据,但从没有相应的记录.遇到错误主从复制会停止.</li>
</ol>
<p>解决方案是在从库上跳过主库的这个事务:</p>
<pre><code>-- 设置从库上的gtid_next为报错事务的gtid.
set gtid_next=&quot;af299bf7-dc7c-11ea-8417-0242ac170002:22805&quot;;
begin;
commit;
start slave;
</code></pre><ol start="2">
<li>create function报错,error: 1418
[Err] 1418 - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you might want to use the less safe log_bin_trust_function_creators variable)</li>
</ol>
<p>解决方案:</p>
<pre><code>DELIMITER ;;
CREATE FUNCTION `xxxx`(user_id INT) RETURNS varchar(4000) CHARSET utf8 COLLATE utf8_unicode_ci
-- 添加关键字DETERMINISTIC.
DETERMINISTIC
BEGIN
</code></pre><ol start="3">
<li>create table报错,error: 1786
[Err] 1786 - Statement violates GTID consistency: CREATE TABLE &hellip; SELECT.</li>
</ol>
<p>解决方案,需要拆分成两部分,create语句和insert语句:</p>
<pre><code>CREATE TABLE xxxx LIKE t;
INSERT INTO xxxx SELECT * FROM t;
</code></pre><ol start="4">
<li>create temporary报错,error: 1787
[Err] 1787 - Statement violates GTID consistency: CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can only be executed outside transactional context.  These statements are also not allowed in a function or trigger because functions and triggers are also considered to be multi-statement transactions.</li>
</ol>
<p>解决方案:
在<code>autocommit=1</code>的情况下可以创建临时表,主库创建临时表时不产生GTID信息,所以不会同步到从库,但在删除临时表时会产生GTID,从在处理时会报错,导致复制中断.</p>
<h2 id="查看gtid">查看GTID</h2>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 主库上执行,Executed_Gtid_Set表示已执行过的GTID集合.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">master</span> <span class="n">status</span><span class="err">\</span><span class="k">G</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
             <span class="n">File</span><span class="p">:</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000005</span>
         <span class="k">Position</span><span class="p">:</span> <span class="mi">194</span>
     <span class="n">Binlog_Do_DB</span><span class="p">:</span> 
 <span class="n">Binlog_Ignore_DB</span><span class="p">:</span> 
<span class="n">Executed_Gtid_Set</span><span class="p">:</span> <span class="n">af299bf7</span><span class="o">-</span><span class="n">dc7c</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8417</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac170002</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">22805</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- 在从库上执行,Executed_Gtid_Set表示从库已经执行过的GTID集合.
</span><span class="c1">-- Retrieved_Gtid_Set,从库会扫描最后一个relay log,显示当前扫描所得的GTID集合.
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">slave</span> <span class="n">status</span><span class="err">\</span><span class="k">G</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">Slave_IO_State</span><span class="p">:</span> <span class="n">Waiting</span> <span class="k">for</span> <span class="n">master</span> <span class="k">to</span> <span class="n">send</span> <span class="n">event</span>
                  <span class="n">Master_Host</span><span class="p">:</span> <span class="mi">192</span><span class="p">.</span><span class="mi">168</span><span class="p">.</span><span class="mi">20</span><span class="p">.</span><span class="mi">151</span>
                  <span class="n">Master_User</span><span class="p">:</span> <span class="n">mtp2</span>
                  <span class="n">Master_Port</span><span class="p">:</span> <span class="mi">3406</span>
                <span class="n">Connect_Retry</span><span class="p">:</span> <span class="mi">60</span>
              <span class="n">Master_Log_File</span><span class="p">:</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000005</span>
          <span class="n">Read_Master_Log_Pos</span><span class="p">:</span> <span class="mi">194</span>
               <span class="n">Relay_Log_File</span><span class="p">:</span> <span class="n">relay_log</span><span class="p">.</span><span class="mi">000007</span>
                <span class="n">Relay_Log_Pos</span><span class="p">:</span> <span class="mi">355</span>
        <span class="n">Relay_Master_Log_File</span><span class="p">:</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000005</span>
             <span class="n">Slave_IO_Running</span><span class="p">:</span> <span class="n">Yes</span>
            <span class="n">Slave_SQL_Running</span><span class="p">:</span> <span class="n">Yes</span>
              <span class="n">Replicate_Do_DB</span><span class="p">:</span> 
          <span class="n">Replicate_Ignore_DB</span><span class="p">:</span> 
           <span class="n">Replicate_Do_Table</span><span class="p">:</span> 
       <span class="n">Replicate_Ignore_Table</span><span class="p">:</span> 
      <span class="n">Replicate_Wild_Do_Table</span><span class="p">:</span> 
  <span class="n">Replicate_Wild_Ignore_Table</span><span class="p">:</span> 
                   <span class="n">Last_Errno</span><span class="p">:</span> <span class="mi">0</span>
                   <span class="n">Last_Error</span><span class="p">:</span> 
                 <span class="n">Skip_Counter</span><span class="p">:</span> <span class="mi">0</span>
          <span class="n">Exec_Master_Log_Pos</span><span class="p">:</span> <span class="mi">194</span>
              <span class="n">Relay_Log_Space</span><span class="p">:</span> <span class="mi">556</span>
              <span class="n">Until_Condition</span><span class="p">:</span> <span class="k">None</span>
               <span class="n">Until_Log_File</span><span class="p">:</span> 
                <span class="n">Until_Log_Pos</span><span class="p">:</span> <span class="mi">0</span>
           <span class="n">Master_SSL_Allowed</span><span class="p">:</span> <span class="k">No</span>
           <span class="n">Master_SSL_CA_File</span><span class="p">:</span> 
           <span class="n">Master_SSL_CA_Path</span><span class="p">:</span> 
              <span class="n">Master_SSL_Cert</span><span class="p">:</span> 
            <span class="n">Master_SSL_Cipher</span><span class="p">:</span> 
               <span class="n">Master_SSL_Key</span><span class="p">:</span> 
        <span class="n">Seconds_Behind_Master</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">Master_SSL_Verify_Server_Cert</span><span class="p">:</span> <span class="k">No</span>
                <span class="n">Last_IO_Errno</span><span class="p">:</span> <span class="mi">0</span>
                <span class="n">Last_IO_Error</span><span class="p">:</span> 
               <span class="n">Last_SQL_Errno</span><span class="p">:</span> <span class="mi">0</span>
               <span class="n">Last_SQL_Error</span><span class="p">:</span> 
  <span class="n">Replicate_Ignore_Server_Ids</span><span class="p">:</span> 
             <span class="n">Master_Server_Id</span><span class="p">:</span> <span class="mi">1</span>
                  <span class="n">Master_UUID</span><span class="p">:</span> <span class="n">af299bf7</span><span class="o">-</span><span class="n">dc7c</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8417</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac170002</span>
             <span class="n">Master_Info_File</span><span class="p">:</span> <span class="n">mysql</span><span class="p">.</span><span class="n">slave_master_info</span>
                    <span class="n">SQL_Delay</span><span class="p">:</span> <span class="mi">0</span>
          <span class="n">SQL_Remaining_Delay</span><span class="p">:</span> <span class="k">NULL</span>
      <span class="n">Slave_SQL_Running_State</span><span class="p">:</span> <span class="n">Slave</span> <span class="n">has</span> <span class="k">read</span> <span class="k">all</span> <span class="n">relay</span> <span class="n">log</span><span class="p">;</span> <span class="n">waiting</span> <span class="k">for</span> <span class="k">more</span> <span class="n">updates</span>
           <span class="n">Master_Retry_Count</span><span class="p">:</span> <span class="mi">86400</span>
                  <span class="n">Master_Bind</span><span class="p">:</span> 
      <span class="n">Last_IO_Error_Timestamp</span><span class="p">:</span> 
     <span class="n">Last_SQL_Error_Timestamp</span><span class="p">:</span> 
               <span class="n">Master_SSL_Crl</span><span class="p">:</span> 
           <span class="n">Master_SSL_Crlpath</span><span class="p">:</span> 
           <span class="n">Retrieved_Gtid_Set</span><span class="p">:</span> 
            <span class="n">Executed_Gtid_Set</span><span class="p">:</span> <span class="mi">60012</span><span class="n">ca6</span><span class="o">-</span><span class="n">dc7d</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8</span><span class="n">f34</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac180002</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>
<span class="n">af299bf7</span><span class="o">-</span><span class="n">dc7c</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8417</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac170002</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">22805</span>
                <span class="n">Auto_Position</span><span class="p">:</span> <span class="mi">1</span>
         <span class="n">Replicate_Rewrite_DB</span><span class="p">:</span> 
                 <span class="n">Channel_Name</span><span class="p">:</span> 
           <span class="n">Master_TLS_Version</span><span class="p">:</span> 
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- 查看binlog event.在语句前后都会设置GTID_NEXT
</span><span class="c1">-- SHOW BINLOG EVENTS [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count]
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="k">in</span> <span class="s1">&#39;bin.000003&#39;</span> <span class="k">limit</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
<span class="o">+</span><span class="c1">------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">Log_name</span>   <span class="o">|</span> <span class="n">Pos</span> <span class="o">|</span> <span class="n">Event_type</span>     <span class="o">|</span> <span class="n">Server_id</span> <span class="o">|</span> <span class="n">End_log_pos</span> <span class="o">|</span> <span class="n">Info</span>                                                              <span class="o">|</span>
<span class="o">+</span><span class="c1">------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
</span><span class="c1"></span><span class="o">|</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="o">|</span>   <span class="mi">4</span> <span class="o">|</span> <span class="n">Format_desc</span>    <span class="o">|</span>         <span class="mi">1</span> <span class="o">|</span>         <span class="mi">123</span> <span class="o">|</span> <span class="n">Server</span> <span class="n">ver</span><span class="p">:</span> <span class="mi">5</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">31</span><span class="o">-</span><span class="n">log</span><span class="p">,</span> <span class="n">Binlog</span> <span class="n">ver</span><span class="p">:</span> <span class="mi">4</span>                             <span class="o">|</span>
<span class="o">|</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="o">|</span> <span class="mi">123</span> <span class="o">|</span> <span class="n">Previous_gtids</span> <span class="o">|</span>         <span class="mi">1</span> <span class="o">|</span>         <span class="mi">194</span> <span class="o">|</span> <span class="n">af299bf7</span><span class="o">-</span><span class="n">dc7c</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8417</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac170002</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">5</span>                          <span class="o">|</span>
<span class="o">|</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="o">|</span> <span class="mi">194</span> <span class="o">|</span> <span class="n">Gtid</span>           <span class="o">|</span>         <span class="mi">1</span> <span class="o">|</span>         <span class="mi">259</span> <span class="o">|</span> <span class="k">SET</span> <span class="o">@@</span><span class="k">SESSION</span><span class="p">.</span><span class="n">GTID_NEXT</span><span class="o">=</span> <span class="s1">&#39;af299bf7-dc7c-11ea-8417-0242ac170002:6&#39;</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="o">|</span> <span class="mi">259</span> <span class="o">|</span> <span class="n">Query</span>          <span class="o">|</span>         <span class="mi">1</span> <span class="o">|</span>         <span class="mi">398</span> <span class="o">|</span> <span class="k">create</span> <span class="k">database</span> <span class="n">mtp2</span> <span class="k">default</span> <span class="n">charset</span> <span class="n">utf8</span> <span class="k">collate</span> <span class="n">utf8_unicode_ci</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="o">|</span> <span class="mi">398</span> <span class="o">|</span> <span class="n">Gtid</span>           <span class="o">|</span>         <span class="mi">1</span> <span class="o">|</span>         <span class="mi">463</span> <span class="o">|</span> <span class="k">SET</span> <span class="o">@@</span><span class="k">SESSION</span><span class="p">.</span><span class="n">GTID_NEXT</span><span class="o">=</span> <span class="s1">&#39;af299bf7-dc7c-11ea-8417-0242ac170002:7&#39;</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
</span><span class="c1"></span><span class="mi">5</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="c1">-- 解析binlog.
</span><span class="c1"></span><span class="n">root</span><span class="o">@</span><span class="n">baecf53ab2f8</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">log</span><span class="o">/</span><span class="n">mysql</span><span class="o">#</span> <span class="n">mysqlbinlog</span> <span class="o">-</span><span class="n">vv</span> <span class="n">bin</span><span class="p">.</span><span class="mi">000003</span> <span class="c1">--include-gtids=&#39;af299bf7-dc7c-11ea-8417-0242ac170002:6&#39;
</span><span class="c1"></span><span class="cm">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span><span class="p">;</span>
<span class="cm">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span><span class="p">;</span>
<span class="k">DELIMITER</span> <span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">4</span>
<span class="o">#</span><span class="mi">200812</span> <span class="mi">17</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">57</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">123</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x815f99b3</span> 	<span class="k">Start</span><span class="p">:</span> <span class="n">binlog</span> <span class="n">v</span> <span class="mi">4</span><span class="p">,</span> <span class="n">server</span> <span class="n">v</span> <span class="mi">5</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">31</span><span class="o">-</span><span class="n">log</span> <span class="n">created</span> <span class="mi">200812</span> <span class="mi">17</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">57</span> <span class="k">at</span> <span class="n">startup</span>
<span class="k">ROLLBACK</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="n">BINLOG</span> <span class="s1">&#39;
</span><span class="s1">xbMzXw8BAAAAdwAAAHsAAAAAAAQANS43LjMxLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</span><span class="s1">AAAAAAAAAAAAAAAAAADFszNfEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA
</span><span class="s1">AbOZX4E=
</span><span class="s1">&#39;</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">123</span>
<span class="o">#</span><span class="mi">200812</span> <span class="mi">17</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">57</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">194</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x5856cea2</span> 	<span class="n">Previous</span><span class="o">-</span><span class="n">GTIDs</span>
<span class="o">#</span> <span class="n">af299bf7</span><span class="o">-</span><span class="n">dc7c</span><span class="o">-</span><span class="mi">11</span><span class="n">ea</span><span class="o">-</span><span class="mi">8417</span><span class="o">-</span><span class="mi">0242</span><span class="n">ac170002</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">5</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">194</span>
<span class="o">#</span><span class="mi">200812</span> <span class="mi">17</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">17</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">259</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">xf56e199c</span> 	<span class="n">GTID</span>	<span class="n">last_committed</span><span class="o">=</span><span class="mi">0</span>	<span class="n">sequence_number</span><span class="o">=</span><span class="mi">1</span>	<span class="n">rbr_only</span><span class="o">=</span><span class="k">no</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">SESSION</span><span class="p">.</span><span class="n">GTID_NEXT</span><span class="o">=</span> <span class="s1">&#39;af299bf7-dc7c-11ea-8417-0242ac170002:6&#39;</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">259</span>
<span class="o">#</span><span class="mi">200812</span> <span class="mi">17</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">17</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">398</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x010ed0fb</span> 	<span class="n">Query</span>	<span class="n">thread_id</span><span class="o">=</span><span class="mi">2</span>	<span class="n">exec_time</span><span class="o">=</span><span class="mi">0</span>	<span class="n">error_code</span><span class="o">=</span><span class="mi">0</span>
<span class="k">SET</span> <span class="k">TIMESTAMP</span><span class="o">=</span><span class="mi">1597223957</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">pseudo_thread_id</span><span class="o">=</span><span class="mi">2</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">foreign_key_checks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">sql_auto_is_null</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">unique_checks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">autocommit</span><span class="o">=</span><span class="mi">1</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">sql_mode</span><span class="o">=</span><span class="mi">1436549152</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">auto_increment_increment</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">auto_increment_offset</span><span class="o">=</span><span class="mi">1</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="cm">/*!\C latin1 *//*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">character_set_client</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">collation_connection</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">collation_server</span><span class="o">=</span><span class="mi">192</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">lc_time_names</span><span class="o">=</span><span class="mi">0</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">collation_database</span><span class="o">=</span><span class="k">DEFAULT</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">create</span> <span class="k">database</span> <span class="n">mtp2</span> <span class="k">default</span> <span class="n">charset</span> <span class="n">utf8</span> <span class="k">collate</span> <span class="n">utf8_unicode_ci</span>
<span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">SET</span> <span class="o">@@</span><span class="k">SESSION</span><span class="p">.</span><span class="n">GTID_NEXT</span><span class="o">=</span> <span class="s1">&#39;AUTOMATIC&#39;</span> <span class="cm">/* added by mysqlbinlog */</span> <span class="cm">/*!*/</span><span class="p">;</span>
<span class="k">DELIMITER</span> <span class="p">;</span>
<span class="o">#</span> <span class="k">End</span> <span class="k">of</span> <span class="n">log</span> <span class="n">file</span>
<span class="cm">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span><span class="p">;</span>
<span class="cm">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span><span class="p">;</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>gRPC系列之连接异常机制</title>
			<link>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 07 Nov 2020 13:27:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</guid>
			<description>连接server端失败的处理 重试机制 // 重点关注addrConn.resetTransport方法. func (ac *addrConn) resetTransport() { // 代码逻辑放在一个死循环里的. for</description>
			<content type="html"><![CDATA[<h2 id="连接server端失败的处理">连接server端失败的处理</h2>
<h3 id="重试机制">重试机制</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 重点关注addrConn.resetTransport方法.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 代码逻辑放在一个死循环里的.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">resolveNow</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">ResolveNowOptions</span><span class="p">{})</span>
		<span class="p">}</span>

        <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="c1">// 当连接关闭时直接返回.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>

        <span class="nx">addrs</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">addrs</span>
        <span class="c1">// 获取backoff时间,根据重试的次数会计算出不同的时间,算法后面重点关注.
</span><span class="c1"></span>		<span class="nx">backoffFor</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span><span class="p">.</span><span class="nf">Backoff</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span><span class="p">)</span>
        <span class="c1">// This will be the duration that dial gets to finish.
</span><span class="c1"></span>        <span class="c1">// 超时时间,默认20秒.
</span><span class="c1"></span>		<span class="nx">dialDuration</span> <span class="o">:=</span> <span class="nx">minConnectTimeout</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">minConnectTimeout</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">dialDuration</span> <span class="p">=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">minConnectTimeout</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dialDuration</span> <span class="p">&lt;</span> <span class="nx">backoffFor</span> <span class="p">{</span>
			<span class="c1">// Give dial more time as we keep failing to connect.
</span><span class="c1"></span>			<span class="nx">dialDuration</span> <span class="p">=</span> <span class="nx">backoffFor</span>
		<span class="p">}</span>
		<span class="c1">// We can potentially spend all the time trying the first address, and
</span><span class="c1"></span>		<span class="c1">// if the server accepts the connection and then hangs, the following
</span><span class="c1"></span>		<span class="c1">// addresses will never be tried.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// The spec doesn&#39;t mention what should be done for multiple addresses.
</span><span class="c1"></span>		<span class="c1">// https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md#proposed-backoff-algorithm
</span><span class="c1"></span>		<span class="nx">connectDeadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">dialDuration</span><span class="p">)</span>

        <span class="c1">// 更新状态为连接中.
</span><span class="c1"></span>		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

        <span class="c1">// 尝试连接服务端.
</span><span class="c1"></span>		<span class="nx">newTr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">reconnect</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">tryAllAddrs</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">connectDeadline</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// After exhausting all addresses, the addrConn enters
</span><span class="c1"></span>			<span class="c1">// TRANSIENT_FAILURE.
</span><span class="c1"></span>            <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
            <span class="c1">// 如果失败了,且状态为Shutdown直接返回.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span>
            <span class="p">}</span>
            <span class="c1">// 标记状态为失败.
</span><span class="c1"></span>			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

			<span class="c1">// Backoff.
</span><span class="c1"></span>			<span class="nx">b</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">resetBackoff</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

            <span class="c1">// 根据backoff时间创建定时器.
</span><span class="c1"></span>			<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">backoffFor</span><span class="p">)</span>
			<span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="c1">// backoff时间到,增加backoff次数,继续循环去尝试连接.
</span><span class="c1"></span>				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span><span class="o">++</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">:</span>
                <span class="c1">// 外部重置了backoff,马上重新循环去尝试连接.
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="c1">// context取消了或超时了,直接返回.
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">newTr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">curAddr</span> <span class="p">=</span> <span class="nx">addr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="nx">newTr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span> <span class="p">=</span> <span class="mi">0</span>

		<span class="nx">hctx</span><span class="p">,</span> <span class="nx">hcancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">hctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Block until the created transport is down. And when this happens,
</span><span class="c1"></span>		<span class="c1">// we restart from the top of the addr list.
</span><span class="c1"></span>		<span class="o">&lt;-</span><span class="nx">reconnect</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">hcancel</span><span class="p">()</span>
		<span class="c1">// restart connecting - the top of the loop will set state to
</span><span class="c1"></span>		<span class="c1">// CONNECTING.  This is against the current connectivity semantics doc,
</span><span class="c1"></span>		<span class="c1">// however it allows for graceful behavior for RPCs not yet dispatched
</span><span class="c1"></span>		<span class="c1">// - unfortunate timing would otherwise lead to the RPC failing even
</span><span class="c1"></span>		<span class="c1">// though the TRANSIENT_FAILURE state (called for by the doc) would be
</span><span class="c1"></span>		<span class="c1">// instantaneous.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Ideally we should transition to Idle here and block until there is
</span><span class="c1"></span>		<span class="c1">// RPC activity that leads to the balancer requesting a reconnect of
</span><span class="c1"></span>		<span class="c1">// the associated SubConn.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>当连接失败后会等待一段时间之后再尝试重连,时间间隔的算法依赖于backoff.Strategy接口的Backoff方法.</li>
<li>利用context的超时控制或取消机制,直接结束.</li>
</ol>
<h3 id="backoff算法">Backoff算法</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在DialContext函数中,当没有设置bs自定义参数时,会默认设置为DefaultExponential.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span> <span class="p">=</span> <span class="nx">backoff</span><span class="p">.</span><span class="nx">DefaultExponential</span>
    <span class="p">}</span>
    
<span class="c1">// internal/backoffG/backoff.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DefaultExponential</span> <span class="p">=</span> <span class="nx">Exponential</span><span class="p">{</span><span class="nx">Config</span><span class="p">:</span> <span class="nx">grpcbackoff</span><span class="p">.</span><span class="nx">DefaultConfig</span><span class="p">}</span>

<span class="c1">// backoff/backoff.go
</span><span class="c1">// DefaultConfig is a backoff configuration with the default values specfied
</span><span class="c1">// at https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md.
</span><span class="c1">//
</span><span class="c1">// This should be useful for callers who want to configure backoff with
</span><span class="c1">// non-default values only for a subset of the options.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DefaultConfig</span> <span class="p">=</span> <span class="nx">Config</span><span class="p">{</span>
    <span class="c1">// 第一次失败之后的延迟时间.
</span><span class="c1"></span>    <span class="nx">BaseDelay</span><span class="p">:</span>  <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="c1">// 多次失败之后的时间乘数.
</span><span class="c1"></span>    <span class="nx">Multiplier</span><span class="p">:</span> <span class="mf">1.6</span><span class="p">,</span>
    <span class="c1">// 随机因子.
</span><span class="c1"></span>    <span class="nx">Jitter</span><span class="p">:</span>     <span class="mf">0.2</span><span class="p">,</span>
    <span class="c1">// 最大延迟时间.
</span><span class="c1"></span>	<span class="nx">MaxDelay</span><span class="p">:</span>   <span class="mi">120</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Backoff returns the amount of time to wait before the next retry given the
</span><span class="c1">// number of retries.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">bc</span> <span class="nx">Exponential</span><span class="p">)</span> <span class="nf">Backoff</span><span class="p">(</span><span class="nx">retries</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
    <span class="c1">// 当重试次数为0时直接返回BaseDelay,为1秒.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">retries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">BaseDelay</span>
	<span class="p">}</span>
	<span class="nx">backoff</span><span class="p">,</span> <span class="nx">max</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">BaseDelay</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">MaxDelay</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">backoff</span> <span class="p">&lt;</span> <span class="nx">max</span> <span class="o">&amp;&amp;</span> <span class="nx">retries</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 当backoff小于max且重试次数大于0时不断的乘以Multiplier.
</span><span class="c1"></span>		<span class="nx">backoff</span> <span class="o">*=</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Multiplier</span>
		<span class="nx">retries</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">backoff</span> <span class="p">=</span> <span class="nx">max</span>
    <span class="p">}</span>
    <span class="c1">// 对时间加上一个随机数.
</span><span class="c1"></span>	<span class="c1">// Randomize backoff delays so that if a cluster of requests start at
</span><span class="c1"></span>	<span class="c1">// the same time, they won&#39;t operate in lockstep.
</span><span class="c1"></span>	<span class="nx">backoff</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Jitter</span><span class="o">*</span><span class="p">(</span><span class="nx">grpcrand</span><span class="p">.</span><span class="nf">Float64</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">backoff</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>可以通过grpc.WithConnectParams和grpc.WithBackoff来设置自定义的backoff策略,在自定义策略里可以定义重试的时间间隔.</li>
<li>默认的backoff策略,第一次重试间隔为1秒,第二次为1*1.6+随机数&hellip;第N次为1*1.6^N +随机数(其中1*1.6^N最大不能超过120秒).</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之client和server的timetou机制</title>
			<link>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E5%92%8Cserver%E7%9A%84timetou%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 07 Nov 2020 13:22:04 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E5%92%8Cserver%E7%9A%84timetou%E6%9C%BA%E5%88%B6/</guid>
			<description>客户端超时的处理 客户端在调用rpc接口时带timeout的context是如何传递给服务端的. // 在调用对应的rpc方法时设置了超时时间为3秒</description>
			<content type="html"><![CDATA[<h2 id="客户端超时的处理">客户端超时的处理</h2>
<p>客户端在调用rpc接口时带timeout的context是如何传递给服务端的.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在调用对应的rpc方法时设置了超时时间为3秒.
</span><span class="c1"></span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
<span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;zhou&#34;</span><span class="p">})</span>

<span class="c1">// 调用SayHello方法最终会调用到invoke函数(call.go文件中).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 在newClientStream方法中会创建clientStream对象,ctx会赋值给该对象的ctx字段.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">ClientStream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">......</span>
    <span class="c1">// 前面代码都不关注,这里生成clientStream对象,关注其ctx字段.
</span><span class="c1"></span>	<span class="nx">cs</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">clientStream</span><span class="p">{</span>
		<span class="nx">callHdr</span><span class="p">:</span>      <span class="nx">callHdr</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>          <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">methodConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">mc</span><span class="p">,</span>
		<span class="nx">opts</span><span class="p">:</span>         <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">callInfo</span><span class="p">:</span>     <span class="nx">c</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">desc</span><span class="p">:</span>         <span class="nx">desc</span><span class="p">,</span>
		<span class="nx">codec</span><span class="p">:</span>        <span class="nx">c</span><span class="p">.</span><span class="nx">codec</span><span class="p">,</span>
		<span class="nx">cp</span><span class="p">:</span>           <span class="nx">cp</span><span class="p">,</span>
		<span class="nx">comp</span><span class="p">:</span>         <span class="nx">comp</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>       <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">beginTime</span><span class="p">:</span>    <span class="nx">beginTime</span><span class="p">,</span>
		<span class="nx">firstAttempt</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableRetry</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">retryThrottler</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="p">=</span> <span class="nx">binarylog</span><span class="p">.</span><span class="nf">GetMethodLogger</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span>

    <span class="c1">// 在newAttemptLocked中会通过负载均衡算法来选择Ready状态的连接.
</span><span class="c1"></span>	<span class="c1">// Only this initial attempt has stats/tracing.
</span><span class="c1"></span>	<span class="c1">// TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 在withRetry中最终会调用op函数,该函数会调用到csAttempt.newStream方法.
</span><span class="c1"></span>	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">newStream</span><span class="p">()</span> <span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">withRetry</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">bufferForRetryLocked</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="o">......</span>
    <span class="c1">// 下面的也不用关注了.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="nf">newStream</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">cs</span>
    <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span> <span class="p">=</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">numRetries</span>
    <span class="c1">// 这里会调用NewStream方法,t指向的是http2Client对象,cs是指向clientStream对象的.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">NewStream</span><span class="p">(</span><span class="nx">cs</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">PerformedIOError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Return without converting to an RPC error so retry code can
</span><span class="c1"></span>			<span class="c1">// inspect.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span><span class="p">.</span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">parser</span><span class="p">{</span><span class="nx">r</span><span class="p">:</span> <span class="nx">s</span><span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// NewStream creates a stream and registers it into the transport as &#34;active&#34;
</span><span class="c1">// streams.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Client</span><span class="p">)</span> <span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">callHdr</span> <span class="o">*</span><span class="nx">CallHdr</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">Stream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">peer</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getPeer</span><span class="p">())</span>
    <span class="c1">// 重点关注createHeaderFields,这个方法会处理HEADERS的数据,来传播表头数据.
</span><span class="c1"></span>    <span class="nx">headerFields</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">createHeaderFields</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">callHdr</span><span class="p">)</span>
    
    <span class="o">......</span>
    <span class="c1">// 下面的代码不关注.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Client</span><span class="p">)</span> <span class="nf">createHeaderFields</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">callHdr</span> <span class="o">*</span><span class="nx">CallHdr</span><span class="p">)</span> <span class="p">([]</span><span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 主要处理HEADERS头部数据.
</span><span class="c1"></span>    <span class="o">......</span>

    <span class="c1">// 支持的字段.
</span><span class="c1"></span>	<span class="nx">headerFields</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">hfLen</span><span class="p">)</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:method&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;POST&#34;</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:scheme&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">scheme</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:path&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">Method</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:authority&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">Host</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;content-type&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">ContentType</span><span class="p">(</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">ContentSubtype</span><span class="p">)})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;user-agent&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;te&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;trailers&#34;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-previous-rpc-attempts&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span><span class="p">)})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-encoding&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span><span class="p">})</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-accept-encoding&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span><span class="p">})</span>
    <span class="p">}</span>
    
    <span class="c1">// 重点在这里,获取ctx的deadline时间,然后放入头部中的grpc-timeout字段中,客户端就是利用这个来吧超时时间传递到服务端的.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dl</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Send out timeout regardless its value. The server can detect timeout context by itself.
</span><span class="c1"></span>		<span class="c1">// TODO(mmukhi): Perhaps this field should be updated when actually writing out to the wire.
</span><span class="c1"></span>		<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">dl</span><span class="p">)</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-timeout&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">EncodeDuration</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">authData</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">callAuthData</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">OutgoingTags</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-tags-bin&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeBinHeader</span><span class="p">(</span><span class="nx">b</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">OutgoingTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-trace-bin&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeBinHeader</span><span class="p">(</span><span class="nx">b</span><span class="p">)})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">added</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromOutgoingContextRaw</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">k</span> <span class="kt">string</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">md</span> <span class="p">{</span>
			<span class="c1">// HTTP doesn&#39;t allow you to set pseudoheaders after non pseudoheaders were set.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">added</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">k</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="c1">// HTTP doesn&#39;t allow you to set pseudoheaders after non pseudoheaders were set.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">md</span><span class="p">.(</span><span class="o">*</span><span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="nx">md</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">headerFields</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>在调用rpc接口时设置了超时的context,会最终传递到http2Client对象中,然后在处理HEADERS时会把deadline时间设置到头部参数<code>grpc-timeout</code>中,传递到服务端.</li>
<li>http2Client对象是在调用<code>Dial</code>或<code>DialContext</code>过程中生成的,每个Endpoint对应一个该对象.</li>
</ol>
<h2 id="服务端超时处理">服务端超时处理</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HandleStreams receives incoming streams using the given handler. This is
</span><span class="c1">// typically run in a separate goroutine.
</span><span class="c1">// traceCtx attaches trace to ctx and returns the new context.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">HandleStreams</span><span class="p">(</span><span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">readerDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 该函数主要接收客户端发送过来的数据,重点关注处理HEADERS部分的数据.
</span><span class="c1"></span>        <span class="o">......</span>

		<span class="k">switch</span> <span class="nx">frame</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">:</span>
            <span class="c1">// 当frame类型为HEADERS时的处理.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="nx">handle</span><span class="p">,</span> <span class="nx">traceCtx</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">break</span>
            <span class="p">}</span>
            
        <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// operateHeader takes action on the decoded headers.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">,</span> <span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">fatal</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">streamID</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nx">StreamID</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">decodeState</span><span class="p">{</span>
		<span class="nx">serverSide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// 获取HEADERS里的数据.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h2code</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">decodeHeader</span><span class="p">(</span><span class="nx">frame</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">FromError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">controlBuf</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cleanupStream</span><span class="p">{</span>
				<span class="nx">streamID</span><span class="p">:</span> <span class="nx">streamID</span><span class="p">,</span>
				<span class="nx">rst</span><span class="p">:</span>      <span class="kc">true</span><span class="p">,</span>
				<span class="nx">rstCode</span><span class="p">:</span>  <span class="nx">h2code</span><span class="p">,</span>
				<span class="nx">onWrite</span><span class="p">:</span>  <span class="kd">func</span><span class="p">()</span> <span class="p">{},</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">buf</span> <span class="o">:=</span> <span class="nf">newRecvBuffer</span><span class="p">()</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Stream</span><span class="p">{</span>
		<span class="nx">id</span><span class="p">:</span>             <span class="nx">streamID</span><span class="p">,</span>
		<span class="nx">st</span><span class="p">:</span>             <span class="nx">t</span><span class="p">,</span>
		<span class="nx">buf</span><span class="p">:</span>            <span class="nx">buf</span><span class="p">,</span>
		<span class="nx">fc</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">inFlow</span><span class="p">{</span><span class="nx">limit</span><span class="p">:</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">initialWindowSize</span><span class="p">)},</span>
		<span class="nx">recvCompress</span><span class="p">:</span>   <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span>
		<span class="nx">method</span><span class="p">:</span>         <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span>
		<span class="nx">contentSubtype</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">contentSubtype</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">StreamEnded</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// s is just created by the caller. No lock needed.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">streamReadDone</span>
    <span class="p">}</span>
    <span class="c1">// 当有设置超时时,Stream对象的ctx设置为Timeout的.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeoutSet</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">decodeState</span><span class="p">)</span> <span class="nf">decodeHeader</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">)</span> <span class="p">(</span><span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// frame.Truncated is set to true when framer detects that the current header
</span><span class="c1"></span>	<span class="c1">// list size hits MaxHeaderListSize limit.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Truncated</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCodeFrameSize</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Internal</span><span class="p">,</span> <span class="s">&#34;peer header list size exceeded limit&#34;</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 处理HEADERS.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">hf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Fields</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nf">processHeaderField</span><span class="p">(</span><span class="nx">hf</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>

	<span class="k">return</span> <span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCodeProtocol</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nf">constructHTTPErrMsg</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">decodeState</span><span class="p">)</span> <span class="nf">processHeaderField</span><span class="p">(</span><span class="nx">f</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Name</span> <span class="p">{</span>
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>

    <span class="k">case</span> <span class="s">&#34;grpc-timeout&#34;</span><span class="p">:</span>
        <span class="c1">// 如果有该字段,解析超时时间,在这里就和客户端联系起来了.
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeoutSet</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">decodeTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">grpcErr</span> <span class="p">=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Internal</span><span class="p">,</span> <span class="s">&#34;transport: malformed time-out: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 经过上述分析,带超时的context已经赋值给Stream的ctx字段了.
</span><span class="c1">// 最后这个ctx会被传递给RPC接口的第一个参数,这样在服务端的接口中就能感知到超时了.
</span></code></pre></div><p><strong>总结</strong></p>
<ol>
<li>服务端在收到HEADERS之后,会解析所有参数,如果有<code>grpc-timeout</code>,就会设置一个带timeout的context,然后传递到rpc接口中.</li>
</ol>
<h2 id="抓包">抓包</h2>
<p><img src="/images/grpc-timeout.png" alt="timeout" title="带timeout的HEADERS">
从图中可以看到HEADERS中有参数<code>grpc-timeout</code>,值为2994000u,超时时间为2994毫秒.</p>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之client端调用</title>
			<link>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E7%AB%AF%E8%B0%83%E7%94%A8/</link>
			<pubDate>Sat, 07 Nov 2020 13:16:47 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E7%AB%AF%E8%B0%83%E7%94%A8/</guid>
			<description>Dail/DailContext与服务端建立连接 // 直接调用的DialContext. // Dial creates a client connection to the given target. func Dial(target string, opts ...DialOption) (*ClientConn, error) { return DialContext(context.Background(), target, opts...) } // Dial</description>
			<content type="html"><![CDATA[<h2 id="daildailcontext与服务端建立连接">Dail/DailContext与服务端建立连接</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 直接调用的DialContext.
</span><span class="c1">// Dial creates a client connection to the given target.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Dial</span><span class="p">(</span><span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DialContext默认是非阻塞的,不会等待连接成功,而是在后台处理连接逻辑.可以用grpc.WithBlock()来设置为阻塞的.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 生成conn.
</span><span class="c1"></span>	<span class="nx">cc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClientConn</span><span class="p">{</span>
		<span class="nx">target</span><span class="p">:</span>            <span class="nx">target</span><span class="p">,</span>
		<span class="nx">csMgr</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">connectivityStateManager</span><span class="p">{},</span>
		<span class="nx">conns</span><span class="p">:</span>             <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">dopts</span><span class="p">:</span>             <span class="nf">defaultDialOptions</span><span class="p">(),</span>
		<span class="nx">blockingpicker</span><span class="p">:</span>    <span class="nf">newPickerWrapper</span><span class="p">(),</span>
		<span class="nx">czData</span><span class="p">:</span>            <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
		<span class="nx">firstResolveEvent</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>

    <span class="c1">// 处理DiaoOption,来设置自定义参数.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nx">opt</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 处理一元RPC的拦截器.
</span><span class="c1"></span>	<span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
    <span class="c1">// 处理流式RPC的拦截器.
</span><span class="c1"></span>	<span class="nf">chainStreamClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">cc</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">......</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">insecure</span> <span class="p">{</span>
        <span class="c1">// 校验认证相关.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errCredentialsConflict</span>
        <span class="p">}</span>
        <span class="c1">// PerRPCCredentials是指设置了自定义认证.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cd</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">PerRPCCredentials</span> <span class="p">{</span>
            <span class="c1">// 判断自定义认证是否依赖TLS.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">cd</span><span class="p">.</span><span class="nf">RequireTransportSecurity</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTransportCredentialsMissing</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="o">......</span>

    <span class="c1">// 超时控制.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">timeout</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">cancel</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span>
		<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span> <span class="o">==</span> <span class="nx">err</span><span class="p">:</span>
				<span class="nx">conn</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">case</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">returnLastError</span><span class="p">:</span>
				<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v: %v&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}()</span>

    <span class="o">......</span>

    <span class="c1">// 解析target的格式,识别出对应的Scheme和Endpoint.
</span><span class="c1"></span>	<span class="c1">// Determine the resolver to use.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">ParseTarget</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
	<span class="nx">unixScheme</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="s">&#34;unix:&#34;</span><span class="p">)</span>
    <span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;parsed scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
    
    <span class="c1">// 根据Scheme来获取对应的Resolver.
</span><span class="c1"></span>    <span class="c1">// 如gRPC默认支持的dns,就是在dns包的init函数中调用了resolver.Register()来注册dns Resolver.
</span><span class="c1"></span>	<span class="nx">resolverBuilder</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果获取失败,就采用默认的Resolver来解析,即passthrough.
</span><span class="c1"></span>		<span class="c1">// If resolver builder is still nil, the parsed target&#39;s scheme is
</span><span class="c1"></span>		<span class="c1">// not registered. Fallback to default resolver and set Endpoint to
</span><span class="c1"></span>		<span class="c1">// the original target.
</span><span class="c1"></span>		<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;scheme %q not registered, fallback to default scheme&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">{</span>
			<span class="nx">Scheme</span><span class="p">:</span>   <span class="nx">resolver</span><span class="p">.</span><span class="nf">GetDefaultScheme</span><span class="p">(),</span>
			<span class="nx">Endpoint</span><span class="p">:</span> <span class="nx">target</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">resolverBuilder</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;could not get resolver for default scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="o">......</span>
    <span class="c1">// 认证相关.
</span><span class="c1"></span>    <span class="c1">// banlancer的相关Option.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span> <span class="p">=</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DialCreds</span><span class="p">:</span>        <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>      <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
		<span class="nx">ChannelzParentID</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span>
		<span class="nx">Target</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span>
	<span class="p">}</span>

    <span class="c1">// 调用Resolver对象的Build方法,在Build内部会调用cc.UpdateState来更新服务端地址.
</span><span class="c1"></span>	<span class="c1">// Build the resolver.
</span><span class="c1"></span>	<span class="nx">rWrapper</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">resolverBuilder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to build resolver: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">resolverWrapper</span> <span class="p">=</span> <span class="nx">rWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="c1">// 当调用grpc.WithBlock()后会阻塞直到连接成功建立.
</span><span class="c1"></span>	<span class="c1">// A blocking dial blocks until the clientConn is ready.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">block</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
            <span class="c1">// 循环判断连接的状态是否为Ready.
</span><span class="c1"></span>			<span class="nx">s</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">GetState</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">FailOnNonTempDialError</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">connectionError</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">terr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">interface</span> <span class="p">{</span>
						<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span>
					<span class="p">})</span>
					<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">terr</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
						<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// ctx got timeout or canceled.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">connectionError</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">returnLastError</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">cc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// newCCResolverWrapper uses the resolver.Builder to build a Resolver and
</span><span class="c1">// returns a ccResolverWrapper object which wraps the newly built resolver.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">rb</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Builder</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ccr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccResolverWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>   <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">done</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">credsClone</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span>
	<span class="k">if</span> <span class="nx">creds</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">;</span> <span class="nx">creds</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">credsClone</span> <span class="p">=</span> <span class="nx">creds</span><span class="p">.</span><span class="nf">Clone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">rbo</span> <span class="o">:=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DisableServiceConfig</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span><span class="p">,</span>
		<span class="nx">DialCreds</span><span class="p">:</span>            <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>          <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>               <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// We need to hold the lock here while we assign to the ccr.resolver field
</span><span class="c1"></span>	<span class="c1">// to guard against a data race caused by the following code path,
</span><span class="c1"></span>	<span class="c1">// rb.Build--&gt;ccr.ReportError--&gt;ccr.poll--&gt;ccr.resolveNow, would end up
</span><span class="c1"></span>	<span class="c1">// accessing ccr.resolver which is being assigned here.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 主要是调用对应的Resolver的Build方法.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolver</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rb</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span> <span class="nx">ccr</span><span class="p">,</span> <span class="nx">rbo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ccr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 下面以gRPC默认的dns Resolver举例.
</span><span class="c1">// Build creates and starts a DNS resolver that watches the name resolution of the target.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">dnsBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">target</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">,</span> <span class="nx">cc</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Resolver</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseTarget</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">Endpoint</span><span class="p">,</span> <span class="nx">defaultPort</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 支持IP地址形式的target.
</span><span class="c1"></span>	<span class="c1">// IP address.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ipAddr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">formatIP</span><span class="p">(</span><span class="nx">host</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">addr</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{{</span><span class="nx">Addr</span><span class="p">:</span> <span class="nx">ipAddr</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="nx">port</span><span class="p">}}</span>
        <span class="c1">// 调用cc.UpdateState,cc实际上是ccResolverWrapper对象.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">Addresses</span><span class="p">:</span> <span class="nx">addr</span><span class="p">})</span>
		<span class="k">return</span> <span class="nx">deadResolver</span><span class="p">{},</span> <span class="kc">nil</span>
	<span class="p">}</span>

    <span class="c1">// 需要进行dns解析.
</span><span class="c1"></span>	<span class="c1">// DNS address (non-IP).
</span><span class="c1"></span>	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dnsResolver</span><span class="p">{</span>
		<span class="nx">host</span><span class="p">:</span>                 <span class="nx">host</span><span class="p">,</span>
		<span class="nx">port</span><span class="p">:</span>                 <span class="nx">port</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>                  <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>               <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>                   <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">rn</span><span class="p">:</span>                   <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">disableServiceConfig</span><span class="p">:</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">DisableServiceConfig</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Authority</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">resolver</span> <span class="p">=</span> <span class="nx">defaultResolver</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">resolver</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">customAuthorityResolver</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">Authority</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="nx">d</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 具体的解析过程在watcher中,解析成功后也会调用cc.UpdateState.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">watcher</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">ResolveNow</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">ResolveNowOptions</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有Resolver的Build方法都会来调用到UpdateState方法.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccr</span> <span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">)</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;ccResolverWrapper: sending update to cc: %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ccr</span><span class="p">.</span><span class="nf">addChannelzTraceEvent</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span> <span class="p">=</span> <span class="nx">s</span>
    <span class="c1">// 主要关注updateResolverState,ccr.cc是ClientConn对象.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nf">poll</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">firstResolveEvent</span><span class="p">.</span><span class="nf">Fire</span><span class="p">()</span>
    <span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

    <span class="o">......</span>

	<span class="kd">var</span> <span class="nx">ret</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 没有设置ServiceConfig,进入到该分支,主要处理balancer对象.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span>
		<span class="c1">// TODO: do we need to apply a failing LB policy if there is no
</span><span class="c1"></span>		<span class="c1">// default, per the error handling design?
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">......</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">balCfg</span> <span class="nx">serviceconfig</span><span class="p">.</span><span class="nx">LoadBalancingConfig</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">balCfg</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span><span class="p">.</span><span class="nx">cfg</span>
	<span class="p">}</span>

	<span class="nx">cbn</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span>
	<span class="nx">bw</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">cbn</span> <span class="o">!=</span> <span class="nx">grpclbName</span> <span class="p">{</span>
		<span class="c1">// Filter any grpclb addresses since we don&#39;t have the grpclb balancer.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">);</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">GRPCLB</span> <span class="p">{</span>
				<span class="nb">copy</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 主要处理连接的逻辑,在后面要重点关注.
</span><span class="c1"></span>	<span class="nx">uccsErr</span> <span class="o">:=</span> <span class="nx">bw</span><span class="p">.</span><span class="nf">updateClientConnState</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">{</span><span class="nx">ResolverState</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">BalancerConfig</span><span class="p">:</span> <span class="nx">balCfg</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">uccsErr</span> <span class="c1">// prefer ErrBadResolver state since any other error is
</span><span class="c1"></span>		<span class="c1">// currently meaningless to the caller.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 默认会走到该分支.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">emptyServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">ServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// should never reach here.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="p">=</span> <span class="nx">sc</span>

    <span class="o">......</span>

	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Only look at balancer types and switch balancer if balancer dial
</span><span class="c1"></span>		<span class="c1">// option is not set.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Balancer dial option was set, and this is the first time handling
</span><span class="c1"></span>        <span class="c1">// resolved addresses. Build a balancer with dopts.balancerBuilder.
</span><span class="c1"></span>        <span class="c1">// 调用grpc.WithBalancerName()设置了balancerBuiler,进入该分支.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="p">=</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Builder</span><span class="p">,</span> <span class="nx">bopts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span> <span class="p">{</span>
	<span class="nx">ccb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccBalancerWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>       <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">scBuffer</span><span class="p">:</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">NewUnbounded</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">subConns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
    <span class="p">}</span>
    <span class="c1">// watcher会持续观察连接的状态变更,重点关注.
</span><span class="c1"></span>    <span class="k">go</span> <span class="nx">ccb</span><span class="p">.</span><span class="nf">watcher</span><span class="p">()</span>
    <span class="c1">// 调用banlancer.Builder对象的Build方法来构建banlancer.
</span><span class="c1"></span>    <span class="c1">// 注意banlancer.Builder和base.PickerBuilder这两个接口.
</span><span class="c1"></span>    <span class="c1">// 自定义的负载均衡算法一般都是实现PickerBuilder或V2PickerBuilder接口,再通过base.NewBalancerBuilder包装成banlancer.Builder接口,实际对象是base.baseBuilder,这里Build返回的实际是base.baseBalancer对象(其实现了balancer.Balancer接口).
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">ccb</span><span class="p">,</span> <span class="nx">bopts</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ccb</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">bb</span> <span class="o">*</span><span class="nx">baseBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opt</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Balancer</span> <span class="p">{</span>
    <span class="c1">// 返回的是baseBalancer对象.
</span><span class="c1"></span>	<span class="nx">bal</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">baseBalancer</span><span class="p">{</span>
        <span class="c1">// 这里cc对象是ccBalancerWrapper.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">:</span>              <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">pickerBuilder</span><span class="p">:</span>   <span class="nx">bb</span><span class="p">.</span><span class="nx">pickerBuilder</span><span class="p">,</span>
		<span class="nx">v2PickerBuilder</span><span class="p">:</span> <span class="nx">bb</span><span class="p">.</span><span class="nx">v2PickerBuilder</span><span class="p">,</span>

		<span class="nx">subConns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">),</span>
		<span class="nx">scStates</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">]</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">),</span>
		<span class="nx">csEvltr</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ConnectivityStateEvaluator</span><span class="p">{},</span>
		<span class="nx">config</span><span class="p">:</span>   <span class="nx">bb</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c1">// Initialize picker to a picker that always returns
</span><span class="c1"></span>	<span class="c1">// ErrNoSubConnAvailable, because when state of a SubConn changes, we
</span><span class="c1"></span>	<span class="c1">// may call UpdateState with this picker.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">bb</span><span class="p">.</span><span class="nx">pickerBuilder</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 当前还没有与服务端建立连接,先设置一个返回error的Picker对象.
</span><span class="c1"></span>		<span class="nx">bal</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">bal</span><span class="p">.</span><span class="nx">v2Picker</span> <span class="p">=</span> <span class="nf">NewErrPickerV2</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">updateClientConnState</span><span class="p">(</span><span class="nx">ccs</span> <span class="o">*</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 调用了Balancer接口的方法,这里实际上是base.baseBalancer对象.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="o">*</span><span class="nx">ccs</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// TODO: handle s.ResolverState.ServiceConfig?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;base.baseBalancer: got new ClientConn state: &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Successful resolution; clear resolver error and ensure we return nil.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">resolverErr</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// addrsSet is the set converted from addrs, it&#39;s used for quick lookup of an address.
</span><span class="c1"></span>	<span class="nx">addrsSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">{</span>
		<span class="nx">addrsSet</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 创建连接,会调用到ccBalancerWrapper的NewSubConn方法,返回的实际上acBalancerWrapper对象.
</span><span class="c1"></span>			<span class="c1">// a is a new address (not existing in b.subConns).
</span><span class="c1"></span>			<span class="nx">sc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">NewSubConn</span><span class="p">([]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{</span><span class="nx">a</span><span class="p">},</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">NewSubConnOptions</span><span class="p">{</span><span class="nx">HealthCheckEnabled</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">HealthCheck</span><span class="p">})</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">logger</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;base.baseBalancer: failed to create new SubConn: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sc</span>
            <span class="c1">// 初始状态默认为空闲.
</span><span class="c1"></span>            <span class="nx">b</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span>
            <span class="c1">// 连接服务端.
</span><span class="c1"></span>			<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
		<span class="c1">// a was removed by resolver.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">addrsSet</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">RemoveSubConn</span><span class="p">(</span><span class="nx">sc</span><span class="p">)</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
			<span class="c1">// Keep the state of this sc in b.scStates until sc&#39;s state becomes Shutdown.
</span><span class="c1"></span>			<span class="c1">// The entry will be deleted in UpdateSubConnState.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// If resolver state contains no addresses, return an error so ClientConn
</span><span class="c1"></span>	<span class="c1">// will trigger re-resolve. Also records this as an resolver error, so when
</span><span class="c1"></span>	<span class="c1">// the overall state turns transient failure, the error message will have
</span><span class="c1"></span>	<span class="c1">// the zero address information.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">ResolverError</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;produced zero addresses&#34;</span><span class="p">))</span>
		<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrBadResolverState</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 建立连接.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">acbw</span> <span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">)</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">ac</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 最终会调用到这个connect方法.
</span><span class="c1">// connect starts creating a transport.
</span><span class="c1">// It does nothing if the ac is not IDLE.
</span><span class="c1">// TODO(bar) Move this to the addrConn section.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">connect</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">errConnClosing</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// Update connectivity state within the lock to prevent subsequent or
</span><span class="c1"></span>	<span class="c1">// concurrent calls from resetting the transport more than once.
</span><span class="c1"></span>	<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="c1">// 采用异步的方式来与服务端建立连接的.
</span><span class="c1"></span>    <span class="c1">// Start a goroutine connecting to the server asynchronously.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">resetTransport</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

        <span class="o">......</span>

        <span class="c1">// 尝试去建立连接.
</span><span class="c1"></span>		<span class="nx">newTr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">reconnect</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">tryAllAddrs</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">connectDeadline</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 错误处理.
</span><span class="c1"></span>            <span class="o">......</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">newTr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">curAddr</span> <span class="p">=</span> <span class="nx">addr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="nx">newTr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span> <span class="p">=</span> <span class="mi">0</span>

        <span class="nx">hctx</span><span class="p">,</span> <span class="nx">hcancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
        <span class="c1">// 重点关注startHealthCheck方法.
</span><span class="c1"></span>		<span class="nx">ac</span><span class="p">.</span><span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">hctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Block until the created transport is down. And when this happens,
</span><span class="c1"></span>		<span class="c1">// we restart from the top of the addr list.
</span><span class="c1"></span>		<span class="o">&lt;-</span><span class="nx">reconnect</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">hcancel</span><span class="p">()</span>
		<span class="c1">// restart connecting - the top of the loop will set state to
</span><span class="c1"></span>		<span class="c1">// CONNECTING.  This is against the current connectivity semantics doc,
</span><span class="c1"></span>		<span class="c1">// however it allows for graceful behavior for RPCs not yet dispatched
</span><span class="c1"></span>		<span class="c1">// - unfortunate timing would otherwise lead to the RPC failing even
</span><span class="c1"></span>		<span class="c1">// though the TRANSIENT_FAILURE state (called for by the doc) would be
</span><span class="c1"></span>		<span class="c1">// instantaneous.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Ideally we should transition to Idle here and block until there is
</span><span class="c1"></span>		<span class="c1">// RPC activity that leads to the balancer requesting a reconnect of
</span><span class="c1"></span>		<span class="c1">// the associated SubConn.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// startHealthCheck starts the health checking stream (RPC) to watch the health
</span><span class="c1">// stats of this connection if health checking is requested and configured.
</span><span class="c1">//
</span><span class="c1">// LB channel health checking is enabled when all requirements below are met:
</span><span class="c1">// 1. it is not disabled by the user with the WithDisableHealthCheck DialOption
</span><span class="c1">// 2. internal.HealthCheckFunc is set by importing the grpc/health package
</span><span class="c1">// 3. a service config with non-empty healthCheckConfig field is provided
</span><span class="c1">// 4. the load balancer requests it
</span><span class="c1">//
</span><span class="c1">// It sets addrConn to READY if the health checking stream is not started.
</span><span class="c1">//
</span><span class="c1">// Caller must hold ac.mu.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 整个函数的重点是调用ac.updateConnecttivityState来设置状态.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">healthcheckManagingState</span> <span class="kt">bool</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">healthcheckManagingState</span> <span class="p">{</span>
            <span class="c1">// 设置连接状态为Ready.
</span><span class="c1"></span>			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableHealthCheck</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 若没有设置healthCheckConfig直接返回.
</span><span class="c1"></span>	<span class="nx">healthCheckConfig</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">healthCheckConfig</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">healthCheckConfig</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ac</span><span class="p">.</span><span class="nx">scopts</span><span class="p">.</span><span class="nx">HealthCheckEnabled</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">healthCheckFunc</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">healthCheckFunc</span>
	<span class="k">if</span> <span class="nx">healthCheckFunc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// The health package is not imported to set health check function.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// TODO: add a link to the health check doc in the error message.
</span><span class="c1"></span>		<span class="nx">channelz</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Health check is requested but health check function is not set.&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">healthcheckManagingState</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Set up the health check helper functions.
</span><span class="c1"></span>	<span class="nx">currentTr</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span>
	<span class="nx">newStream</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="o">!=</span> <span class="nx">currentTr</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Canceled</span><span class="p">,</span> <span class="s">&#34;the provided transport is no longer valid to use&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nf">newNonRetryClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">StreamDesc</span><span class="p">{</span><span class="nx">ServerStreams</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">currentTr</span><span class="p">,</span> <span class="nx">ac</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// headlthCheckFunc最终会调用到下面的函数,来设置连接状态.
</span><span class="c1"></span>	<span class="nx">setConnectivityState</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">lastErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="o">!=</span> <span class="nx">currentTr</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">lastErr</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Start the health checking stream.
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// healthCheckFunc默认值是health.clientHealthCheck函数(health/client.go文件中).
</span><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">healthCheckFunc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">newStream</span><span class="p">,</span> <span class="nx">setConnectivityState</span><span class="p">,</span> <span class="nx">healthCheckConfig</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Code</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">==</span> <span class="nx">codes</span><span class="p">.</span><span class="nx">Unimplemented</span> <span class="p">{</span>
				<span class="nx">channelz</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Subchannel health check is unimplemented at server side, thus health check is disabled&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">channelz</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;HealthCheckFunc exits with unexpected error %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="c1">// Note: this requires a lock on ac.mu.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">lastErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Subchannel Connectivity change to %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">acbw</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">lastErr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// TODO(bar switching) send updates to all balancer wrappers when balancer
</span><span class="c1"></span>	<span class="c1">// gracefully switching is supported.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// When updating addresses for a SubConn, if the address in use is not in
</span><span class="c1"></span>	<span class="c1">// the new addresses, the old ac will be tearDown() and a new ac will be
</span><span class="c1"></span>	<span class="c1">// created. tearDown() generates a state change with Shutdown state, we
</span><span class="c1"></span>	<span class="c1">// don&#39;t want the balancer to receive this state change. So before
</span><span class="c1"></span>	<span class="c1">// tearDown() on the old ac, ac.acbw (acWrapper) will be set to nil, and
</span><span class="c1"></span>	<span class="c1">// this function will be called with (nil, Shutdown). We don&#39;t need to call
</span><span class="c1"></span>	<span class="c1">// balancer method in this case.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 最终会向scBuffer里写入连接的状态信息,还记得之前需要重点关注的ccBalancerWrapper对象的watcher方法么.
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scStateUpdate</span><span class="p">{</span>
		<span class="nx">sc</span><span class="p">:</span>    <span class="nx">sc</span><span class="p">,</span>
		<span class="nx">state</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span>
		<span class="nx">err</span><span class="p">:</span>   <span class="nx">err</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// watcher balancer functions sequentially, so the balancer can be implemented
</span><span class="c1">// lock-free.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">watcher</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Get</span><span class="p">():</span>
            <span class="c1">// 从scBuffer中获取数据.
</span><span class="c1"></span>			<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
            <span class="nx">su</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="o">*</span><span class="nx">scStateUpdate</span><span class="p">)</span>
            <span class="c1">// 调用Balancer接口的UpdateSubConnState来设置连接的状态,这里balancer对象是base.baseBalancer对象.
</span><span class="c1"></span>			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">su</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">ConnectionError</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">err</span><span class="p">})</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        <span class="p">}</span>

		<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">scs</span> <span class="o">:=</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">acbw</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scs</span> <span class="p">{</span>
				<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">removeAddrConn</span><span class="p">(</span><span class="nx">acbw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">(),</span> <span class="nx">errConnDrain</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="kc">nil</span><span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">ConnectivityState</span>

    <span class="o">......</span>

    <span class="c1">// 中间代码忽略,重点关注下面的.
</span><span class="c1"></span>	<span class="c1">// Regenerate picker when one of the following happens:
</span><span class="c1"></span>	<span class="c1">//  - this sc entered or left ready
</span><span class="c1"></span>	<span class="c1">//  - the aggregated state of balancer is TransientFailure
</span><span class="c1"></span>	<span class="c1">//    (may need to update error message)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nx">oldS</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span> <span class="o">||</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
        <span class="c1">// 获取Picker接口的对象.
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nf">regeneratePicker</span><span class="p">()</span>
	<span class="p">}</span>

    <span class="c1">// 这里cc对象是ccBalancerWrapper对象(实现了balancer.ClientConn接口).
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">picker</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// regeneratePicker takes a snapshot of the balancer, and generates a picker
</span><span class="c1">// from it. The picker is
</span><span class="c1">//  - errPicker if the balancer is in TransientFailure,
</span><span class="c1">//  - built by the pickerBuilder with all READY SubConns otherwise.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">regeneratePicker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">mergeErrors</span><span class="p">())</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 记录状态为Ready的连接.
</span><span class="c1"></span>	<span class="nx">readySCs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">]</span><span class="nx">SubConnInfo</span><span class="p">)</span>

	<span class="c1">// Filter out all ready SCs from full subConn map.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
			<span class="nx">readySCs</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">SubConnInfo</span><span class="p">{</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">addr</span><span class="p">}</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 调用PickerBuilder接口的Build方法来生成Picker接口,供后续负载均衡使用,一般自定义负载均衡算法是需要实现这两个接口的.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">pickerBuilder</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">PickerBuildInfo</span><span class="p">{</span><span class="nx">ReadySCs</span><span class="p">:</span> <span class="nx">readySCs</span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="c1">// 设置ClientConn的blockingpicker对象的picker字段.
</span><span class="c1"></span>	<span class="c1">// Update picker before updating state.  Even though the ordering here does
</span><span class="c1"></span>	<span class="c1">// not matter, it can lead to multiple calls of Pick in the common start-up
</span><span class="c1"></span>	<span class="c1">// case where we wait for ready and then perform an RPC.  If the picker is
</span><span class="c1"></span>	<span class="c1">// updated later, we could call the &#34;connecting&#34; picker when the state is
</span><span class="c1"></span>	<span class="c1">// updated, and then call the &#34;ready&#34; picker after the picker gets updated.
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">updatePicker</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Picker</span><span class="p">)</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ConnectivityState</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="调用rpc接口">调用RPC接口</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">helloServiceClient</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloReply</span><span class="p">)</span>
    <span class="c1">// 这里cc是ClientConn对象,调用其Invoke方法,定义在call.go文件里.
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Invoke sends the RPC request on the wire and returns after response is
</span><span class="c1">// received.  This is typically called by generated code.
</span><span class="c1">//
</span><span class="c1">// All errors returned by Invoke are compatible with the status package.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// allow interceptor to see all applicable call options, which means those
</span><span class="c1"></span>	<span class="c1">// configured as defaults from dial option as well as per-call options
</span><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">callOptions</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果有设置客户端拦截器,最终也会调用到invoke函数.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">unaryInt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">invoke</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 没有就直接调用invoke函数.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 该函数内部会使用负载均衡算法,来选出一个连接.
</span><span class="c1"></span>	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">ClientStream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 前面代码可以不关注.
</span><span class="c1"></span>    <span class="o">......</span>

	<span class="nx">cs</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">clientStream</span><span class="p">{</span>
		<span class="nx">callHdr</span><span class="p">:</span>      <span class="nx">callHdr</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>          <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">methodConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">mc</span><span class="p">,</span>
		<span class="nx">opts</span><span class="p">:</span>         <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">callInfo</span><span class="p">:</span>     <span class="nx">c</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">desc</span><span class="p">:</span>         <span class="nx">desc</span><span class="p">,</span>
		<span class="nx">codec</span><span class="p">:</span>        <span class="nx">c</span><span class="p">.</span><span class="nx">codec</span><span class="p">,</span>
		<span class="nx">cp</span><span class="p">:</span>           <span class="nx">cp</span><span class="p">,</span>
		<span class="nx">comp</span><span class="p">:</span>         <span class="nx">comp</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>       <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">beginTime</span><span class="p">:</span>    <span class="nx">beginTime</span><span class="p">,</span>
		<span class="nx">firstAttempt</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableRetry</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">retryThrottler</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="p">=</span> <span class="nx">binarylog</span><span class="p">.</span><span class="nf">GetMethodLogger</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span>

    <span class="c1">// 重点关注newAttempLocked.
</span><span class="c1"></span>	<span class="c1">// Only this initial attempt has stats/tracing.
</span><span class="c1"></span>	<span class="c1">// TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">newStream</span><span class="p">()</span> <span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">withRetry</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">bufferForRetryLocked</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">md</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromOutgoingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="nx">logEntry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">binarylog</span><span class="p">.</span><span class="nx">ClientHeader</span><span class="p">{</span>
			<span class="nx">OnClientSide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
			<span class="nx">Header</span><span class="p">:</span>       <span class="nx">md</span><span class="p">,</span>
			<span class="nx">MethodName</span><span class="p">:</span>   <span class="nx">method</span><span class="p">,</span>
			<span class="nx">Authority</span><span class="p">:</span>    <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">deadline</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nx">logEntry</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">desc</span> <span class="o">!=</span> <span class="nx">unaryStreamDesc</span> <span class="p">{</span>
		<span class="c1">// Listen on cc and stream contexts to cleanup when the user closes the
</span><span class="c1"></span>		<span class="c1">// ClientConn or cancels the stream context.  In all other cases, an error
</span><span class="c1"></span>		<span class="c1">// should already be injected into the recv buffer by the transport, which
</span><span class="c1"></span>		<span class="c1">// the client will eventually receive, and then we will cancel the stream&#39;s
</span><span class="c1"></span>		<span class="c1">// context in clientStream.finish.
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">ErrClientConnClosing</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()))</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// newAttemptLocked creates a new attempt with a transport.
</span><span class="c1">// If it succeeds, then it replaces clientStream&#39;s attempt with this new attempt.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">clientStream</span><span class="p">)</span> <span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">Handler</span><span class="p">,</span> <span class="nx">trInfo</span> <span class="o">*</span><span class="nx">traceInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">retErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newAttempt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">csAttempt</span><span class="p">{</span>
		<span class="nx">cs</span><span class="p">:</span>           <span class="nx">cs</span><span class="p">,</span>
		<span class="nx">dc</span><span class="p">:</span>           <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span>
		<span class="nx">statsHandler</span><span class="p">:</span> <span class="nx">sh</span><span class="p">,</span>
		<span class="nx">trInfo</span><span class="p">:</span>       <span class="nx">trInfo</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="o">......</span>

    <span class="c1">// 重点关注getTransport.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">getTransport</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callInfo</span><span class="p">.</span><span class="nx">failFast</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trInfo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">trInfo</span><span class="p">.</span><span class="nx">firstLine</span><span class="p">.</span><span class="nf">SetRemoteAddr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">newAttempt</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">newAttempt</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nx">done</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span> <span class="p">=</span> <span class="nx">newAttempt</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">getTransport</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">failfast</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ClientTransport</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 调用pick方法来负载均衡.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">pick</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">failfast</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">{</span>
		<span class="nx">Ctx</span><span class="p">:</span>            <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">FullMethodName</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// pick returns the transport that will be used for the RPC.
</span><span class="c1">// It may block in the following cases:
</span><span class="c1">// - there&#39;s no picker
</span><span class="c1">// - the current picker returns ErrNoSubConnAvailable
</span><span class="c1">// - the current picker returns other errors and failfast is false.
</span><span class="c1">// - the subConn returned by the current picker is not READY
</span><span class="c1">// When one of these situations happens, pick blocks until the picker gets updated.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pw</span> <span class="o">*</span><span class="nx">pickerWrapper</span><span class="p">)</span> <span class="nf">pick</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">failfast</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ClientTransport</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="kd">var</span> <span class="nx">lastPickErr</span> <span class="kt">error</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">done</span> <span class="p">{</span>
			<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrClientConnClosing</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">picker</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="p">=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ch</span> <span class="o">==</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span> <span class="p">{</span>

            <span class="o">......</span>

			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ch</span> <span class="p">=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">picker</span>
		<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

        <span class="c1">// 调用Pick方法负载均衡,可以是自定义负载均衡算法,gRPC默认的是轮询.
</span><span class="c1"></span>		<span class="nx">pickResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Pick</span><span class="p">(</span><span class="nx">info</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 返回错误时的处理.
</span><span class="c1"></span>            <span class="o">......</span>
		<span class="p">}</span>

        <span class="c1">// 把conn显示的转化为acBalancerWrapper.
</span><span class="c1"></span>		<span class="nx">acw</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">.(</span><span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;subconn returned from pick is not *acBalancerWrapper&#34;</span><span class="p">)</span>
			<span class="k">continue</span>
        <span class="p">}</span>
        
        <span class="c1">// 调用getReadyTransport,来判断状态是否为Ready,若为Idle则发起connect.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">acw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">().</span><span class="nf">getReadyTransport</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nf">doneChannelzWrapper</span><span class="p">(</span><span class="nx">acw</span><span class="p">,</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span><span class="p">),</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 状态不为Ready,则返回重新进行pick.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Calling done with nil error, no bytes sent and no bytes received.
</span><span class="c1"></span>			<span class="c1">// DoneInfo with default value works.
</span><span class="c1"></span>			<span class="nx">pickResult</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;blockingPicker: the picked transport is not ready, loop back to repick&#34;</span><span class="p">)</span>
		<span class="c1">// If ok == false, ac.state is not READY.
</span><span class="c1"></span>		<span class="c1">// A valid picker always returns READY subConn. This means the state of ac
</span><span class="c1"></span>		<span class="c1">// just changed, and picker will be updated shortly.
</span><span class="c1"></span>		<span class="c1">// continue back to the beginning of the for loop to repick.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<ul>
<li>要实现自定义Resolver,需要实现resolver.Builder接口和resolver.Resolver接口.在init函数中调用resolver.Register来注册自定义的Builder对象.在Builder接口的Build方法中要调用UpdateState来更新服务端地址信息.客户端在解析target时会根据scheme来获取对应的Resolver对象.</li>
<li>要实现自定义负载均衡算法,需要实现base.PickerBuilder接口和balancer.Picker接口(注意这两个接口有V2版的),通过base.NewBalancerBuilder包装成balancer.Builder接口,再在init函数中调用balancer.Register来注册该Builder对象.最后grpc.WithBalancerName把Builder包装成grpc.DialOption.</li>
<li>要实现自定义认证,需要实现credentials.PerRPCCredentials接口,然后调用grpc.WithPerRPCCredentials把对象包装成grpc.DialOption.</li>
<li>在客户端调用<code>Dial</code>或<code>DialContext</code>过程中,会先通过Resolver来解析出所有的Endpoint,然后会与每一个Endpoint建立连接(采用异步的方式),同时也会设置好对应的负载均衡Picker对象.注意如果使用了grpc.WithBlock()会同步等待连接建立成功(有一个成功就可以了),否则就会直接返回.</li>
<li>负载均衡算法会在调用具体的RPC函数过程中使用到,在invoke函数(call.go文件中)中会根据负载均衡算法来选定一个连接,然后发起请求.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之server端调用</title>
			<link>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bserver%E7%AB%AF%E8%B0%83%E7%94%A8/</link>
			<pubDate>Sat, 07 Nov 2020 11:47:48 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bserver%E7%AB%AF%E8%B0%83%E7%94%A8/</guid>
			<description>NewServer创建gRPC服务对象 主要是基于grpc-go的1.33.1版本Unary RPC来分析. // NewServer creates a gRPC server which has no service registered and has not // started to accept</description>
			<content type="html"><![CDATA[<h2 id="newserver创建grpc服务对象">NewServer创建gRPC服务对象</h2>
<p>主要是基于grpc-go的1.33.1版本Unary RPC来分析.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewServer creates a gRPC server which has no service registered and has not
</span><span class="c1">// started to accept requests yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewServer</span><span class="p">(</span><span class="nx">opt</span> <span class="o">...</span><span class="nx">ServerOption</span><span class="p">)</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
    <span class="c1">// 处理Server对象的一些定制化参数.在Go中推荐采用Option的方式从外部来影响对象内的行为.
</span><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="nx">defaultServerOptions</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opt</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">opts</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 生成Server对象.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span>
        <span class="nx">lis</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
        <span class="nx">opts</span><span class="p">:</span>     <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">conns</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
		<span class="nx">services</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">serviceInfo</span><span class="p">),</span>
		<span class="nx">quit</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">czData</span><span class="p">:</span>   <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
    <span class="p">}</span>
    
    <span class="c1">// 处理一元服务端拦截器,支持链式多拦截器.
</span><span class="c1"></span>    <span class="nf">chainUnaryServerInterceptors</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    
    <span class="c1">// 处理流式服务端拦截器,支持链式多拦截器.
</span><span class="c1"></span>	<span class="nf">chainStreamServerInterceptors</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">cv</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">EnableTracing</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">events</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">NewEventLog</span><span class="p">(</span><span class="s">&#34;grpc.Server&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s:%d&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">))</span>
	<span class="p">}</span>

    <span class="c1">// 用来控制处理连接的goroutine的数量,为0时表示不控制.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">initServerWorkers</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">channelzID</span> <span class="p">=</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">RegisterServer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">channelzServer</span><span class="p">{</span><span class="nx">s</span><span class="p">},</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h2 id="serveroption自定义参数">ServerOption自定义参数</h2>
<p><strong>Creds</strong>
主要用来设置服务端认证相关的参数.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用来设置TLS.
</span><span class="c1">// Creds returns a ServerOption that sets credentials for server connections.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Creds</span><span class="p">(</span><span class="nx">c</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">creds</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// gRPC中的credentials包,已定义相关的TransportCredentials.
</span><span class="c1">// NewServerTLSFromFile constructs TLS credentials from the input certificate file and key
</span><span class="c1">// file for server.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewServerTLSFromFile</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">TransportCredentials</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cert</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tls</span><span class="p">.</span><span class="nf">LoadX509KeyPair</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">NewTLS</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Certificates</span><span class="p">:</span> <span class="p">[]</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Certificate</span><span class="p">{</span><span class="nx">cert</span><span class="p">}}),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><strong>UnaryInterceptor</strong>
主要用来设置服务端的拦截器.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// UnaryInterceptor returns a ServerOption that sets the UnaryServerInterceptor for the
</span><span class="c1">// server. Only one unary interceptor can be installed. The construction of multiple
</span><span class="c1">// interceptors (e.g., chaining) can be implemented at the caller.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">UnaryInterceptor</span><span class="p">(</span><span class="nx">i</span> <span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;The unary server interceptor was already set and may not be reset.&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 具体的自定义拦截器需要实现UnaryServerInterceptor函数原型.
</span><span class="c1">// UnaryServerInterceptor provides a hook to intercept the execution of a unary RPC on the server. info
</span><span class="c1">// contains all the information of this RPC the interceptor can operate on. And handler is the wrapper
</span><span class="c1">// of the service method implementation. It is the responsibility of the interceptor to invoke handler
</span><span class="c1">// to complete the RPC.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnaryServerInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p><strong>ChainUnaryInterceptor</strong>
主要用来设置服务端的链式拦截器.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 支持同时设置多个拦截器.
</span><span class="c1">// ChainUnaryInterceptor returns a ServerOption that specifies the chained interceptor
</span><span class="c1">// for unary RPCs. The first interceptor will be the outer most,
</span><span class="c1">// while the last interceptor will be the inner most wrapper around the real call.
</span><span class="c1">// All unary interceptors added by this method will be chained.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ChainUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptors</span> <span class="o">...</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span><span class="p">,</span> <span class="nx">interceptors</span><span class="o">...</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h2 id="注册rpc对象到server中">注册RPC对象到Server中</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 注册HelloServiceServer对象到gRPC对象中.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">HelloServiceServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_HelloService_serviceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// _HelloService_serviceDesc主要用来描述RPC对象的信息.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_HelloService_serviceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;HelloService&#34;</span><span class="p">,</span>
	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloServiceServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>
		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;SayHello&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_HelloService_SayHello_Handler</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>
	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;hello.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 注册RPC服务对象.
</span><span class="c1">// RegisterService registers a service and its implementation to the gRPC
</span><span class="c1">// server. It is called from the IDL generated code. This must be called before
</span><span class="c1">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to
</span><span class="c1">// ensure it implements sd.HandlerType.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">RegisterService</span><span class="p">(</span><span class="nx">sd</span> <span class="o">*</span><span class="nx">ServiceDesc</span><span class="p">,</span> <span class="nx">ss</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// 主要用来判断接口类型是否一致.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ss</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ht</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">sd</span><span class="p">.</span><span class="nx">HandlerType</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
		<span class="nx">st</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">ss</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">ht</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&#34;</span><span class="p">,</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ht</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="nx">sd</span><span class="p">,</span> <span class="nx">ss</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">register</span><span class="p">(</span><span class="nx">sd</span> <span class="o">*</span><span class="nx">ServiceDesc</span><span class="p">,</span> <span class="nx">ss</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;RegisterService(%q)&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serve</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService after Server.Serve for %q&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 判断服务名是否已经注册过了.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService found duplicate service registration for %q&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 创建serviceInfo对象.
</span><span class="c1"></span>	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">serviceInfo</span><span class="p">{</span>
        <span class="c1">// 接口的实现对象.
</span><span class="c1"></span>        <span class="nx">serviceImpl</span><span class="p">:</span> <span class="nx">ss</span><span class="p">,</span>
        
        <span class="c1">// 具体的方法描述信息.
</span><span class="c1"></span>		<span class="nx">methods</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">MethodDesc</span><span class="p">),</span>
        <span class="nx">streams</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">StreamDesc</span><span class="p">),</span>
        
        <span class="c1">// 元数据.
</span><span class="c1"></span>		<span class="nx">mdata</span><span class="p">:</span>       <span class="nx">sd</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1">// 保存具体的方法.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">info</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">MethodName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Streams</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sd</span><span class="p">.</span><span class="nx">Streams</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">info</span><span class="p">.</span><span class="nx">streams</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">StreamName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">info</span>
<span class="p">}</span>
</code></pre></div><h2 id="server启动监听等待连接">Server启动监听等待连接</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Serve accepts incoming connections on the listener lis, creating a new
</span><span class="c1">// ServerTransport and service goroutine for each. The service goroutines
</span><span class="c1">// read gRPC requests and then call the registered handlers to reply to them.
</span><span class="c1">// Serve returns when lis.Accept fails with fatal errors.  lis will be closed when
</span><span class="c1">// this method returns.
</span><span class="c1">// Serve will return a non-nil error unless Stop or GracefulStop is called.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

    <span class="o">......</span>

	<span class="nx">ls</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">listenSocket</span><span class="p">{</span><span class="nx">Listener</span><span class="p">:</span> <span class="nx">lis</span><span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">[</span><span class="nx">ls</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

    <span class="o">......</span>

	<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lis</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">[</span><span class="nx">ls</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">ls</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">,</span> <span class="nx">ls</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="kd">var</span> <span class="nx">tempDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// how long to sleep on accept failure
</span><span class="c1"></span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 等待连接.
</span><span class="c1"></span>		<span class="nx">rawConn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 当返回错误时,会尝试重新调用Accept,时间间隔从5毫秒开始,每重试一次时间翻倍,直到1秒.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ne</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">interface</span> <span class="p">{</span>
				<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span>
			<span class="p">});</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ne</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 计算时间间隔的逻辑.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">tempDelay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="o">*=</span> <span class="mi">2</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">max</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">;</span> <span class="nx">tempDelay</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="nx">max</span>
				<span class="p">}</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Accept error: %v; retrying in %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">tempDelay</span><span class="p">)</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">tempDelay</span><span class="p">)</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
					<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;done serving; Accept = %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        
        <span class="c1">// Accept正常后,重置时间为0.
</span><span class="c1"></span>		<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// Start a new goroutine to deal with rawConn so we don&#39;t stall this Accept
</span><span class="c1"></span>		<span class="c1">// loop goroutine.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Make sure we account for the goroutine so GracefulStop doesn&#39;t nil out
</span><span class="c1"></span>        <span class="c1">// s.conns before this conn can be added.
</span><span class="c1"></span>        <span class="c1">// 主要是为了优雅的关闭,在关闭前所有的连接必须被处理完了.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// 启动一个新的goroutine来处理新的连接.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="业务处理逻辑">业务处理逻辑</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// handleRawConn forks a goroutine to handle a just-accepted connection that
</span><span class="c1">// has not had any I/O performed on it yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">rawConn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rawConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="c1">// 设置超时时间,默认是120秒.
</span><span class="c1"></span>    <span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">connectionTimeout</span><span class="p">))</span>
    
    <span class="c1">// 处理TLS认证.
</span><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">authInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">useTransportAuthenticator</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// ErrConnDispatched means that the connection was dispatched away from
</span><span class="c1"></span>		<span class="c1">// gRPC; those connections should be left open.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">ErrConnDispatched</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">errorf</span><span class="p">(</span><span class="s">&#34;ServerHandshake(%q) failed: %v&#34;</span><span class="p">,</span> <span class="nx">rawConn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">channelz</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;grpc: Server.Serve failed to complete security handshake from %q: %v&#34;</span><span class="p">,</span> <span class="nx">rawConn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">rawConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
		<span class="k">return</span>
	<span class="p">}</span>

    <span class="c1">// 开启HTTP/2协议.
</span><span class="c1"></span>	<span class="c1">// Finish handshaking (HTTP2)
</span><span class="c1"></span>	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newHTTP2Transport</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">authInfo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nf">addConn</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 开启新的goroutine来处理业务数据.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">removeConn</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

    <span class="kd">var</span> <span class="nx">roundRobinCounter</span> <span class="kt">uint32</span>
    <span class="c1">// HandleStreams主要是接收数据,并生成Stream对象,在调用下面的匿名函数来处理具体的业务逻辑.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">HandleStreams</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// 判断是否有设置numServerWorkers.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">data</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">serverWorkerData</span><span class="p">{</span><span class="nx">st</span><span class="p">:</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">wg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">stream</span><span class="p">:</span> <span class="nx">stream</span><span class="p">}</span>
			<span class="k">select</span> <span class="p">{</span>
            <span class="c1">// 发送数据到指定的channel中.
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serverWorkerChannels</span><span class="p">[</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">roundRobinCounter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">data</span><span class="p">:</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="c1">// If all stream workers are busy, fallback to the default code path.
</span><span class="c1"></span>				<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                    <span class="c1">// 若所有workerchannel都在忙,则单独创建goroutine.
</span><span class="c1"></span>					<span class="nx">s</span><span class="p">.</span><span class="nf">handleStream</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">traceInfo</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">))</span>
					<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="p">}()</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 没有限制worker大小,则单独创建goroutine.
</span><span class="c1"></span>				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">handleStream</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">traceInfo</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">))</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">EnableTracing</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">ctx</span>
		<span class="p">}</span>
		<span class="nx">tr</span> <span class="o">:=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;grpc.Recv.&#34;</span><span class="o">+</span><span class="nf">methodFamily</span><span class="p">(</span><span class="nx">method</span><span class="p">),</span> <span class="nx">method</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">tr</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// HandleStreams receives incoming streams using the given handler. This is
</span><span class="c1">// typically run in a separate goroutine.
</span><span class="c1">// traceCtx attaches trace to ctx and returns the new context.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">HandleStreams</span><span class="p">(</span><span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">readerDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">controlBuf</span><span class="p">.</span><span class="nf">throttle</span><span class="p">()</span>
        <span class="c1">// 读取HTTP/2协议中的frame数据.
</span><span class="c1"></span>		<span class="nx">frame</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">framer</span><span class="p">.</span><span class="nx">fr</span><span class="p">.</span><span class="nf">ReadFrame</span><span class="p">()</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">lastRead</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 错误相关.
</span><span class="c1"></span>            <span class="o">......</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// 针对不同类型的frame的处理,可以和之前的抓包对应起来.
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">frame</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="nx">handle</span><span class="p">,</span> <span class="nx">traceCtx</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">DataFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleData</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">RSTStreamFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleRSTStream</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">SettingsFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleSettings</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">PingFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handlePing</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">WindowUpdateFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleWindowUpdate</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">GoAwayFrame</span><span class="p">:</span>
			<span class="c1">// TODO: Handle GoAway from the client appropriately.
</span><span class="c1"></span>		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="nx">logLevel</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">logger</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;transport: http2Server.HandleStreams found unhandled frame type %v.&#34;</span><span class="p">,</span> <span class="nx">frame</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleStream</span><span class="p">(</span><span class="nx">t</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">,</span> <span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">,</span> <span class="nx">trInfo</span> <span class="o">*</span><span class="nx">traceInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 解析方法名,如/HelloService/SayHello.
</span><span class="c1"></span>	<span class="nx">sm</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Method</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sm</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">sm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">sm</span> <span class="p">=</span> <span class="nx">sm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="p">}</span>
	<span class="nx">pos</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">LastIndex</span><span class="p">(</span><span class="nx">sm</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// 错误处理.
</span><span class="c1"></span>        <span class="o">......</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// service服务名等于HelloService.
</span><span class="c1"></span>    <span class="nx">service</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">[:</span><span class="nx">pos</span><span class="p">]</span>
    <span class="c1">// 方法名等于SyaHello.
</span><span class="c1"></span>	<span class="nx">method</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">[</span><span class="nx">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">// 从已注册的service中查找.
</span><span class="c1"></span>	<span class="nx">srv</span><span class="p">,</span> <span class="nx">knownService</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">service</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">knownService</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 若方法存在,在调用processUnaryRPC.此时md已经指向注册时的Handler了,如SyaHello方法对应的_HelloService_SayHello_Handler.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">processUnaryRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">streams</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 调用流式处理.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">processStreamingRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 若不存在,调用unknown.
</span><span class="c1"></span>	<span class="c1">// Unknown service, or known server unknown method.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">unknownDesc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">unknownStreamDesc</span><span class="p">;</span> <span class="nx">unknownDesc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">processStreamingRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unknownDesc</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="o">......</span>
<span class="p">}</span>

<span class="c1">// processUnaryRPC实质上就是先从stream中读取一个完整的message,然后再调用md的Handler,来执行具体的业务代码,最后再sendResponse.
</span><span class="c1"></span>
<span class="c1">// 具体的业务逻辑代码,*.pb.go文件中.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_HelloService_SayHello_Handler</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dec</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">interceptor</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 解析请求参数.
</span><span class="c1"></span>	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">dec</span><span class="p">(</span><span class="nx">in</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    
    <span class="c1">// 如果没有设置拦截器,就直接调用SayHello.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">interceptor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">{</span>
		<span class="nx">Server</span><span class="p">:</span>     <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">FullMethod</span><span class="p">:</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1">// UnaryHandler,具体的业务逻辑.
</span><span class="c1"></span>	<span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">.(</span><span class="o">*</span><span class="nx">HelloRequest</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="c1">// 调用拦截器,最后再执行handler,来处理业务逻辑.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">interceptor</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<ul>
<li>通过<code>ServerOption</code>来设置自定义参数,最主要的包括<code>grpc.Creds</code>(用于设置服务端认证)和<code>grpc.UnaryInterceptor</code>(用于设置服务端拦截器).</li>
<li>在*.pb.go中主要是通过<code>grpc.ServiceDesc</code>来描述rpc接口的信息,最终调用会指向其<code>Handler</code>字段.</li>
<li>在整个处理过程中会涉及到的goroutine.
<ul>
<li>当<code>Accept</code>接收到一个新连接时就会启用一个goroutine,主要用来处理认证及HTTP/2相关的初始化.</li>
<li>接着会启用一个goroutine用来接收HTTP/2协议的数据.</li>
<li>每接收到一个完整请求包时,会再启用一个goroutine用来处理新的消息包.注意:此处如果设置了<code>numServerWorkers</code>,会优先使用workchannel.</li>
</ul>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之初识</title>
			<link>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E8%AF%86/</link>
			<pubDate>Fri, 06 Nov 2020 22:05:51 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E8%AF%86/</guid>
			<description>RPC RPC指远程过程调用(Remote Procedure Call),让远程服务调用更加简单、透明.服务调用者可以像调用本地接口一样调用远程的服务提供者,而不需</description>
			<content type="html"><![CDATA[<h2 id="rpc">RPC</h2>
<p>RPC指远程过程调用(Remote Procedure Call),让远程服务调用更加简单、透明.服务调用者可以像调用本地接口一样调用远程的服务提供者,而不需要关心底层通信细节和调用过程,RPC框架负责底层的传输方式、序列化方式和通信细节.</p>
<p>gRPC是一个高性能、开源和通用的RPC框架,面向服务端和移动端,特点如下:</p>
<ul>
<li>支持多语言.</li>
<li>基于IDL文件定义服务,通过protoc工具生成指定语言的数据结构、服务端接口和客户端Stub.</li>
<li>通信协议基于HTTP/2设计,支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性.使得在移动端设备上更加省电和节省网络流量.</li>
<li>序列化支持<a href="https://github.com/protocolbuffers/protobuf">Protocol Buffer</a>和JSON.</li>
</ul>
<p><img src="/images/grpc.png" alt="gRPC调用示例" title="gRPC调用"></p>
<h2 id="protoc工具">protoc工具</h2>
<p>先安装相关工具,可以用来直接生成go和grpc的代码.</p>
<ol>
<li>安装<a href="https://github.com/protocolbuffers/protobuf">protoc</a></li>
<li>安装<a href="https://github.com/protocolbuffers/protobuf-go">protoc-gen-go</a></li>
<li>安装<a href="https://github.com/grpc/grpc-go">protoc-gen-go-grpc</a></li>
</ol>
<h2 id="idl文件">IDL文件</h2>
<p>生成<code>hello.proto</code>文件,内容如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>

<span class="nx">option</span> <span class="nx">go_package</span><span class="p">=</span><span class="s">&#34;.;pb&#34;</span><span class="p">;</span>

<span class="nx">message</span> <span class="nx">HelloRequest</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">name</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">HelloReply</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">message</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">HelloService</span> <span class="p">{</span>
    <span class="nx">rpc</span> <span class="nf">SayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>syntax,定义proto的版本,支持proto2和proto3,proto3才支持grpc.</li>
<li>go_package,定义生成的go文件的包名(package name).</li>
<li>message,定义数据结构.</li>
<li>service,定义服务,可包含多个rpc函数.</li>
</ul>
<h2 id="生成go语言代码">生成go语言代码</h2>
<p>使用工具<code>protoc</code>来生成对应的go文件,命令<code>protoc -I=./proto --go_out=plugins=grpc:./pb hello.proto</code>.</p>
<ul>
<li><code>-I=./proto</code>,表示proto文件所在的目录.</li>
<li><code>--go_out</code>,表示生成go语言的代码,且存放go文件的目录,默认是不会生成grpc的代码的,需要显式声明<code>plugins=grpc</code>.</li>
<li><code>hello.proto</code>,表示proto文件的名字.</li>
</ul>
<p>在目录<code>pb</code>中生成文件<code>hello.pb.go</code>,文件里面包含了grpc相关代码.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Reference imports to suppress errors if they are not otherwise used.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span>

<span class="c1">// This is a compile-time assertion to ensure that this generated file
</span><span class="c1">// is compatible with the grpc package it is being compiled against.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">SupportPackageIsVersion6</span>

<span class="c1">// HelloServiceClient is the client API for HelloService service.
</span><span class="c1">//
</span><span class="c1">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">HelloServiceClient</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">helloServiceClient</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cc</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewHelloServiceClient</span><span class="p">(</span><span class="nx">cc</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span><span class="p">)</span> <span class="nx">HelloServiceClient</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">helloServiceClient</span><span class="p">{</span><span class="nx">cc</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">helloServiceClient</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloReply</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// HelloServiceServer is the server API for HelloService service.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">HelloServiceServer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// UnimplementedHelloServiceServer can be embedded to have forward compatible implementations.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnimplementedHelloServiceServer</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">UnimplementedHelloServiceServer</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Unimplemented</span><span class="p">,</span> <span class="s">&#34;method SayHello not implemented&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">HelloServiceServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_HelloService_serviceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_HelloService_SayHello_Handler</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dec</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">interceptor</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">dec</span><span class="p">(</span><span class="nx">in</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">interceptor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">{</span>
		<span class="nx">Server</span><span class="p">:</span>     <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">FullMethod</span><span class="p">:</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">.(</span><span class="o">*</span><span class="nx">HelloRequest</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">interceptor</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">_HelloService_serviceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;HelloService&#34;</span><span class="p">,</span>
	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloServiceServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>
		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;SayHello&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_HelloService_SayHello_Handler</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>
	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;hello.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><h2 id="服务端代码">服务端代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 监听tcp端口,用于接受客户端请求.
</span><span class="c1"></span><span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">port</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to listen: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 创建gRPC服务实例对象.
</span><span class="c1"></span><span class="nx">grpcserver</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>

<span class="c1">// 把server对象注册到gRPC服务中,server对象实现了HelloServiceServer接口.
</span><span class="c1"></span><span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">grpcserver</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">server</span><span class="p">{})</span>

<span class="c1">// 阻塞等待客户端连接,直到进程被终止或Stop函数被调用.
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">grpcserver</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to server: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="客户端代码">客户端代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个连接与服务端进行通信.
</span><span class="c1"></span><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to dail: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 关闭连接.
</span><span class="c1"></span><span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="c1">// 创建HelloService的Client stub.
</span><span class="c1"></span><span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewHelloServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>

<span class="c1">// 调用对应的服务方法.
</span><span class="c1"></span><span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;zhou&#34;</span><span class="p">})</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to sayhello: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
</code></pre></div><h2 id="调用分析">调用分析</h2>
<h3 id="wireshark抓包">wireshark抓包</h3>
<p>服务端监听在9090端口,用<a href="https://www.wireshark.org/">wireshark</a>来进行抓包.
<img src="/images/pcap1.png" alt="抓包" title="wireshark抓包">
可以看到前三行是tcp三次握手的报文,后续的全部都解析成了tcp协议,gRPC是基于http/2,需要手工修改Protocol为http/2.
wireshark菜单栏&ndash;&gt;分析(A)&ndash;&gt;解码为(Decode As),在弹出的界面新增一行,然后修改&quot;当前&quot;列为HTTP2.
<img src="/images/pcap2.png" alt="设置http/2" title="设置协议为http2"></p>
<p>现在能正常解析为HTTP/2协议了,一次gRPC调用总览如下:
<img src="/images/pcap3.png" alt="HTTP/2协议" title="gRPC调用总览">
从上图大体可以看出,gRPC调用过程分为:<code>Magic(C-&gt;S) --&gt; SETTINGS(S-&gt;C) --&gt; SETTINGS(C-&gt;S) --&gt; SETTINGS(S-&gt;C) --&gt; SETTINGS,HEADERS,DATA(C-&gt;S) --&gt; WINDOW_UPDATE,PING(S-&gt;C) --&gt; HEADERS,DATA,HEADERS(S-&gt;C) --&gt; PING,WINDOW_UPDATE,PING(C-&gt;S) --&gt; PING(S-&gt;C)</code></p>
<h3 id="magic">Magic</h3>
<p><img src="/images/grpc-magic.png" alt="Magic" title="gRPC-Magic">
Magic帧的主要作用是建立HTTP/2请求的前言.在HTTP/2协议中,要求两端都要发送连接前言,来最终确认所使用的协议,并确定HTTP/2连接的初始设置.</p>
<p>而Magic帧是客户端的前言之一,内容为<code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>,以确定启用HTTP/2连接.</p>
<h3 id="settings">SETTINGS</h3>
<p><img src="/images/grpc-settings1.png" alt="SETTINGS1" title="gRPC-SETTINGS">
由服务端发送给客户端,主要设置<code>Max Frame Size</code>为16384字节,作用域是整个连接而非单一的流.也是服务端的连接前言.</p>
<p><img src="/images/grpc-settings2.png" alt="SETTINGS2" title="gRPC-SETTINGS">
由客户端发送给服务端,是客户端的连接前言(和Magic一起).</p>
<p><img src="/images/grpc-settings3.png" alt="SETTINGS3" title="gRPC-SETTINGS">
由服务端发送给客户端,在发送完前言后,客户端和服务端还需要有一步互相确认的动作,对应的就是带有<code>ACK: True</code>的帧.</p>
<p><img src="/images/grpc-settings4.png" alt="SETTINGS4" title="gRPC-SETTINGS">
由客户端发送给服务端,是带有<code>ACK: True</code>的帧.</p>
<h3 id="headers">HEADERS</h3>
<p><img src="/images/grpc-headers1.png" alt="HEADERS1" title="gRPC-HEADERS">
主要是存储和传播HTTP的表头信息.</p>
<h3 id="data">DATA</h3>
<p><img src="/images/grpc-data1.png" alt="DATA1" title="gRPC-DATA">
DATA是数据帧,可以看到请求的protobuf结构只有1个字段,该字段的值为<code>zhou</code>(可以参见客户端代码).</p>
<h3 id="window_update">WINDOW_UPDATE</h3>
<p><img src="/images/grpc-win.png" alt="WIN" title="gRPC-WINDOW_UPDATE">
主要是管理流控制窗口的大小.</p>
<h3 id="headersdataheaders">HEADERS,DATA,HEADERS</h3>
<p><img src="/images/grpc-rsp1.png" alt="RSP1" title="gRPC-DATA">
<img src="/images/grpc-rsp2.png" alt="RSP2" title="gRPC-DATA">
服务端发送给客户端的响应,HEADERS frame记录的是HTTP响应状态(<code>200 OK</code>)和响应的内容格式(<code>application/grpc</code>).
响应的protobuf结构也是只有1个字段,字段的值是<code>zhou</code>.</p>
<h3 id="ping">PING</h3>
<p>主要是判断当前连接是否仍然可用,也常用于计算往返时间.</p>
<h2 id="流式模式">流式模式</h2>
<p>gRPC支持UnaryRPC(一元PRC)和StreamRPC(流式RPC).</p>
<ul>
<li>UnaryRPC,上面介绍的都是基于UnaryRPC的,该模式是一个请求对应一个响应.</li>
<li>StreamRPC流式模式的请求和响应是多对多的,又分为三种类型:
<ul>
<li>Server-side streaming RPC,服务端流式模式,即一个请求对应多个响应.</li>
<li>Client-side streaming RPC,客户端流式模式,即多个请求对应一个响应.</li>
<li>Bidirectional streaming RPC,双向流式模式,即多个请求对应多个响应.</li>
</ul>
</li>
</ul>
<p>流式模式需要用到关键字<code>stream</code>,如下proto文件.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>

<span class="nx">option</span> <span class="nx">go_package</span><span class="p">=</span><span class="s">&#34;.;pb&#34;</span><span class="p">;</span>

<span class="nx">message</span> <span class="nx">HelloRequest</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">name</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">HelloReply</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">message</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">HelloService</span> <span class="p">{</span>
    <span class="nx">rpc</span> <span class="nf">SayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">ServerSayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">ClientSayHello</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">BidirSayHello</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloReply</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>SayHello</code>是一元RPC模式.
<code>ServerSayHello</code>是服务端流式模式.
<code>ClientSayHello</code>是客户端流式模式.
<code>BidirSayHello</code>是双向流式模式.</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://jingwei.link/2018/10/02/grpc-wireshark-analysis.html">抓包gRPC的细节与分析</a></li>
<li><a href="https://httpwg.org/specs/rfc7540.html">Hypertext Transfer Protocol Version 2</a></li>
<li><a href="https://eddycjy.com/posts/go/talk/2019-06-29-talking-grpc/">从实践到原理，带你参透 gRPC</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>go性能分析</title>
			<link>https://shenbaise9527.com/posts/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
			<description>性能分析 Go语言项目中的性能分析主要有以下几个方面: CPU profile: CPU使用情况,按照一定频率去采集应用程序在CPU和寄存器上面的数据. Memory profile(Heap profile): 报告程序</description>
			<content type="html"><![CDATA[<h2 id="性能分析">性能分析</h2>
<p>Go语言项目中的性能分析主要有以下几个方面:</p>
<ul>
<li>CPU profile: CPU使用情况,按照一定频率去采集应用程序在CPU和寄存器上面的数据.</li>
<li>Memory profile(Heap profile): 报告程序的内存使用情况.</li>
<li>Block Profiling: 报告goroutines不在运行状态的情况,可用来分析和查找死锁等性能瓶颈.</li>
<li>Goroutine Profiling: 报告goroutines的使用情况,有哪些goroutines,调用关系是怎么样的?</li>
</ul>
<h2 id="数据采集">数据采集</h2>
<p>Go语言内置了获取程序运行数据的工具,包括两个标准库:</p>
<ol>
<li><code>runtime/pprof</code>: 采集工具型应用的运行数据进行分析</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;runtime/pprof&#34;</span>

<span class="c1">// 开启CPU性能分析.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">StartCPUProfile</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>

<span class="c1">// 关闭CPU性能分析.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">StopCPUProfile</span><span class="p">()</span>

<span class="c1">// 记录程序堆栈信息.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">WriteHeapProfile</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
</code></pre></div><p>pprof开启后,每隔一段时间(10ms)就会收集下当前的堆栈信息,获取各个函数占用的CPU以及内存资源,最后通过采样数据分析,形成性能分析报告.</p>
<ol start="2">
<li><code>net/http/pprof</code>: 采集服务型应用的运行数据进行分析</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在web server端导入pprof库.
</span><span class="c1"></span><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>

<span class="c1">// 如果使用自定义Mux,需要手动注册路由规则.
</span><span class="c1"></span><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/cmdline&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Cmdline</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/profile&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Profile</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/symbol&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Symbol</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/trace&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Trace</span><span class="p">)</span>

<span class="c1">// 如果使用gin框架,推荐使用&#39;github.com/DeanThompson/ginpprof&#39;
</span></code></pre></div><p>http服务会多出<code>/debug/pprof</code>的endpoint:</p>
<ul>
<li>/debug/pprof/profile: 访问这个链接会自动进行CPU Profiling,持续30s,并生成文件供下载.</li>
<li>/debug/pprof/heap: Memory Profiling.</li>
<li>/debug/pprof/block: Block Profiling.</li>
<li>/debug/pprof/goroutines: 运行的goroutines列表以及调用关系.</li>
</ul>
<ol start="3">
<li>profiling数据是动态的,要想获得有效的数据,请保证应用处于较大的负载,否则如果处于空闲状态,得到的结果可能没有任何意义</li>
</ol>
<h2 id="数据分析">数据分析</h2>
<h3 id="go-tool-pprof命令">go tool pprof命令</h3>
<p>可以通过命令<code>go tool pprof --help</code>查看命令的具体使用方法.</p>
<pre><code>$ go tool pprof --help
usage:

Produce output in the specified format.

   pprof &lt;format&gt; [options] [binary] &lt;source&gt; ...

Omit the format to get an interactive shell whose commands can be used
to generate various views of a profile

   pprof [options] [binary] &lt;source&gt; ...

Omit the format and provide the &quot;-http&quot; flag to get an interactive web
interface at the specified host:port that can be used to navigate through
various views of a profile.

   pprof -http [host]:[port] [options] [binary] &lt;source&gt; ...

Details:
  Output formats (select at most one):
</code></pre><h3 id="图形化">图形化</h3>
<ol>
<li>
<p>安装<a href="https://graphviz.gitlab.io/">graphviz</a>,windows是还需要把安装目录下的<code>bin</code>文件夹添加到<code>PATH</code>环境变量中.</p>
</li>
<li>
<p>使用<code>dot -version</code>命令查看graphviz安装是否成功.</p>
</li>
<li>
<p>安装go-torch,使用<code>go get -v github.com/uber/go-torch</code>命令安装.
当<code>go-torch</code>不带任何参数时,会默认从<code>http://localhost:8080/debug/pprof/profile</code>获取profiling数据.</p>
<pre><code>$ go-torch --help
Usage:
go-torch [options] [binary] &lt;profile source&gt;

pprof Options:
-u, --url=         Base URL of your Go program (default: http://localhost:8080)
    --suffix=      URL path of pprof profile (default: /debug/pprof/profile)
-b, --binaryinput= File path of previously saved binary profile. (binary profile is anything accepted by https://golang.org/cmd/pprof)
    --binaryname=  File path of the binary that the binaryinput is for, used for pprof inputs
-t, --seconds=     Number of seconds to profile for (default: 30)
    --pprofArgs=   Extra arguments for pprof
</code></pre></li>
<li>
<p>安装<a href="https://www.perl.org/get.html">perl</a>,FlameGraph需要perl支持.</p>
</li>
<li>
<p>安装FlameGraph,使用<code>git clone https://github.com/brendangregg/FlameGraph.git</code>命令安装.
windows平台下,需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code>按如下方式修改,然后在<code>go-torch</code>目录下执行<code>go install</code>命令.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) {
</span><span class="c1"></span><span class="nx">flameGraph</span> <span class="o">:=</span> <span class="nf">findInPath</span><span class="p">(</span><span class="nx">flameGraphScripts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">flameGraph</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errNoPerlScript</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">runScript</span><span class="p">(</span><span class="s">&#34;perl&#34;</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">flameGraph</span><span class="p">},</span> <span class="nx">args</span><span class="o">...</span><span class="p">),</span> <span class="nx">graphInput</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nf">runScript</span><span class="p">(</span><span class="nx">flameGraph</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">graphInput</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>安装go-wrk,使用<code>go get -v https://github.com/adjust/go-wrk</code>命令安装.</p>
<pre><code>$ go-wrk --help
Usage of go-wrk:
-CA string
        A PEM eoncoded CA's certificate file. (default &quot;someCertCAFile&quot;)
-H string
        the http headers sent separated by '\n' (default &quot;User-Agent: go-wrk 0.1 benchmark\nContent-Type: text/html;&quot;)
-b string
        the http request body
-c int
        the max numbers of connections used (default 100)
-cert string
        A PEM eoncoded certificate file. (default &quot;someCertFile&quot;)
-d string
        dist mode
-f string
        json config file
-i	TLS checks are disabled
-k	if keep-alives are disabled (default true)
-key string
        A PEM encoded private key file. (default &quot;someKeyFile&quot;)
-m string
        the http request method (default &quot;GET&quot;)
-n int
        the total number of calls processed (default 1000)
-p string
        the http request body data file
-r	in the case of having stream or file in the response,
        it reads all response body to calculate the response size
-s string
        if specified, it counts how often the searched string s is contained in the responses
-t int
        the numbers of threads used (default 1)
</code></pre></li>
<li>
<p>使用方式</p>
<ul>
<li>使用go-wrk压测,使用命令<code>go-wrk -n 50000 http://127.0.0.1:8080/*/*</code>在某个接口进行压测</li>
<li>使用go-torch收集数据,使用命令<code>go-torch -u http://127.0.0.1:8080 -t 30</code>,30秒之后终端会出现如下提示: <code>Writing svg to torch.svg</code>,然后使用浏览器打开<code>torch.svg</code>,就能看到火焰图.</li>
</ul>
</li>
<li>
<p>perf</p>
<ul>
<li>Linux下使用命令<code>perf record -a -g -p pid -- sleep 30</code>,对指定进程采样30秒.</li>
<li>使用命令<code>perf script -i ../perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl &gt; app.svg</code>,其中<code>../perf.data</code>为<code>perf record</code>生成的采样数据,然后切换到FlameGraph的目录来执行上述命令,就能得到火焰图了(<code>stackcollapse-perf.pl</code>脚本是合并调用栈信息,<code>flamegraph.pl</code>脚本是生成火焰图).</li>
</ul>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/Dr-wei/p/11742414.html">Go pprof性能调优</a>.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>tcp连接过程</title>
			<link>https://shenbaise9527.com/posts/tcp%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/tcp%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/</guid>
			<description>tcp建连接三次握手 客户端发送SYN到服务器发起握手. 服务器收到SYN后回复SYN+ACK给客户端. 客户端收到SYN+ACK后,回复服务器一</description>
			<content type="html"><![CDATA[<h2 id="tcp建连接三次握手">tcp建连接三次握手</h2>
<ul>
<li>客户端发送SYN到服务器发起握手.</li>
<li>服务器收到SYN后回复SYN+ACK给客户端.</li>
<li>客户端收到SYN+ACK后,回复服务器一个ACK表示收到了,此时客户端的端口状态已经是established.</li>
<li>tcp握手的详细过程,<a href="http://www.cnxct.com/something-about-phpfpm-s-backlog/">图片来源</a>
<img src="/images/tcp_accept_queue.png" alt="tcp建立连接的流程和队列" title="tcp连接的流程"></li>
</ul>
<p>客户端作为主动发起连接方,首先要发送SYN(Synchronize Sequence Nubers,同步序列号)包,若客户端长时间收不到服务端的ACK报文,客户端就会重发SYN包,重传次数是受内核参数<code>/proc/sys/net/ipv4/tcp_syn_retries</code>控制.</p>
<pre><code># 系统为centos7.2.1511,默认为6次.
$ cat /proc/sys/net/ipv4/tcp_syn_retries 
6
</code></pre><p>通常第一次超时重传为1秒,第二次超时重传为2秒,第三次超时重传为4秒,第四次为8秒,第五次为16秒,第五次超时重传之后还会再等待32秒,如果服务端仍然没有回应ACK,客户端就会终止三次握手.总耗时为63秒.</p>
<h2 id="半连接队列">半连接队列</h2>
<p>syns queue就是半连接队列,server收到client的syn后会把连接信息放入该队列.</p>
<p>半连接队列的大小为max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog).</p>
<pre><code># 在ubuntu18.04机器上为128.
$ cat /proc/sys/net/ipv4/tcp_max_syn_backlog 
128
</code></pre><p>syn floods攻击就是针对半连接队列的,攻击方不停的建立连接,收到server的syn+ack就丢弃什么也不做,导致server的半连接队列满而其它正常连接无法进来.</p>
<h2 id="全连接队列">全连接队列</h2>
<ul>
<li>accept queue就是全连接队列,server再收到client的ack后会把连接信息放入该队列.</li>
<li>全连接队列的大小为min(backlog, /proc/sys/net/core/somaxconn).</li>
<li>backlog是指<code>listen(int sockfd, int backlog)</code>函数中的backlog大小.</li>
</ul>
<pre><code># 在ubuntu18.04机器上为128.
$ cat /proc/sys/net/core/somaxconn
128
</code></pre><h2 id="如何观察队列溢出">如何观察队列溢出</h2>
<p><strong>netstat -s</strong></p>
<pre><code># 查看半连接队列溢出.
sky-HP# netstat -s | egrep &quot;SYNs to LISTEN&quot;
667399 SYNs to LISTEN sockets ignored
# 上面看到的667399就是半连接队列溢出次数,隔几秒执行下,如果这个数字一直在变大肯定就是半连接队列溢出了.

# 查看全连接队列溢出.
sky-HP# netstat -s | grep &quot;overflowed&quot;
667399 times the listen queue of a socket overflowed
</code></pre><p><strong>ss -lntp</strong></p>
<pre><code># l表示处于LISTEN状态 n表示不反向解析 t表示tcp协议 p表示进程信息.
sky-HP# ss -lntp
State       Recv-Q       Send-Q              Local Address:Port              Peer Address:Port                                                        
LISTEN      0            128                       0.0.0.0:8388                   0.0.0.0:*           users:((&quot;haproxy&quot;,pid=1465,fd=6))               
LISTEN      0            128                 127.0.0.53%lo:53                     0.0.0.0:*           users:((&quot;systemd-resolve&quot;,pid=841,fd=13))       
LISTEN      0            128                       0.0.0.0:22                     0.0.0.0:*           users:((&quot;sshd&quot;,pid=1476,fd=3))                  
LISTEN      0            5                       127.0.0.1:631                    0.0.0.0:*           users:((&quot;cupsd&quot;,pid=5112,fd=7))                 
LISTEN      0            128                     127.0.0.1:1080                   0.0.0.0:*           users:((&quot;trojan&quot;,pid=1940,fd=6))                
LISTEN      0            128                     127.0.0.1:8123                   0.0.0.0:*           users:((&quot;polipo&quot;,pid=1461,fd=4))                
</code></pre><p>Send-Q就是表示全连接队列的允许最大长度,Recv-Q表示当前全连接队列的长度.这是套接字处于LISTEN状态时.
需要注意,当套接字处于Established状态时Recv-Q表示套接字缓冲区还没有被应用取走的字节数(接收队列长度),Send-Q表示还没有被远端主机确认的字节数(发送队列长度).</p>
<h2 id="溢出行为的控制">溢出行为的控制</h2>
<p><strong>半连接队列控制</strong>
当半连接队列满时,只能丢弃连接?</p>
<p>并不是这样的,Linux提供了syncookies功能,可以在不适用半连接队列的情况下成功建立连接.
syncookies原理:服务器会根据当前的状态计算出一个值,放入己方的SYN+ACK报文中发送给客户端,当客户端返回ACK报文时,取出该值验证,如果合法,就认为连接建立成功.</p>
<p>syncookies功能由内核参数<code>/proc/sys/net/ipv4/tcp_syncookies</code>来控制.</p>
<ul>
<li>值为0时,表示关闭该功能.</li>
<li>值为1时,表示仅当半连接队列满时,再启用该功能.1为默认值,默认开启.</li>
<li>值为2时,表示无条件开启该功能.</li>
</ul>
<p><strong>全连接队列控制</strong>
内核参数<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>决定当溢出后系统如何处理.</p>
<ul>
<li>为0时表示server扔掉client发过来的ack.server会认为连接还未建立.server过段时间会继续向client发送syn+ack.重传会经历1、2、4、8、16、32秒(若重传为5次),如果服务端仍没有收到ack,才会关闭连接,总共需63秒.
<ul>
<li>内核参数<code>/proc/sys/net/ipv4/tcp_synack_retries</code>控制重试次数.如果client超时时间比较短,client就容易异常.</li>
</ul>
</li>
<li>为1时表示server发送一个reset包给client,表示废掉这个握手过程和连接.client会看到connection reset by peer的错误.</li>
</ul>
<pre><code># 在ubuntu18.04机器上的默认值.
sky-HP# cat /proc/sys/net/ipv4/tcp_abort_on_overflow 
0
sky-HP# cat /proc/sys/net/ipv4/tcp_synack_retries 
5
</code></pre><p>可以通过<code>sysctl -w</code>来修改这些内核参数,重启之后修改无效.</p>
<pre><code>sky-HP# sysctl -w net.ipv4.tcp_synack_retries=2
net.ipv4.tcp_synack_retries = 2
sky-HP# cat /proc/sys/net/ipv4/tcp_synack_retries 
2

sky-HP# sysctl -w net.ipv4.tcp_abort_on_overflow=1
net.ipv4.tcp_abort_on_overflow = 1
sky-HP# cat /proc/sys/net/ipv4/tcp_abort_on_overflow 
1
</code></pre><p>修改配置文件<code>/etc/sysctl.conf</code>,然后再<code>sysctl -p</code>来触发,重启之后仍生效.</p>
<h2 id="绕过三次握手">绕过三次握手</h2>
<p>三次握手建立连接的后果就是,数据请求必须在一个RTT(从客户端到服务器一个往返时间)后才能发送.</p>
<p>在Linux3.7内核版本之后,提供了TCP Fast Open功能,可以减少TCP连接建立的时延.
<img src="/images/fast.jpg" alt="Fast Open" title="Linux TCP Fast Open"></p>
<p>客户端首次建立连接时仍然需要三次握手.</p>
<ol>
<li>客户端发送SYN报文,报文包含Fast Open选项,且该选项的Cookie为空,表名客户端请求Fast Open Cookie.</li>
<li>支持TCP Fast Open的服务器生成Cookie,并置于SYN-ACK数据包中的Fast Open选项发回给客户端.</li>
<li>客户端收到SYN-ACK后,本地缓存Fast Open选项中的Cookie.</li>
</ol>
<p>当客户端再次与服务器建立连接时就可以利用Cookie来绕过三次握手过程.</p>
<ol>
<li>客户端发送SYN报文,该报文包含之前缓存的Cookie及业务数据报文.</li>
<li>支持TCP Fast Open的服务器会对收到的Cookie进行校验.
<ul>
<li>如果合法,服务器将在SYN-ACK报文中对SYN和业务数据进行确认,服务器随后把业务数据传递给应用程序;</li>
<li>如果不合法,服务器将丢弃SYN报文中包含的业务数据,且在SYN-ACK报文中只确认SYN的序列号.</li>
</ul>
</li>
<li>若服务器接受了SYN报文中的业务数据,即在握手完成之前发送了数据,这就减少了握手带来的一个RTT的时间消耗.</li>
<li>客户端将发送ACK确认服务器发回的SYN及数据.若客户端在初始的SYN报文中的数据未被确认,则客户端会重新发送这些数据.</li>
<li>此后的TCP连接的数据传输过程和非TCP Fast Open的正常情况是一致的.</li>
</ol>
<p>TCP Fast Open功能受内核参数<code>/proc/sys/net/ipv4/tcp_fastopen</code>控制.</p>
<ul>
<li>值为0时,表示关闭该功能.</li>
<li>值为1时,作为客户端使用Fast Open功能.</li>
<li>值为2时,作为服务端使用Fast Open功能.</li>
<li>值为3时,作为客户端和服务端都可以使用Fast Open功能.</li>
</ul>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ">TCP 三次握手原理，你真的理解吗？</a></li>
<li><a href="https://time.geekbang.org/column/article/81057">关于 Linux 网络，你必须知道这些</a></li>
<li><a href="https://www.cnblogs.com/otis/p/13070877.html">看完这篇，再不懂TCP我也没办法了</a></li>
<li><a href="https://www.cnxct.com/something-about-phpfpm-s-backlog/">TCP SOCKET中backlog参数的用途是什么？</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>局部变量在函数栈上的顺序分析</title>
			<link>https://shenbaise9527.com/posts/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%87%BD%E6%95%B0%E6%A0%88%E4%B8%8A%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%87%BD%E6%95%B0%E6%A0%88%E4%B8%8A%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</guid>
			<description>问题来源 源于如下代码: int main(int argc, char* argv[]){ int i = 0; int arr[3] = {0}; for(; i&amp;lt;=3; i++){ arr[i] = 0; printf(&amp;#34;hello world\n&amp;#34;); } return 0; } 这段代码的运行结果并非是打印三行“hello word”，而是会无限打</description>
			<content type="html"><![CDATA[<h2 id="问题来源">问题来源</h2>
<p>源于如下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello word”，这是为什么？</p>
<p>当看到这段后，脑海中最直观的感受：</p>
<blockquote>
<p>函数栈上的地址是从大到小的，局部变量i先入栈，数组arr后入栈。假设arr的地址为0x0，则arr[0]的地址为0x0，arr[1]的地址为0x4，arr[2]的地址为0x8，i的地址为0xc。所以在循环中访问到arr[3]时的地址正好对应到变量i上，把i的值修改为0，导致出现死循环。</p>
</blockquote>
<p>需要进行验证下，首先在vs2013上测试，发现和想象的完全不一样。
只打印了四行“hello word”，然后程序崩溃，显示“Run-Time Check Failure #2 - Stack around the variable &lsquo;arr&rsquo; was corrupted”。
然后修改下代码把变量i和arr的地址都打印出来，可以看到变量i的地址比arr的地址小，这是怎么回事？怎么参数入栈的顺序和变量声明的顺序不一样了？</p>
<p>接着又在x86-64位centos6上测试，采用“gcc demo.c -o demo”编译，运行发现和想象的是一样的，无限打印“hello world”。</p>
<p>问题：</p>
<blockquote>
<p>1.参数入栈的顺序和变量声明的顺序怎么不一致？
2.在linux下表现怎么和windows不一样？</p>
</blockquote>
<h2 id="问题分析">问题分析</h2>
<p>以前从来没关注过局部变量的声明顺序和入栈顺序之前的关系，首先来理理为什么在windows下不一致，而在linux下是一致的。
在linux下使用的编译器是GCC，主要参考的是<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html">GCC 中的编译器堆栈保护技术</a>这篇文章，文中提到了GCC中三个与堆栈保护有关的选项。</p>
<blockquote>
<ol>
<li>-fstack-protector，启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</li>
<li>-fstack-protector-all，启用堆栈保护，为所有函数插入保护代码</li>
<li>-fno-stack-protector，禁用堆栈保护</li>
</ol>
</blockquote>
<p>在linux下重新编译下，gcc demo.c -fstack-protector -o demo，发现运行时只打印了四次“hello world”，且变量i的地址也是比arr的地址小，linux下的现象已和windows一样了。</p>
<blockquote>
<p>编译时如果开启了优化选项(O2或O3)，会默认启用堆栈保护。</p>
</blockquote>
<p>当启用堆栈保护后，局部变量的顺序被重新组织了。这样做的目的主要是为了防止溢出攻击，具体可以详读上面提到的那篇文章。
局部变量的顺序的重组的规则如下，主要适用于GCC编译器，VS的处理不一样(主要参考<a href="https://blog.csdn.net/qq_19406483/article/details/77511447?utm_source=blogxgwz3">C语言局部变量在内存栈中的顺序</a>这篇文章,但结论有所修正)：</p>
<blockquote>
<ol>
<li>内存由高到低优先分配给占位8字节、4字节、2字节、1字节的数据类型</li>
<li>同总占位的类型按定义变量的先后顺序内存地址会增加</li>
<li>在规则2前提下，定义数组不会和同总数据类型混占内存</li>
</ol>
</blockquote>
<p>数据类型占位说明(64位机器下)：
8字节：double、long long int、long int(该类型在64位windows下位4字节，在linux x86/ppc下都是8字节)
4字节：int、float、unsigned int
2字节：short 、unsigned short
1字节：char 、unsigned char
例如,分别定义下列变量，内存地址中由高到低分别为： double &lt; int &lt; short &lt; char</p>
<p>参考如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">char_a</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">short_a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">int_a</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">float_a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">double_a</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uint_a</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">int</span> <span class="n">lint_a</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">dlint_a</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;  &amp;char_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">char_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34; &amp;short_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">short_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;   &amp;int_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">int_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34; &amp;float_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">float_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;&amp;double_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">double_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34; &amp;unsigned_int_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uint_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;     &amp;long_int_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">lint_a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;&amp;long_long_int_a : %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dlint_a</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;address-index: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;address-arr[%d]: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p>启用堆栈保护选项，结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="o">&amp;</span><span class="nl">char_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fa5</span>   <span class="o">--</span><span class="err">在最低的低地址位</span>
<span class="o">&amp;</span><span class="nl">short_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fa6</span>
<span class="o">&amp;</span><span class="nl">int_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fa8</span>  <span class="o">--</span><span class="n">int_a</span><span class="err">、</span><span class="n">float_a</span><span class="err">、</span><span class="n">uint_a</span><span class="err">、</span><span class="n">i</span> <span class="mi">4</span><span class="err">个同大小的变量地址在一起</span><span class="p">(</span><span class="err">与声明顺序相反</span><span class="p">)</span>
<span class="o">&amp;</span><span class="nl">float_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fac</span>
<span class="o">&amp;</span><span class="nl">double_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fb8</span> <span class="o">--</span><span class="n">double_a</span><span class="err">、</span><span class="n">lint_a</span><span class="err">、</span><span class="n">llint_a</span> <span class="mi">3</span><span class="err">个同大小的变量地址在一起</span><span class="p">(</span><span class="err">与声明顺序相反</span><span class="p">)</span>
<span class="o">&amp;</span><span class="nl">uint_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fb0</span>
<span class="o">&amp;</span><span class="nl">lint_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fc0</span>
<span class="o">&amp;</span><span class="nl">llint_a</span> <span class="p">:</span> <span class="mh">0x7fff14d57fc8</span>
<span class="n">address</span><span class="o">-</span><span class="nl">i</span><span class="p">:</span> <span class="mh">0x7fff14d57fb4</span>
<span class="n">address</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x7fff14d57fd0</span>  <span class="o">--</span><span class="err">数组地址在高位上</span>
<span class="n">address</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x7fff14d57fd4</span>
<span class="n">address</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x7fff14d57fd8</span>
</code></pre></div><p>从以上结果可以验证上面的规则。针对规则三，对于int类型的数组地址在高位，非数组变量在低位。double类型的数组也是类似的(注意上面的提到的文章是相反的结论)</p>
<h2 id="问题总结">问题总结</h2>
<ol>
<li>堆栈保护技术，主要是编译器为了防止溢出攻击而发展出来的技术，GCC有相应的编译选项可以开启和关闭。</li>
<li>局部变量的入栈规则，不启用堆栈保护技术时，按照声明的顺序入栈。启用堆栈保护技术时，是按照三个规则来进行重组的。</li>
<li>GCC默认是没有开启堆栈保护选项的，但如果启用了优化选项，堆栈保护选项会自动启用。</li>
</ol>
<h2 id="问题扩展">问题扩展</h2>
<p>如果数组arr的长度是4，如下代码，在64位x86上还能无限打印“hello world”吗？(gcc demo.c -o demo编译)</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>是不会无限打印的，这涉及到8字节对齐的问题。
数组arr[4]刚好满足8字节对齐，在栈中i和arr是不会连续存放的(暂不清楚缘由)，所以越界是不会访问到i的。
数组arr[3]是不满足8字节对齐，把变量i放到一起刚好满足，编译器就会把i和arr存放到一起。</p>
<p>如果数组arr的长度是5或7列，结果又是如何的？</p>
]]></content>
		</item>
		
		<item>
			<title>记录cgo调用C实现的加解密静态库中遇到的问题</title>
			<link>https://shenbaise9527.com/posts/cgo/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/posts/cgo/</guid>
			<description>起因 公司有个公共的加解密库,供所有后端C++服务调用的,但最近要使用Go来实现个服务需要用到加解密,而Go并没有提供AES-256-ECB的</description>
			<content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>公司有个公共的加解密库,供所有后端C++服务调用的,但最近要使用Go来实现个服务需要用到加解密,而Go并没有提供AES-256-ECB的加解密库,所以决定用cgo来调用这个公共的加解密库.</p>
<h2 id="window">Window</h2>
<p>在window下加解密库是提供的DLL,用Go的<code>syscall.NewLazyDLL</code>可以非常方便的加载DLL,window下基本没有遇到障碍.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="c1">// MICrypt 接口.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MICrypt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">MIFreeSafeHandle</span>    <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetDecryptDataLen</span> <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetEncryptDataLen</span> <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetSafeHandle</span>     <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MILoad</span>              <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MITransDecrypt</span>      <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MITransEncrypt</span>      <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">lib</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">NewLazyDLL</span><span class="p">(</span><span class="s">&#34;crypto64.dll&#34;</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MICrypt</span><span class="p">{</span>
		<span class="nx">MIGetSafeHandle</span><span class="p">:</span>     <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetSafeHandle&#34;</span><span class="p">),</span>
		<span class="nx">MIFreeSafeHandle</span><span class="p">:</span>    <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIFreeSafeHandle&#34;</span><span class="p">),</span>
		<span class="nx">MIGetDecryptDataLen</span><span class="p">:</span> <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetDecryptDataLen&#34;</span><span class="p">),</span>
		<span class="nx">MIGetEncryptDataLen</span><span class="p">:</span> <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetEncryptDataLen&#34;</span><span class="p">),</span>
		<span class="nx">MILoad</span><span class="p">:</span>              <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MILoad&#34;</span><span class="p">),</span>
		<span class="nx">MITransDecrypt</span><span class="p">:</span>      <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MITransDecrypt&#34;</span><span class="p">),</span>
		<span class="nx">MITransEncrypt</span><span class="p">:</span>      <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MITransEncrypt&#34;</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="c1">// 待加密字符串.
</span><span class="c1"></span>	<span class="nx">msg</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;I am test trans crypto!&#34;</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">MIGetSafeHandle</span><span class="p">.</span><span class="nf">Call</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MILoad</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">iLen</span> <span class="kt">int32</span>
	<span class="kd">var</span> <span class="nx">srcLen</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIGetEncryptDataLen</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">iLen</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iLen</span><span class="p">)</span>

	<span class="c1">// 加密.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">MITransEncrypt</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">iLen</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>

	<span class="nx">dstLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">iDLen</span> <span class="kt">int32</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIGetDecryptDataLen</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">iDLen</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>

	<span class="c1">// 再解密.
</span><span class="c1"></span>	<span class="nx">newSrc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iDLen</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MITransDecrypt</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newSrc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">newSrc</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIFreeSafeHandle</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="linux">Linux</h2>
<p>在Linux下加解密库提供的是静态库,调用方式完全不同于windows,碰到很多问题.</p>
<h3 id="不支持c中的引用">不支持C++中的引用<code>&amp;</code></h3>
<pre><code># aesecb
./aesecb.go:27:2: could not determine kind of name for C.MIGetDecryptDataLen
./aesecb.go:20:2: could not determine kind of name for C.MIGetEncryptDataLen
cgo: 
gcc errors for preamble:
In file included from ./aesecb.go:6:0:
/home/sky/code/imp/2nd/crypto/include/ISafeInterface.h:111:50: error: expected ';', ',' or ')' before '&amp;' token
 _DLL_EXP_API int32_t MIGetEncryptDataLen(int32_t &amp;iRevLen, const char *pData, int32_t iLen, intptr_t pSafeHandle);
</code></pre><p><strong>解决方案</strong>
把引用修改为指针</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">_DLL_EXP_API</span> <span class="kt">int32_t</span> <span class="nf">MIGetEncryptDataLen</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span> <span class="n">iRevLen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pData</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">iLen</span><span class="p">,</span> <span class="n">intptr_t</span> <span class="n">pSafeHandle</span><span class="p">);</span>
</code></pre></div><h3 id="undefined-reference">undefined reference</h3>
<pre><code>$ go build -x
WORK=/tmp/go-build163613860
mkdir -p $WORK/b001/
cd /home/sky/go/path/src/aesecb
CGO_LDFLAGS='&quot;-g&quot; &quot;-O2&quot; &quot;-L/home/sky/code/imp/2nd/cryptogo/lib/Linux_x86_64&quot; &quot;-lmism&quot; &quot;-lstdc++&quot;' /home/sky/go/go1.14/pkg/tool/linux_amd64/cgo -objdir $WORK/b001/ -importpath aesecb -- -I/h
ome/sky/code/imp/2nd/cryptogo/include -I $WORK/b001/ -g -O2 ./aesecb.gocd $WORK
gcc -fno-caret-diagnostics -c -x c - -o /dev/null || true
gcc -Qunused-arguments -c -x c - -o /dev/null || true
gcc -fdebug-prefix-map=a=b -c -x c - -o /dev/null || true
gcc -gno-record-gcc-switches -c -x c - -o /dev/null || true
cd $WORK/b001
TERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_x001.o -c _cgo_export.cTERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_x002.o -c aesecb.cgo2.cTERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_cgo_main.o -c _cgo_main.ccd /home/sky/go/path/src/aesecb
TERM='dumb' gcc -I . -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -o $WORK/b001/_cgo_.o $WORK/b001/_cgo_main.o $WORK/b001/_x00
1.o $WORK/b001/_x002.o -g -O2 -L/home/sky/code/imp/2nd/cryptogo/lib/Linux_x86_64 -lmism -lstdc++# aesecb
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetDecryptDataLen':
/tmp/go-build/cgo-gcc-prolog:69: undefined reference to `MIGetDecryptDataLen'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetEncryptDataLen':
/tmp/go-build/cgo-gcc-prolog:92: undefined reference to `MIGetEncryptDataLen'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetSafeHandle':
/tmp/go-build/cgo-gcc-prolog:109: undefined reference to `MIGetSafeHandle'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MILoad':
/tmp/go-build/cgo-gcc-prolog:131: undefined reference to `MILoad'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MITransDecrypt':
/tmp/go-build/cgo-gcc-prolog:156: undefined reference to `MITransDecrypt'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MITransEncrypt':
/tmp/go-build/cgo-gcc-prolog:181: undefined reference to `MITransEncrypt'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIFreeSafeHandle':
/tmp/go-build/cgo-gcc-prolog:49: undefined reference to `MIFreeSafeHandle'
collect2: error: ld returned 1 exit status
</code></pre><p>由于在编译加解密库mism时,是使用的g++编译器,编译出来的函数名会加上修饰符,导致cgo找不到对应的函数</p>
<pre><code># 查看符号表
$ nm libmism.a
...
0000000000000490 T _Z12MIMD5DecryptPcRiPKci
000000000000040f T _Z12MIMD5EncryptPcRiPKci
000000000000031f T _Z14MITransDecryptPciPKcil
00000000000002c9 T _Z14MITransEncryptPciPKcil
...
</code></pre><p>可以看到函数名已经发生变化了.</p>
<p><strong>解决方案</strong>
修改代码以C方式编译</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span>
<span class="p">{</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">......</span>
    <span class="n">_DLL_EXP_API</span> <span class="n">intptr_t</span> <span class="n">MIGetSafeHandle</span><span class="p">();</span>
<span class="p">......</span>
<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div><p>再次编译后,查看符号表,可以看到函数名没有发生变化.</p>
<pre><code>$ nm libmism.a
......
0000000000000040 T MIFreeSafeHandle
00000000000001d0 T MIGetDecryptDataLen
0000000000000190 T MIGetEncryptDataLen
0000000000000000 T MIGetSafeHandle
0000000000000070 T MILoad
0000000000000150 T MITransDecrypt
0000000000000110 T MITransEncrypt
......
</code></pre><h3 id="库依赖">库依赖</h3>
<p>继续编译,又报了undefined reference</p>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./libmism.a(AESEncryptHandle.cpp.o): In function `AESEncryptHandle::Encrypt(char*, int&amp;, char const*, int const&amp;)':
AESEncryptHandle.cpp:(.text+0x135): undefined reference to `EVP_aes_256_ecb'
AESEncryptHandle.cpp:(.text+0x145): undefined reference to `EVP_EncryptInit'
AESEncryptHandle.cpp:(.text+0x15c): undefined reference to `EVP_EncryptUpdate'
AESEncryptHandle.cpp:(.text+0x171): undefined reference to `EVP_EncryptFinal'
AESEncryptHandle.cpp:(.text+0x179): undefined reference to `EVP_CIPHER_CTX_cleanup'
./libmism.a(AESEncryptHandle.cpp.o): In function `AESEncryptHandle::Decrypt(char*, int&amp;, char const*, int const&amp;)':
AESEncryptHandle.cpp:(.text+0x215): undefined reference to `EVP_aes_256_ecb'
AESEncryptHandle.cpp:(.text+0x225): undefined reference to `EVP_DecryptInit'
AESEncryptHandle.cpp:(.text+0x23c): undefined reference to `EVP_DecryptUpdate'
AESEncryptHandle.cpp:(.text+0x251): undefined reference to `EVP_DecryptFinal'
AESEncryptHandle.cpp:(.text+0x259): undefined reference to `EVP_CIPHER_CTX_cleanup'
collect2: error: ld returned 1 exit status
</code></pre><p>这是加解密库是调用的openssl来实现的,而在go代码里只显示链接了加解密库</p>
<p><strong>解决方案</strong>
修改go代码,还要额外链接openssl的库.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="nx">cgo</span> <span class="nx">LDFLAGS</span><span class="p">:</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">2</span><span class="nx">nd</span><span class="o">/</span><span class="nx">crypto</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">openssl</span><span class="o">-</span><span class="nx">OpenSSL_1_0_2</span><span class="o">-</span><span class="nx">stable</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">lmism</span> <span class="o">-</span><span class="nx">lssl</span> <span class="o">-</span><span class="nx">lcrypto</span> <span class="o">-</span><span class="nx">lstdc</span><span class="o">++</span>
</code></pre></div><p>继续编译,又报了undefined reference</p>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_globallookup':
dso_dlfcn.c:(.text+0x11): undefined reference to `dlopen'
dso_dlfcn.c:(.text+0x24): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x2f): undefined reference to `dlclose'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_bind_func':
dso_dlfcn.c:(.text+0x354): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x412): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_bind_var':
dso_dlfcn.c:(.text+0x484): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x542): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_load':
dso_dlfcn.c:(.text+0x5a9): undefined reference to `dlopen'
dso_dlfcn.c:(.text+0x60d): undefined reference to `dlclose'
dso_dlfcn.c:(.text+0x645): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_pathbyaddr':
dso_dlfcn.c:(.text+0x6d1): undefined reference to `dladdr'
dso_dlfcn.c:(.text+0x731): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_unload':
dso_dlfcn.c:(.text+0x792): undefined reference to `dlclose'
collect2: error: ld returned 1 exit status
</code></pre><p>缺少ld引用.</p>
<p><strong>解决方案</strong>
修改go代码,还要额外链接ld的库.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="nx">cgo</span> <span class="nx">LDFLAGS</span><span class="p">:</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">2</span><span class="nx">nd</span><span class="o">/</span><span class="nx">crypto</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">openssl</span><span class="o">-</span><span class="nx">OpenSSL_1_0_2</span><span class="o">-</span><span class="nx">stable</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">lmism</span> <span class="o">-</span><span class="nx">lssl</span> <span class="o">-</span><span class="nx">lcrypto</span> <span class="o">-</span><span class="nx">lstdc</span><span class="o">++</span> <span class="o">-</span><span class="nx">ldl</span>
</code></pre></div><h3 id="类型映射错误">类型映射错误</h3>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./aesecb.go:16:10: assignment mismatch: 3 variables but _Cfunc_MIGetSafeHandle returns 1 values
./aesecb.go:17:18: cannot use uintptr(0) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MILoad
./aesecb.go:20:31: cannot use uintptr(unsafe.Pointer(&amp;iLen)) (type uintptr) as type *_Ctype_int in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:20:63: cannot use uintptr(unsafe.Pointer(&amp;msg[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:20:97: cannot use uintptr(srcLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:22:26: cannot use uintptr(unsafe.Pointer(&amp;buf[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:60: cannot use uintptr(iLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:75: cannot use uintptr(unsafe.Pointer(&amp;msg[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:109: cannot use uintptr(srcLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MITransEncrypt
./aesecb.go:27:31: cannot use uintptr(unsafe.Pointer(&amp;iDLen)) (type uintptr) as type *_Ctype_int in argument to _Cfunc_MIGetDecryptDataLen
./aesecb.go:27:31: too many errors
</code></pre><p>基本上都是用错了类型,参考类型映射来修改.</p>
<table>
<thead>
<tr>
<th style="text-align:left">C类型</th>
<th style="text-align:left">调用方法</th>
<th style="text-align:left">Go类型</th>
<th style="text-align:left">字节数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">C.char</td>
<td style="text-align:left">byte</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">signed char</td>
<td style="text-align:left">C.schar</td>
<td style="text-align:left">int8</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">C.uchar</td>
<td style="text-align:left">uint8</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">short int</td>
<td style="text-align:left">C.short</td>
<td style="text-align:left">int16</td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">short unsigned int</td>
<td style="text-align:left">C.ushort</td>
<td style="text-align:left">uint16</td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">C.int</td>
<td style="text-align:left">int</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">C.uint</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long int</td>
<td style="text-align:left">C.long</td>
<td style="text-align:left">int32 or int64</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long unsigned int</td>
<td style="text-align:left">C.ulong</td>
<td style="text-align:left">uint32 or uint64</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long long int</td>
<td style="text-align:left">C.longlong</td>
<td style="text-align:left">int64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long long unsigned int</td>
<td style="text-align:left">C.ulonglong</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">C.float</td>
<td style="text-align:left">float32</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">C.double</td>
<td style="text-align:left">float64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">wchar_t</td>
<td style="text-align:left">C.wchar_t</td>
<td style="text-align:left"></td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">void *</td>
<td style="text-align:left">unsafe.Pointer</td>
<td style="text-align:left"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>最后完整代码如下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>                                     

<span class="cm">/*                                               
</span><span class="cm">#cgo CFLAGS: -I../2nd/crypto/include
</span><span class="cm">#cgo LDFLAGS: -L../2nd/crypto/lib/Linux_x86_64 -L../3rd/openssl-OpenSSL_1_0_2-stable/lib/Linux_x86_64 -lmism -lssl -lcrypto -lstdc++ -ldl                    
</span><span class="cm">#include &#34;ISafeInterface.h&#34;                      
</span><span class="cm">*/</span>                                               
<span class="kn">import</span> <span class="s">&#34;C&#34;</span>                                       
<span class="kn">import</span> <span class="p">(</span>                                         
    <span class="s">&#34;fmt&#34;</span>                                        
    <span class="s">&#34;unsafe&#34;</span>                                     
<span class="p">)</span>                                                

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>                                    
    <span class="nx">msg</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;I am test trans crypto!&#34;</span><span class="p">)</span>  
    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetSafeHandle</span><span class="p">()</span>                     
    <span class="nx">C</span><span class="p">.</span><span class="nf">MILoad</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>                   
    <span class="kd">var</span> <span class="nx">iLen</span> <span class="kt">int32</span>                               
    <span class="kd">var</span> <span class="nx">srcLen</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>                    
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetEncryptDataLen</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="nx">iLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">44</span><span class="p">)</span>                      
    <span class="nx">C</span><span class="p">.</span><span class="nf">MITransEncrypt</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">iLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                             
                                                 
    <span class="nx">dstLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                           
    <span class="kd">var</span> <span class="nx">iDLen</span> <span class="kt">int32</span>                              
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetDecryptDataLen</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="nx">iDLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
                                                 
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">)</span>                           
    <span class="nx">newSrc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iDLen</span><span class="p">)</span>                
    <span class="nx">C</span><span class="p">.</span><span class="nf">MITransDecrypt</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newSrc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">newSrc</span><span class="p">))</span>                  
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIFreeSafeHandle</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="go-tool-cgo">go tool cgo</h3>
<p>调用该命令会在当前目录生成_obj文件夹,在里面文件可以看到类型转换的信息.<a href="https://wiki.jikexueyuan.com/project/go-command-tutorial/0.13.html">参考命令</a></p>
<pre><code># sky @ localhost in ~/go/path/src/aesecb/_obj [11:33:09] 
$ ll 
total 48
drwxr-xr-x 2 sky sky 4096 Sep 10 11:32 .
drwxr-xr-x 3 sky sky   92 Sep 10 11:32 ..
-rw-r--r-- 1 sky sky 6264 Sep 10 11:32 _cgo_.o
-rw-r--r-- 1 sky sky  605 Sep 10 11:32 _cgo_export.c
-rw-r--r-- 1 sky sky 1547 Sep 10 11:32 _cgo_export.h
-rw-r--r-- 1 sky sky   13 Sep 10 11:32 _cgo_flags
-rw-r--r-- 1 sky sky 5427 Sep 10 11:32 _cgo_gotypes.go
-rw-r--r-- 1 sky sky  416 Sep 10 11:32 _cgo_main.c
-rw-r--r-- 1 sky sky 2020 Sep 10 11:32 aesecb.cgo1.go
-rw-r--r-- 1 sky sky 5710 Sep 10 11:32 aesecb.cgo2.c
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
