<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Golangs on 深白色9527</title>
		<link>https://shenbaise9527.com/golang/</link>
		<description>Recent content in Golangs on 深白色9527</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 22 Nov 2020 11:41:27 +0800</lastBuildDate>
		<atom:link href="https://shenbaise9527.com/golang/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>golang数据类型</title>
			<link>https://shenbaise9527.com/golang/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
			<pubDate>Sun, 22 Nov 2020 11:41:27 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
			<description>主要包含基本的内建类型(布尔类型、数值类型和字符串类型)和复合类型(array、slice、map、channel、function、str</description>
			<content type="html"><![CDATA[<p>主要包含基本的内建类型(布尔类型、数值类型和字符串类型)和复合类型(array、slice、map、channel、function、struct、interface)</p>
<h2 id="基本数据类型">基本数据类型</h2>
<h3 id="布尔类型">布尔类型</h3>
<p>类型标记为bool，值为true/false，零值为false，<strong>值类型，可定义为常量</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 变量定义的几种方式
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">bflag</span> <span class="kt">bool</span>
<span class="nx">bflag</span> <span class="p">=</span> <span class="kc">true</span>

<span class="kd">var</span> <span class="nx">bflag1</span> <span class="kt">bool</span> <span class="p">=</span> <span class="kc">true</span>
<span class="kd">var</span> <span class="nx">bflag2</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c1">// 短变量声明,只能用于函数内部
</span><span class="c1"></span><span class="nx">bflag3</span> <span class="o">:=</span> <span class="kc">true</span>
</code></pre></div><h3 id="整数类型">整数类型</h3>
<p>类型标记为<strong>int/uint、int8/uint8、int16/uint16、int32/uint32、int64/uint64、byte、rune</strong>，零值为0，<strong>值类型，可定义为常量</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">标记符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int/uint</td>
<td style="text-align:left">有符号/无符号整数,依赖于CPU平台机器字大小,32或64bit</td>
</tr>
<tr>
<td style="text-align:left">int8/uint8</td>
<td style="text-align:left">有符号/无符号整数,8bit</td>
</tr>
<tr>
<td style="text-align:left">int16/uint16</td>
<td style="text-align:left">有符号/无符号整数,16bit</td>
</tr>
<tr>
<td style="text-align:left">int32/uint32</td>
<td style="text-align:left">有符号/无符号整数,32bit</td>
</tr>
<tr>
<td style="text-align:left">int64/uint64</td>
<td style="text-align:left">有符号/无符号整数,64bit</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">等价于uint8,一般用于强调数值是一个原始的数据而不是一个小的整数</td>
</tr>
<tr>
<td style="text-align:left">rune</td>
<td style="text-align:left">等价于int32,表示一个Unicode码点</td>
</tr>
</tbody>
</table>
<p>其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255</p>
<p>rune专门用来存储Unicode编码的单个字符，有5种表示方式：</p>
<ol>
<li>该rune字面量所对应的字符，比如&rsquo;a'、'-'，这个字符必须是Unicode编码规范所支持的</li>
<li>使用“\x”为前导后跟2位十六进制数，表示宽度为1字节</li>
<li>使用“\”为前导后跟3位八进制数，表示的范围与上一个表示法相同</li>
<li>使用“\u”为前导后跟4位十六进制数，表示宽度为2字节的值</li>
<li>使用“\U”为前导后跟8位十六进制数，表示宽度为4字节的值
<strong>还支持一类特殊的字符序列&mdash;-转义符</strong></li>
</ol>
<p>Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">*</span>      <span class="o">/</span>      <span class="o">%</span>      <span class="o">&lt;&lt;</span>       <span class="o">&gt;&gt;</span>     <span class="o">&amp;</span>       <span class="o">&amp;^</span>
<span class="o">+</span>      <span class="o">-</span>      <span class="p">|</span>      <span class="p">^</span>
<span class="o">==</span>     <span class="o">!=</span>     <span class="p">&lt;</span>      <span class="o">&lt;=</span>       <span class="p">&gt;</span>      <span class="o">&gt;=</span>
<span class="o">&amp;&amp;</span>
<span class="o">||</span>
</code></pre></div><p>整数的bit位操作符</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">&amp;</span>      <span class="nx">位运算</span> <span class="nx">AND</span>
<span class="p">|</span>      <span class="nx">位运算</span> <span class="nx">OR</span>
<span class="p">^</span>      <span class="nx">位运算</span> <span class="nx">XOR</span>
<span class="o">&amp;^</span>     <span class="nx">位清空</span> <span class="p">(</span><span class="nx">AND</span> <span class="nx">NOT</span><span class="p">)</span>
<span class="o">&lt;&lt;</span>     <span class="nx">左移</span>
<span class="o">&gt;&gt;</span>     <span class="nx">右移</span>
</code></pre></div><blockquote>
<p><strong>注意：</strong> ++/- -只能后置，且是语句不是表达式，不能进行赋值，即i++是合法，++i和j=i++都是非法的</p>
</blockquote>
<h3 id="浮点数类型">浮点数类型</h3>
<p>类型标记为<strong>float32/float64</strong>，零值为0，<strong>值类型，可定义为常量</strong></p>
<p>浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。</p>
<p>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（<strong>注意：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差</strong>）。</p>
<h3 id="复数类型">复数类型</h3>
<p>类型标记为<strong>complex64/complex128</strong>，<strong>值类型，可定义为常量</strong></p>
<h3 id="字符串类型">字符串类型</h3>
<p>类型标记为<strong>string</strong>，零值为&quot;&quot;，<strong>值类型，可定义为常量</strong></p>
<p>一个字符串是一个不可改变的字节序列</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;x&#39;</span> <span class="c1">// 非法，字符串是只读的
</span></code></pre></div><p>字符串在Go语言内存模型中用一个2字长的数据结构表示。它包含一个指向字符串存储数据的指针和一个长度数据。因为string类型是不可变的，对于多字符串共享同一个存储数据是安全的。切分操作会得到一个新的2字长结构字符串，但是指向同一个字节序列，切分时不涉及内存分配或复制操作。</p>
<h3 id="常量特别说明">常量特别说明</h3>
<p>常量只能是布尔类型、整数类型、浮点数类型、复数类型、字符串</p>
<p>常量生成器<strong>itoa</strong>，常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式</p>
<p>无类型常量：
Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是<strong>无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</strong>。
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 不需要类型转换
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>

<span class="c1">// 需要类型转换,Pi64定义了具体类型
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">Pi64</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">Pi64</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex128</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
</code></pre></div><h2 id="复合数据类型">复合数据类型</h2>
<h3 id="数组array">数组(array)</h3>
<p>固定长度的特定类型元素组成的序列，<strong>值类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>

<span class="c1">// 含有100个元素的数组，最后一个元素被初始化为-1，其余的为0
</span><span class="c1"></span><span class="nx">d</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">99</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

<span class="c1">// 支持切片操作
</span></code></pre></div><h3 id="切片slice">切片(slice)</h3>
<p>变长的序列，序列中每个元素都有相同的类型，一个slice类型一般写作[]T，其中T代表slice中元素的类型。
<strong>零值为nil，引用类型</strong></p>
<p>元素的底层存储结构为数组，一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度指目前slice中已有元素的数目；长度不能超过容量，容量指目前slice最多能存放的元素个数。内置的len和cap函数分别返回slice的长度和容量。</p>
<p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。</p>
<p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>    <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="kc">nil</span>        <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>    <span class="c1">// len(s) == 0, s != nil
</span></code></pre></div><p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
<span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</code></pre></div><p>当调用内置的append函数向slice追加元素时，如果元素数量超过容量，会引发扩容操作，此时slice的指针所指向的数组会发生变更</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// intslice为nil
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">intslice</span> <span class="p">[]</span><span class="kt">int64</span>
	
	<span class="c1">// intslice的长度和容量为4
</span><span class="c1"></span>	<span class="nx">intslice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intslice</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">intslice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">intslice</span><span class="p">))</span> <span class="c1">// output:4 4
</span><span class="c1"></span>	
	<span class="c1">// intslice会扩充，长度和容量变为8
</span><span class="c1"></span>	<span class="nx">intslice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intslice</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">intslice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">intslice</span><span class="p">))</span> <span class="c1">// output:8 8
</span><span class="c1"></span>	
	<span class="c1">// 通过切片操作赋值给is1，此时is1和intslice底层指向同一个数组
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="o">:=</span> <span class="nx">intslice</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 2 4
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33]
</span><span class="c1"></span>	
	<span class="c1">// is1追加一个元素，长度未超过容量，不会引起扩容，此时修改is1中的元素会影响intslice
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">is1</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 3 4
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33 99]
</span><span class="c1"></span>	<span class="c1">// intslice[3]也被修改为99了
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">intslice</span><span class="p">)</span> <span class="c1">// output: [11 22 33 99 55 66 77 88]
</span><span class="c1"></span>	
	<span class="c1">// 继续追加元素，超过了容量，引起扩容，is1和intslice此时底层指向不同的数组，对is1的操作不会影响intslice
</span><span class="c1"></span>	<span class="nx">is1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">is1</span><span class="p">,</span> <span class="mi">990</span><span class="p">,</span> <span class="mi">991</span><span class="p">,</span> <span class="mi">992</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">is1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">is1</span><span class="p">))</span> <span class="c1">// output: 6 8
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">is1</span><span class="p">)</span> <span class="c1">// output: [22 33 99 990 991 992]
</span><span class="c1"></span>	<span class="c1">// intslice并未被修改
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">intslice</span><span class="p">)</span> <span class="c1">// output: [11 22 33 99 55 66 77 88]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>遍历切片时可以直接采用下标也可以采用for-range的方式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int32</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>

	<span class="c1">// 针对切片的第一种遍历方式,直接采用下标访问
</span><span class="c1"></span>	<span class="nx">ssLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ssLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ss</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>

	<span class="c1">// 针对切片的第二种遍历方式,使用for-range,也是采用下标访问
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ss</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">))</span>
	<span class="c1">// 针对切片的第三种遍历方式,也是使用for-range,但采用索引+值的方式,下文中索引使用了_(忽略该参数)
</span><span class="c1"></span>	<span class="c1">// 需要注意value是个局部变量,生命周期归属这个for循环
</span><span class="c1"></span>	<span class="c1">// 迭代时只会改变value所对应的值,value本身只会被声明一次,即在整个for循环内其地址是不会改变的
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="cm">/* 注意和下面的go func方式进行比较
</span><span class="cm">		   此种方式在https://goplay.space/上一直输出的是5(即切片中的最后一个元素)
</span><span class="cm">		   但在本地windows下用vscode输出的结果是变化的,有时全部输出5,有时输出4和5...
</span><span class="cm">		   此种方式存在竞态
</span><span class="cm">		   使用go tool vet 可以进行检测：loop variable value captured by func literal
</span><span class="cm">		*/</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 此种方式在vscode上会直接显示告警 loop variable value captured by func literal
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;------&#34;</span><span class="p">)</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ss</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ss</span> <span class="p">{</span>
		<span class="c1">// 此种方式会把切片中的元素打印一遍
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="字典map">字典(map)</h3>
<p>map在底层是用哈希表实现的，哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p><strong>零值为nil，引用类型</strong></p>
<p>一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法。</p>
<p>可以通过内置函数make或字面值创建map</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 通过内置make来创建
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="c1">// 通过字面值创建,并初始化了2个元素
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">&#34;alice&#34;</span><span class="p">:</span>   <span class="mi">31</span><span class="p">,</span>
    <span class="s">&#34;charlie&#34;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 通过key的下标进行访问对应的value
</span><span class="c1"></span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">32</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">])</span> <span class="c1">// &#34;32&#34;
</span><span class="c1"></span>
<span class="c1">// 通过key来访问value时，若key不存在，也不会报错，而是会返回value对应的零值
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">])</span> <span class="c1">// &#34;0&#34;,bob并不存在于ages中,返回value的零值(0)
</span><span class="c1"></span><span class="nx">age</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span>  <span class="c1">// age=0
</span><span class="c1"></span>
<span class="c1">// 若key存在则ok为true;若key不存在则ok为false。可通过这种方式来判断key是不是存在
</span><span class="c1">// 判断一个元素是否存在必须采用此种方式，不能通过比较零值
</span><span class="c1"></span><span class="nx">age</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span>

<span class="c1">// 通过内置delete函数来删除元素
</span><span class="c1"></span><span class="nb">delete</span><span class="p">(</span><span class="nx">ages</span><span class="p">,</span> <span class="s">&#34;alice&#34;</span><span class="p">)</span>

<span class="c1">// 空的map
</span><span class="c1"></span><span class="nx">ages</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</code></pre></div><blockquote>
<p>**注意：**向一个nil值的map存入元素将导致一个panic异常</p>
</blockquote>
<p>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作。禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="c1">// compile error: cannot take address of map element
</span></code></pre></div><p>遍历map中全部的key/value对，可以使用range风格的for循环实现，和之前的slice遍历语法类似</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// name和age对应map中的key、value，迭代顺序是不确定的
</span><span class="c1"></span><span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ages</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\t%d\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</p>
<p>hash结构中直接使用的Bucket数组，而不是Bucket*指针的数据，是一段连续的内存空间。</p>
<p>每个bucket中存放最多8个key/value对, 如果多于8个，那么会申请一个新的bucket，并将它与之前的bucket链起来(<strong>称为溢出链overflow</strong>)，溢出链的Bucket的空间是使用mallocgc分配的。</p>
<p>hash结构采用的可扩展哈希的算法。由hash值mod当前hash表大小决定某一个值属于哪个桶，而hash表大小是2的指数(2^B)。每次扩容，会增大到上次大小的两倍。结构体中有一个buckets和一个oldbuckets是用来实现增量扩容的。正常情况下直接使用buckets，而oldbuckets为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</p>
<p>按key的类型采用相应的hash算法得到key的hash值。将hash值的低位当作hmap结构体中buckets数组的index，找到key所在的bucket。将hash的高8位存储在了bucket的tophash中。**注意，这里高8位不是用来当作key/value在bucket内部的offset的，而是作为一个主键，在查找时对tophash数组的每一项进行顺序匹配的。**先比较hash值高位与bucket的tophash[i]是否相等，如果相等则再比较bucket的第i个的key与所给的key是否相等。如果相等，则返回其对应的value，反之，在overflow buckets中按照上述方法继续寻找。</p>
<blockquote>
<p>**注意：**Bucket中key/value的放置顺序，是将keys放在一起，values放在一起，为什么不将key和对应的value放在一起呢？如果那么做，存储结构将变成key1/value1/key2/value2… 设想如果是这样的一个map[int64]int8，考虑到字节对齐，会浪费很多存储空间。不得不说通过上述的一个小细节，可以看出Go在设计上的深思熟虑。</p>
</blockquote>
<p>Go语言使用的是增量扩容。假设扩容之前容量为X，扩容之后容量为Y，对于某个哈希值hash，一般情况下(hash mod X)不等于(hash mod Y)，所以扩容之后要重新计算每一项在哈希表中的新位置。当hash表扩容之后，需要将那些旧的pair重新哈希到新的table上(源代码中称之为evacuate)， 这个工作并没有在扩容之后一次性完成，而是逐步的完成（在insert和remove时每次搬移1-2个pair），主要是为了缩短map容器的响应时间，避免扩容时阻塞(本质上还是将总的扩容时间分摊到了每一次哈希操作上面)。</p>
<blockquote>
<p>**注意：**如果key或value小于128字节，则它们的值是直接使用的bucket作为存储的。否则bucket中存储的是指向实际key/value数据的指针，</p>
</blockquote>
<h3 id="通道channel">通道(channel)</h3>
<p>类型标记为chan，它在栈上只是一个指针，实际的数据都是由指针所指向的堆上面。<strong>零值为nil，引用类型</strong></p>
<p>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 通过内置make函数创建chan
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 先声明，再创建
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 通过内置close函数关闭chan，此操作不是必须的，当没有被引用时，GC会回收
</span><span class="c1"></span><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</code></pre></div><p>channel创建时默认时双向的，但Go语言也提供了单向的channel，分别表示用于只发送或只接收的channel。类型<strong>chan&lt;- int</strong>表示一个只发送int的channel，只能发送不能接收。相反，类型**&lt;-chan int**表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向）这种限制将在编译期检测。</p>
<p>Go语言提供了无缓冲的channels和带缓冲的channels，在使用make创建时看是否提供了第二个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 无缓冲channel
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c1">// 带缓冲channel,容量为100
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">// 读channel时可忽略读取到的值
</span><span class="c1"></span><span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></div><ul>
<li>读或写一个nil的channel的操作会永远阻塞</li>
<li>读一个已关闭的channel会立刻返回一个channel元素类型的零值</li>
<li>写一个已关闭的channel会导致panic</li>
<li>无缓冲channel是同步的，若发送者和接受者不是同时存在，则读或写将被阻塞</li>
<li>有缓冲channel是异步的，当容量为满时写将被阻塞，当容量为空时读将被阻塞</li>
</ul>
<p>select-case 多路复用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="p">}()</span>

	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Commencing countdown. Please return to abort.&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
		<span class="cm">/* case后必须是channel变量的操作
</span><span class="cm">		   若不存在default分支且所有channel都未触发时，select将阻塞
</span><span class="cm">		   若存在default分支且所有channel都未触发时，会立即执行default分支
</span><span class="cm">		   若只有1个channel触发时，会立即执行对应的case分支代码
</span><span class="cm">		   若同时多个channel触发时，会随机选择执行其中一个对应的case分支代码
</span><span class="cm">		*/</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lauch aborted!&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">abort</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lauching.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 读取channel时可返回2个参数，ok表示是否读取成功，当fileSize被关闭时会立即返回false
</span><span class="c1"></span><span class="nx">fileSize</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
<span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSize</span>
</code></pre></div><p>for-range 迭代，可循环获取channel上的数据，若channel上没有数据会被阻塞。当channel被close后for-range结束循环迭代</p>
<h3 id="函数function">函数(function)</h3>
<p>类型标记为func，函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。<strong>零值为nil，引用类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">body</span>
<span class="p">}</span>

<span class="c1">// 当涉及多参数返回时，需要注意返回值类型是必须的，返回值命名是可选的（所有返回值要么都有命名，要么都没有）
</span><span class="c1">// 命名的返回值可以在函数内部作为变量来使用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="c1">// 以下2种声明是错误的
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span>
<span class="p">}</span>
</code></pre></div><p>函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p>
<p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// squares返回一个匿名函数。
</span><span class="c1">// 该匿名函数每次被调用时都会返回下一个数的平方。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">squares</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">++</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">squares</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;4&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;9&#34;
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1">// &#34;16&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><blockquote>
<p>**注意：**Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义</p>
</blockquote>
<h3 id="方法">方法</h3>
<p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;math&#34;</span>

<span class="c1">// 结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// 函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Point结构的一个方法,
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nf">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。可以任意的选择接收器的名字。</p>
<p>在方法调用过程中，接收器参数一般会在方法名之前出现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义Point类型的变量
</span><span class="c1"></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

<span class="c1">// 通过变量调用方法
</span><span class="c1"></span><span class="nx">r</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</code></pre></div><p>也可以采用指针来声明方法，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 方法的接收器类型是*Point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nf">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。</li>
<li>不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到。Point{1, 2}.ScaleBy(2)是非法的，编译会报错</li>
</ul>
<h3 id="结构体struct">结构体(struct)</h3>
<p>类型标记为struct，<strong>零值为结构中各成员变量所对应的零值，值类型</strong>
结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 定义了结构体Employee
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>        <span class="kt">int</span>
    <span class="nx">Name</span>      <span class="kt">string</span>
    <span class="nx">Address</span>   <span class="kt">string</span>
    <span class="nx">DoB</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">Position</span>  <span class="kt">string</span>
    <span class="nx">Salary</span>    <span class="kt">int</span>
    <span class="nx">ManagerID</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// 声明变量，类型为Employee
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">dilbert</span> <span class="nx">Employee</span>
</code></pre></div><p>dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 直接对每个成员赋值
</span><span class="c1"></span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">-=</span> <span class="mi">5000</span>

<span class="c1">// 对成员取地址，然后通过指针访问
</span><span class="c1"></span><span class="nx">position</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Position</span>
<span class="o">*</span><span class="nx">position</span> <span class="p">=</span> <span class="s">&#34;Senior &#34;</span> <span class="o">+</span> <span class="o">*</span><span class="nx">position</span>

<span class="c1">// 点操作符也可以和指向结构体的指针一起工作：
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">employeeOfTheMonth</span> <span class="o">*</span><span class="nx">Employee</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">dilbert</span>
<span class="nx">employeeOfTheMonth</span><span class="p">.</span><span class="nx">Position</span> <span class="o">+=</span> <span class="s">&#34; (proactive team player)&#34;</span>
</code></pre></div><blockquote>
<p>**注意：**结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p>
</blockquote>
<p>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 严格按照结构体定义的成员顺序
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>

<span class="c1">// 以成员名字和相应的值来初始化，可以包含部分或全部的成员，成员出现的顺序不重要
</span><span class="c1"></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// 初始化全部成员
</span><span class="c1"></span><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span> <span class="c1">// 初始化其中一个成员，其它成员默认为对应的零值
</span><span class="c1"></span>
<span class="c1">// 以上2种方式不能混用
</span></code></pre></div><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用= =或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员</p>
<p>Go语言提供的不同寻常的结构体嵌入机制，让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Circle</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span> <span class="c1">// 匿名嵌套
</span><span class="c1"></span>    <span class="nx">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Wheel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Circle</span> <span class="c1">// 匿名嵌套
</span><span class="c1"></span>    <span class="nx">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// 基于匿名嵌入的特性，可以直接访问叶子属性而不需要给出完整的路径
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Wheel</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>            <span class="c1">// 等价于w.Circle.Point.X = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>            <span class="c1">// 等价于w.Circle.Point.Y = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Radius</span> <span class="p">=</span> <span class="mi">5</span>       <span class="c1">// 等价于w.Circle.Radius = 5
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Spokes</span> <span class="p">=</span> <span class="mi">20</span>

<span class="c1">// 结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">}</span>                       <span class="c1">// compile error: unknown fields
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// compile error: unknown fields
</span><span class="c1"></span>
<span class="c1">// 正确的做法
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span>
    <span class="nx">Circle</span><span class="p">:</span> <span class="nx">Circle</span><span class="p">{</span>
        <span class="nx">Point</span><span class="p">:</span>  <span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
        <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="c1">// NOTE: 逗号是必须要的
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员。</p>
<p>但是在包外部，因为circle和point没有导出不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>
<p>目前描述的匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。匿名成员并不要求是结构体类型，其实任何命名的类型都可以作为结构体的匿名成员。</p>
<p><strong>简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心</strong></p>
<h3 id="接口interface">接口(interface)</h3>
<p>接口类型是一种抽象的类型，类型标记为interface，<strong>零值为nil，引用类型</strong></p>
<p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p>
<p>**依赖于接口而不是实现，优先使用组合而不是继承，这是程序抽象的基本原则。**但是长久以来以C++为代表的“面向对象”语言曲解了这些原则，让人们走入了误区。为什么要将方法和数据绑死？为什么要有多重继承这么变态的设计？面向对象中最强调的应该是对象间的消息传递，却为什么被演绎成了封装继承和多态。面向对象是否实现程序程序抽象的合理途径，又或者是因为它存在我们就认为它合理了。历史原因，中间出现了太多的错误。不管怎么样，Go的interface给我们打开了一扇新的窗。</p>
<blockquote>
<p>关于C++和面向对象的发展可以参考下孟岩的文章&ndash;<a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎</a></p>
</blockquote>
<p>interface实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。</p>
<blockquote>
<p>**注意：**空接口和带方法的接口底层结构略有不同，带方法的接口除了包含类型信息还需要包含具体类型中已实现的方法</p>
</blockquote>
<p>一个不包含任何值的nil接口和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。具体可参考官方文档，<a href="https://golang.google.cn/doc/faq#nil_error">国内链接</a> <a href="http://golang.org/doc/faq#nil_error">国外链接</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>  <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">Student</span>
	<span class="kd">var</span> <span class="nx">it</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="c1">// 此时it为nil.output: nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">it</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;non nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 赋值后it本身不为nil了,其类型字段指向了*Student,其值指向的是nil.output: non nil
</span><span class="c1"></span>	<span class="nx">it</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="k">if</span> <span class="nx">it</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;non nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 引用官方文档的例子，无论条件怎么变化始终会返回一个non-nil的error
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">returnsError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">MyError</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nf">bad</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">ErrBad</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span> <span class="c1">// Will always return a non-nil error.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>空的interface可以被当作任意类型来使用，它使得Go语言拥有了一定的动态性，但却又不损失静态语言在类型安全方面拥有的编译时检查的优势。</p>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之连接异常机制</title>
			<link>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 07 Nov 2020 13:27:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</guid>
			<description>连接server端失败的处理 重试机制 // 重点关注addrConn.resetTransport方法. func (ac *addrConn) resetTransport() { // 代码逻辑放在一个死循环里的. for</description>
			<content type="html"><![CDATA[<h2 id="连接server端失败的处理">连接server端失败的处理</h2>
<h3 id="重试机制">重试机制</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 重点关注addrConn.resetTransport方法.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 代码逻辑放在一个死循环里的.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">resolveNow</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">ResolveNowOptions</span><span class="p">{})</span>
		<span class="p">}</span>

        <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="c1">// 当连接关闭时直接返回.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>

        <span class="nx">addrs</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">addrs</span>
        <span class="c1">// 获取backoff时间,根据重试的次数会计算出不同的时间,算法后面重点关注.
</span><span class="c1"></span>		<span class="nx">backoffFor</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span><span class="p">.</span><span class="nf">Backoff</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span><span class="p">)</span>
        <span class="c1">// This will be the duration that dial gets to finish.
</span><span class="c1"></span>        <span class="c1">// 超时时间,默认20秒.
</span><span class="c1"></span>		<span class="nx">dialDuration</span> <span class="o">:=</span> <span class="nx">minConnectTimeout</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">minConnectTimeout</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">dialDuration</span> <span class="p">=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">minConnectTimeout</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dialDuration</span> <span class="p">&lt;</span> <span class="nx">backoffFor</span> <span class="p">{</span>
			<span class="c1">// Give dial more time as we keep failing to connect.
</span><span class="c1"></span>			<span class="nx">dialDuration</span> <span class="p">=</span> <span class="nx">backoffFor</span>
		<span class="p">}</span>
		<span class="c1">// We can potentially spend all the time trying the first address, and
</span><span class="c1"></span>		<span class="c1">// if the server accepts the connection and then hangs, the following
</span><span class="c1"></span>		<span class="c1">// addresses will never be tried.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// The spec doesn&#39;t mention what should be done for multiple addresses.
</span><span class="c1"></span>		<span class="c1">// https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md#proposed-backoff-algorithm
</span><span class="c1"></span>		<span class="nx">connectDeadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">dialDuration</span><span class="p">)</span>

        <span class="c1">// 更新状态为连接中.
</span><span class="c1"></span>		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

        <span class="c1">// 尝试连接服务端.
</span><span class="c1"></span>		<span class="nx">newTr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">reconnect</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">tryAllAddrs</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">connectDeadline</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// After exhausting all addresses, the addrConn enters
</span><span class="c1"></span>			<span class="c1">// TRANSIENT_FAILURE.
</span><span class="c1"></span>            <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
            <span class="c1">// 如果失败了,且状态为Shutdown直接返回.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span>
            <span class="p">}</span>
            <span class="c1">// 标记状态为失败.
</span><span class="c1"></span>			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

			<span class="c1">// Backoff.
</span><span class="c1"></span>			<span class="nx">b</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">resetBackoff</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

            <span class="c1">// 根据backoff时间创建定时器.
</span><span class="c1"></span>			<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">backoffFor</span><span class="p">)</span>
			<span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="c1">// backoff时间到,增加backoff次数,继续循环去尝试连接.
</span><span class="c1"></span>				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span><span class="o">++</span>
				<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">:</span>
                <span class="c1">// 外部重置了backoff,马上重新循环去尝试连接.
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="c1">// context取消了或超时了,直接返回.
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">newTr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">curAddr</span> <span class="p">=</span> <span class="nx">addr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="nx">newTr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span> <span class="p">=</span> <span class="mi">0</span>

		<span class="nx">hctx</span><span class="p">,</span> <span class="nx">hcancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">hctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Block until the created transport is down. And when this happens,
</span><span class="c1"></span>		<span class="c1">// we restart from the top of the addr list.
</span><span class="c1"></span>		<span class="o">&lt;-</span><span class="nx">reconnect</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">hcancel</span><span class="p">()</span>
		<span class="c1">// restart connecting - the top of the loop will set state to
</span><span class="c1"></span>		<span class="c1">// CONNECTING.  This is against the current connectivity semantics doc,
</span><span class="c1"></span>		<span class="c1">// however it allows for graceful behavior for RPCs not yet dispatched
</span><span class="c1"></span>		<span class="c1">// - unfortunate timing would otherwise lead to the RPC failing even
</span><span class="c1"></span>		<span class="c1">// though the TRANSIENT_FAILURE state (called for by the doc) would be
</span><span class="c1"></span>		<span class="c1">// instantaneous.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Ideally we should transition to Idle here and block until there is
</span><span class="c1"></span>		<span class="c1">// RPC activity that leads to the balancer requesting a reconnect of
</span><span class="c1"></span>		<span class="c1">// the associated SubConn.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>当连接失败后会等待一段时间之后再尝试重连,时间间隔的算法依赖于backoff.Strategy接口的Backoff方法.</li>
<li>利用context的超时控制或取消机制,直接结束.</li>
</ol>
<h3 id="backoff算法">Backoff算法</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在DialContext函数中,当没有设置bs自定义参数时,会默认设置为DefaultExponential.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">bs</span> <span class="p">=</span> <span class="nx">backoff</span><span class="p">.</span><span class="nx">DefaultExponential</span>
    <span class="p">}</span>
    
<span class="c1">// internal/backoffG/backoff.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DefaultExponential</span> <span class="p">=</span> <span class="nx">Exponential</span><span class="p">{</span><span class="nx">Config</span><span class="p">:</span> <span class="nx">grpcbackoff</span><span class="p">.</span><span class="nx">DefaultConfig</span><span class="p">}</span>

<span class="c1">// backoff/backoff.go
</span><span class="c1">// DefaultConfig is a backoff configuration with the default values specfied
</span><span class="c1">// at https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md.
</span><span class="c1">//
</span><span class="c1">// This should be useful for callers who want to configure backoff with
</span><span class="c1">// non-default values only for a subset of the options.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DefaultConfig</span> <span class="p">=</span> <span class="nx">Config</span><span class="p">{</span>
    <span class="c1">// 第一次失败之后的延迟时间.
</span><span class="c1"></span>    <span class="nx">BaseDelay</span><span class="p">:</span>  <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="c1">// 多次失败之后的时间乘数.
</span><span class="c1"></span>    <span class="nx">Multiplier</span><span class="p">:</span> <span class="mf">1.6</span><span class="p">,</span>
    <span class="c1">// 随机因子.
</span><span class="c1"></span>    <span class="nx">Jitter</span><span class="p">:</span>     <span class="mf">0.2</span><span class="p">,</span>
    <span class="c1">// 最大延迟时间.
</span><span class="c1"></span>	<span class="nx">MaxDelay</span><span class="p">:</span>   <span class="mi">120</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Backoff returns the amount of time to wait before the next retry given the
</span><span class="c1">// number of retries.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">bc</span> <span class="nx">Exponential</span><span class="p">)</span> <span class="nf">Backoff</span><span class="p">(</span><span class="nx">retries</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
    <span class="c1">// 当重试次数为0时直接返回BaseDelay,为1秒.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">retries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">BaseDelay</span>
	<span class="p">}</span>
	<span class="nx">backoff</span><span class="p">,</span> <span class="nx">max</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">BaseDelay</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">MaxDelay</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">backoff</span> <span class="p">&lt;</span> <span class="nx">max</span> <span class="o">&amp;&amp;</span> <span class="nx">retries</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 当backoff小于max且重试次数大于0时不断的乘以Multiplier.
</span><span class="c1"></span>		<span class="nx">backoff</span> <span class="o">*=</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Multiplier</span>
		<span class="nx">retries</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">backoff</span> <span class="p">=</span> <span class="nx">max</span>
    <span class="p">}</span>
    <span class="c1">// 对时间加上一个随机数.
</span><span class="c1"></span>	<span class="c1">// Randomize backoff delays so that if a cluster of requests start at
</span><span class="c1"></span>	<span class="c1">// the same time, they won&#39;t operate in lockstep.
</span><span class="c1"></span>	<span class="nx">backoff</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Jitter</span><span class="o">*</span><span class="p">(</span><span class="nx">grpcrand</span><span class="p">.</span><span class="nf">Float64</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">backoff</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>可以通过grpc.WithConnectParams和grpc.WithBackoff来设置自定义的backoff策略,在自定义策略里可以定义重试的时间间隔.</li>
<li>默认的backoff策略,第一次重试间隔为1秒,第二次为1*1.6+随机数&hellip;第N次为1*1.6^N +随机数(其中1*1.6^N最大不能超过120秒).</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之client和server的timetou机制</title>
			<link>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E5%92%8Cserver%E7%9A%84timetou%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 07 Nov 2020 13:22:04 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E5%92%8Cserver%E7%9A%84timetou%E6%9C%BA%E5%88%B6/</guid>
			<description>客户端超时的处理 客户端在调用rpc接口时带timeout的context是如何传递给服务端的. // 在调用对应的rpc方法时设置了超时时间为3秒</description>
			<content type="html"><![CDATA[<h2 id="客户端超时的处理">客户端超时的处理</h2>
<p>客户端在调用rpc接口时带timeout的context是如何传递给服务端的.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在调用对应的rpc方法时设置了超时时间为3秒.
</span><span class="c1"></span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
<span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;zhou&#34;</span><span class="p">})</span>

<span class="c1">// 调用SayHello方法最终会调用到invoke函数(call.go文件中).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 在newClientStream方法中会创建clientStream对象,ctx会赋值给该对象的ctx字段.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">ClientStream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">......</span>
    <span class="c1">// 前面代码都不关注,这里生成clientStream对象,关注其ctx字段.
</span><span class="c1"></span>	<span class="nx">cs</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">clientStream</span><span class="p">{</span>
		<span class="nx">callHdr</span><span class="p">:</span>      <span class="nx">callHdr</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>          <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">methodConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">mc</span><span class="p">,</span>
		<span class="nx">opts</span><span class="p">:</span>         <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">callInfo</span><span class="p">:</span>     <span class="nx">c</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">desc</span><span class="p">:</span>         <span class="nx">desc</span><span class="p">,</span>
		<span class="nx">codec</span><span class="p">:</span>        <span class="nx">c</span><span class="p">.</span><span class="nx">codec</span><span class="p">,</span>
		<span class="nx">cp</span><span class="p">:</span>           <span class="nx">cp</span><span class="p">,</span>
		<span class="nx">comp</span><span class="p">:</span>         <span class="nx">comp</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>       <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">beginTime</span><span class="p">:</span>    <span class="nx">beginTime</span><span class="p">,</span>
		<span class="nx">firstAttempt</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableRetry</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">retryThrottler</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="p">=</span> <span class="nx">binarylog</span><span class="p">.</span><span class="nf">GetMethodLogger</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span>

    <span class="c1">// 在newAttemptLocked中会通过负载均衡算法来选择Ready状态的连接.
</span><span class="c1"></span>	<span class="c1">// Only this initial attempt has stats/tracing.
</span><span class="c1"></span>	<span class="c1">// TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 在withRetry中最终会调用op函数,该函数会调用到csAttempt.newStream方法.
</span><span class="c1"></span>	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">newStream</span><span class="p">()</span> <span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">withRetry</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">bufferForRetryLocked</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="o">......</span>
    <span class="c1">// 下面的也不用关注了.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="nf">newStream</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">cs</span>
    <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span> <span class="p">=</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">numRetries</span>
    <span class="c1">// 这里会调用NewStream方法,t指向的是http2Client对象,cs是指向clientStream对象的.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">NewStream</span><span class="p">(</span><span class="nx">cs</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">PerformedIOError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Return without converting to an RPC error so retry code can
</span><span class="c1"></span>			<span class="c1">// inspect.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span><span class="p">.</span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">parser</span><span class="p">{</span><span class="nx">r</span><span class="p">:</span> <span class="nx">s</span><span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// NewStream creates a stream and registers it into the transport as &#34;active&#34;
</span><span class="c1">// streams.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Client</span><span class="p">)</span> <span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">callHdr</span> <span class="o">*</span><span class="nx">CallHdr</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">Stream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">peer</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getPeer</span><span class="p">())</span>
    <span class="c1">// 重点关注createHeaderFields,这个方法会处理HEADERS的数据,来传播表头数据.
</span><span class="c1"></span>    <span class="nx">headerFields</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">createHeaderFields</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">callHdr</span><span class="p">)</span>
    
    <span class="o">......</span>
    <span class="c1">// 下面的代码不关注.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Client</span><span class="p">)</span> <span class="nf">createHeaderFields</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">callHdr</span> <span class="o">*</span><span class="nx">CallHdr</span><span class="p">)</span> <span class="p">([]</span><span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 主要处理HEADERS头部数据.
</span><span class="c1"></span>    <span class="o">......</span>

    <span class="c1">// 支持的字段.
</span><span class="c1"></span>	<span class="nx">headerFields</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">hfLen</span><span class="p">)</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:method&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;POST&#34;</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:scheme&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">scheme</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:path&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">Method</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;:authority&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">Host</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;content-type&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">ContentType</span><span class="p">(</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">ContentSubtype</span><span class="p">)})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;user-agent&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">})</span>
	<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;te&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;trailers&#34;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-previous-rpc-attempts&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">PreviousAttempts</span><span class="p">)})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-encoding&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span><span class="p">})</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-accept-encoding&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">callHdr</span><span class="p">.</span><span class="nx">SendCompress</span><span class="p">})</span>
    <span class="p">}</span>
    
    <span class="c1">// 重点在这里,获取ctx的deadline时间,然后放入头部中的grpc-timeout字段中,客户端就是利用这个来吧超时时间传递到服务端的.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dl</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Send out timeout regardless its value. The server can detect timeout context by itself.
</span><span class="c1"></span>		<span class="c1">// TODO(mmukhi): Perhaps this field should be updated when actually writing out to the wire.
</span><span class="c1"></span>		<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">dl</span><span class="p">)</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-timeout&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">EncodeDuration</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">authData</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">callAuthData</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">OutgoingTags</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-tags-bin&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeBinHeader</span><span class="p">(</span><span class="nx">b</span><span class="p">)})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">OutgoingTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;grpc-trace-bin&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeBinHeader</span><span class="p">(</span><span class="nx">b</span><span class="p">)})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">added</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromOutgoingContextRaw</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">k</span> <span class="kt">string</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">md</span> <span class="p">{</span>
			<span class="c1">// HTTP doesn&#39;t allow you to set pseudoheaders after non pseudoheaders were set.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">added</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">k</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="c1">// HTTP doesn&#39;t allow you to set pseudoheaders after non pseudoheaders were set.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">md</span><span class="p">.(</span><span class="o">*</span><span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="nx">md</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nf">isReservedHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="nx">headerFields</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">headerFields</span><span class="p">,</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nf">encodeMetadataHeader</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)})</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">headerFields</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><strong>总结</strong></p>
<ol>
<li>在调用rpc接口时设置了超时的context,会最终传递到http2Client对象中,然后在处理HEADERS时会把deadline时间设置到头部参数<code>grpc-timeout</code>中,传递到服务端.</li>
<li>http2Client对象是在调用<code>Dial</code>或<code>DialContext</code>过程中生成的,每个Endpoint对应一个该对象.</li>
</ol>
<h2 id="服务端超时处理">服务端超时处理</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HandleStreams receives incoming streams using the given handler. This is
</span><span class="c1">// typically run in a separate goroutine.
</span><span class="c1">// traceCtx attaches trace to ctx and returns the new context.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">HandleStreams</span><span class="p">(</span><span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">readerDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 该函数主要接收客户端发送过来的数据,重点关注处理HEADERS部分的数据.
</span><span class="c1"></span>        <span class="o">......</span>

		<span class="k">switch</span> <span class="nx">frame</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">:</span>
            <span class="c1">// 当frame类型为HEADERS时的处理.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="nx">handle</span><span class="p">,</span> <span class="nx">traceCtx</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">break</span>
            <span class="p">}</span>
            
        <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// operateHeader takes action on the decoded headers.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">,</span> <span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">fatal</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">streamID</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nx">StreamID</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">decodeState</span><span class="p">{</span>
		<span class="nx">serverSide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// 获取HEADERS里的数据.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h2code</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">decodeHeader</span><span class="p">(</span><span class="nx">frame</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">FromError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">controlBuf</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cleanupStream</span><span class="p">{</span>
				<span class="nx">streamID</span><span class="p">:</span> <span class="nx">streamID</span><span class="p">,</span>
				<span class="nx">rst</span><span class="p">:</span>      <span class="kc">true</span><span class="p">,</span>
				<span class="nx">rstCode</span><span class="p">:</span>  <span class="nx">h2code</span><span class="p">,</span>
				<span class="nx">onWrite</span><span class="p">:</span>  <span class="kd">func</span><span class="p">()</span> <span class="p">{},</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">buf</span> <span class="o">:=</span> <span class="nf">newRecvBuffer</span><span class="p">()</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Stream</span><span class="p">{</span>
		<span class="nx">id</span><span class="p">:</span>             <span class="nx">streamID</span><span class="p">,</span>
		<span class="nx">st</span><span class="p">:</span>             <span class="nx">t</span><span class="p">,</span>
		<span class="nx">buf</span><span class="p">:</span>            <span class="nx">buf</span><span class="p">,</span>
		<span class="nx">fc</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">inFlow</span><span class="p">{</span><span class="nx">limit</span><span class="p">:</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">initialWindowSize</span><span class="p">)},</span>
		<span class="nx">recvCompress</span><span class="p">:</span>   <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span>
		<span class="nx">method</span><span class="p">:</span>         <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span>
		<span class="nx">contentSubtype</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">contentSubtype</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">StreamEnded</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// s is just created by the caller. No lock needed.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">streamReadDone</span>
    <span class="p">}</span>
    <span class="c1">// 当有设置超时时,Stream对象的ctx设置为Timeout的.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeoutSet</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">decodeState</span><span class="p">)</span> <span class="nf">decodeHeader</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">)</span> <span class="p">(</span><span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// frame.Truncated is set to true when framer detects that the current header
</span><span class="c1"></span>	<span class="c1">// list size hits MaxHeaderListSize limit.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Truncated</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCodeFrameSize</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Internal</span><span class="p">,</span> <span class="s">&#34;peer header list size exceeded limit&#34;</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 处理HEADERS.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">hf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Fields</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nf">processHeaderField</span><span class="p">(</span><span class="nx">hf</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>

	<span class="k">return</span> <span class="nx">http2</span><span class="p">.</span><span class="nx">ErrCodeProtocol</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nf">constructHTTPErrMsg</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">decodeState</span><span class="p">)</span> <span class="nf">processHeaderField</span><span class="p">(</span><span class="nx">f</span> <span class="nx">hpack</span><span class="p">.</span><span class="nx">HeaderField</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Name</span> <span class="p">{</span>
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>

    <span class="k">case</span> <span class="s">&#34;grpc-timeout&#34;</span><span class="p">:</span>
        <span class="c1">// 如果有该字段,解析超时时间,在这里就和客户端联系起来了.
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeoutSet</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">timeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">decodeTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">grpcErr</span> <span class="p">=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Internal</span><span class="p">,</span> <span class="s">&#34;transport: malformed time-out: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="c1">// 其它暂不关注.
</span><span class="c1"></span>    <span class="o">......</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 经过上述分析,带超时的context已经赋值给Stream的ctx字段了.
</span><span class="c1">// 最后这个ctx会被传递给RPC接口的第一个参数,这样在服务端的接口中就能感知到超时了.
</span></code></pre></div><p><strong>总结</strong></p>
<ol>
<li>服务端在收到HEADERS之后,会解析所有参数,如果有<code>grpc-timeout</code>,就会设置一个带timeout的context,然后传递到rpc接口中.</li>
</ol>
<h2 id="抓包">抓包</h2>
<p><img src="/images/grpc-timeout.png" alt="timeout" title="带timeout的HEADERS">
从图中可以看到HEADERS中有参数<code>grpc-timeout</code>,值为2994000u,超时时间为2994毫秒.</p>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之client端调用</title>
			<link>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E7%AB%AF%E8%B0%83%E7%94%A8/</link>
			<pubDate>Sat, 07 Nov 2020 13:16:47 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bclient%E7%AB%AF%E8%B0%83%E7%94%A8/</guid>
			<description>Dail/DailContext与服务端建立连接 // 直接调用的DialContext. // Dial creates a client connection to the given target. func Dial(target string, opts ...DialOption) (*ClientConn, error) { return DialContext(context.Background(), target, opts...) } // Dial</description>
			<content type="html"><![CDATA[<h2 id="daildailcontext与服务端建立连接">Dail/DailContext与服务端建立连接</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 直接调用的DialContext.
</span><span class="c1">// Dial creates a client connection to the given target.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Dial</span><span class="p">(</span><span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DialContext默认是非阻塞的,不会等待连接成功,而是在后台处理连接逻辑.可以用grpc.WithBlock()来设置为阻塞的.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 生成conn.
</span><span class="c1"></span>	<span class="nx">cc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClientConn</span><span class="p">{</span>
		<span class="nx">target</span><span class="p">:</span>            <span class="nx">target</span><span class="p">,</span>
		<span class="nx">csMgr</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">connectivityStateManager</span><span class="p">{},</span>
		<span class="nx">conns</span><span class="p">:</span>             <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">dopts</span><span class="p">:</span>             <span class="nf">defaultDialOptions</span><span class="p">(),</span>
		<span class="nx">blockingpicker</span><span class="p">:</span>    <span class="nf">newPickerWrapper</span><span class="p">(),</span>
		<span class="nx">czData</span><span class="p">:</span>            <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
		<span class="nx">firstResolveEvent</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>

    <span class="c1">// 处理DiaoOption,来设置自定义参数.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nx">opt</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 处理一元RPC的拦截器.
</span><span class="c1"></span>	<span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
    <span class="c1">// 处理流式RPC的拦截器.
</span><span class="c1"></span>	<span class="nf">chainStreamClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">cc</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">......</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">insecure</span> <span class="p">{</span>
        <span class="c1">// 校验认证相关.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errCredentialsConflict</span>
        <span class="p">}</span>
        <span class="c1">// PerRPCCredentials是指设置了自定义认证.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cd</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">PerRPCCredentials</span> <span class="p">{</span>
            <span class="c1">// 判断自定义认证是否依赖TLS.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">cd</span><span class="p">.</span><span class="nf">RequireTransportSecurity</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTransportCredentialsMissing</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="o">......</span>

    <span class="c1">// 超时控制.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">timeout</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">cancel</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span>
		<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span> <span class="o">==</span> <span class="nx">err</span><span class="p">:</span>
				<span class="nx">conn</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">case</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">returnLastError</span><span class="p">:</span>
				<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v: %v&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}()</span>

    <span class="o">......</span>

    <span class="c1">// 解析target的格式,识别出对应的Scheme和Endpoint.
</span><span class="c1"></span>	<span class="c1">// Determine the resolver to use.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">ParseTarget</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
	<span class="nx">unixScheme</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="s">&#34;unix:&#34;</span><span class="p">)</span>
    <span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;parsed scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
    
    <span class="c1">// 根据Scheme来获取对应的Resolver.
</span><span class="c1"></span>    <span class="c1">// 如gRPC默认支持的dns,就是在dns包的init函数中调用了resolver.Register()来注册dns Resolver.
</span><span class="c1"></span>	<span class="nx">resolverBuilder</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果获取失败,就采用默认的Resolver来解析,即passthrough.
</span><span class="c1"></span>		<span class="c1">// If resolver builder is still nil, the parsed target&#39;s scheme is
</span><span class="c1"></span>		<span class="c1">// not registered. Fallback to default resolver and set Endpoint to
</span><span class="c1"></span>		<span class="c1">// the original target.
</span><span class="c1"></span>		<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;scheme %q not registered, fallback to default scheme&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">{</span>
			<span class="nx">Scheme</span><span class="p">:</span>   <span class="nx">resolver</span><span class="p">.</span><span class="nf">GetDefaultScheme</span><span class="p">(),</span>
			<span class="nx">Endpoint</span><span class="p">:</span> <span class="nx">target</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">resolverBuilder</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;could not get resolver for default scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="o">......</span>
    <span class="c1">// 认证相关.
</span><span class="c1"></span>    <span class="c1">// banlancer的相关Option.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span> <span class="p">=</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DialCreds</span><span class="p">:</span>        <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>      <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
		<span class="nx">ChannelzParentID</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span>
		<span class="nx">Target</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span>
	<span class="p">}</span>

    <span class="c1">// 调用Resolver对象的Build方法,在Build内部会调用cc.UpdateState来更新服务端地址.
</span><span class="c1"></span>	<span class="c1">// Build the resolver.
</span><span class="c1"></span>	<span class="nx">rWrapper</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">resolverBuilder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to build resolver: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">resolverWrapper</span> <span class="p">=</span> <span class="nx">rWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="c1">// 当调用grpc.WithBlock()后会阻塞直到连接成功建立.
</span><span class="c1"></span>	<span class="c1">// A blocking dial blocks until the clientConn is ready.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">block</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
            <span class="c1">// 循环判断连接的状态是否为Ready.
</span><span class="c1"></span>			<span class="nx">s</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">GetState</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">FailOnNonTempDialError</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">connectionError</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">terr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">interface</span> <span class="p">{</span>
						<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span>
					<span class="p">})</span>
					<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">terr</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
						<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// ctx got timeout or canceled.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">connectionError</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">returnLastError</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">cc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// newCCResolverWrapper uses the resolver.Builder to build a Resolver and
</span><span class="c1">// returns a ccResolverWrapper object which wraps the newly built resolver.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">rb</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Builder</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ccr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccResolverWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>   <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">done</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">credsClone</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span>
	<span class="k">if</span> <span class="nx">creds</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">;</span> <span class="nx">creds</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">credsClone</span> <span class="p">=</span> <span class="nx">creds</span><span class="p">.</span><span class="nf">Clone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">rbo</span> <span class="o">:=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DisableServiceConfig</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span><span class="p">,</span>
		<span class="nx">DialCreds</span><span class="p">:</span>            <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>          <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>               <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// We need to hold the lock here while we assign to the ccr.resolver field
</span><span class="c1"></span>	<span class="c1">// to guard against a data race caused by the following code path,
</span><span class="c1"></span>	<span class="c1">// rb.Build--&gt;ccr.ReportError--&gt;ccr.poll--&gt;ccr.resolveNow, would end up
</span><span class="c1"></span>	<span class="c1">// accessing ccr.resolver which is being assigned here.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 主要是调用对应的Resolver的Build方法.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolver</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rb</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span> <span class="nx">ccr</span><span class="p">,</span> <span class="nx">rbo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ccr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 下面以gRPC默认的dns Resolver举例.
</span><span class="c1">// Build creates and starts a DNS resolver that watches the name resolution of the target.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">dnsBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">target</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">,</span> <span class="nx">cc</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Resolver</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseTarget</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">Endpoint</span><span class="p">,</span> <span class="nx">defaultPort</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 支持IP地址形式的target.
</span><span class="c1"></span>	<span class="c1">// IP address.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ipAddr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">formatIP</span><span class="p">(</span><span class="nx">host</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">addr</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{{</span><span class="nx">Addr</span><span class="p">:</span> <span class="nx">ipAddr</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="nx">port</span><span class="p">}}</span>
        <span class="c1">// 调用cc.UpdateState,cc实际上是ccResolverWrapper对象.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">Addresses</span><span class="p">:</span> <span class="nx">addr</span><span class="p">})</span>
		<span class="k">return</span> <span class="nx">deadResolver</span><span class="p">{},</span> <span class="kc">nil</span>
	<span class="p">}</span>

    <span class="c1">// 需要进行dns解析.
</span><span class="c1"></span>	<span class="c1">// DNS address (non-IP).
</span><span class="c1"></span>	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dnsResolver</span><span class="p">{</span>
		<span class="nx">host</span><span class="p">:</span>                 <span class="nx">host</span><span class="p">,</span>
		<span class="nx">port</span><span class="p">:</span>                 <span class="nx">port</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>                  <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>               <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>                   <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">rn</span><span class="p">:</span>                   <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">disableServiceConfig</span><span class="p">:</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">DisableServiceConfig</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Authority</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">resolver</span> <span class="p">=</span> <span class="nx">defaultResolver</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">resolver</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">customAuthorityResolver</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">Authority</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="nx">d</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 具体的解析过程在watcher中,解析成功后也会调用cc.UpdateState.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">watcher</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">ResolveNow</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">ResolveNowOptions</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有Resolver的Build方法都会来调用到UpdateState方法.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccr</span> <span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">)</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;ccResolverWrapper: sending update to cc: %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ccr</span><span class="p">.</span><span class="nf">addChannelzTraceEvent</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span> <span class="p">=</span> <span class="nx">s</span>
    <span class="c1">// 主要关注updateResolverState,ccr.cc是ClientConn对象.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nf">poll</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">firstResolveEvent</span><span class="p">.</span><span class="nf">Fire</span><span class="p">()</span>
    <span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

    <span class="o">......</span>

	<span class="kd">var</span> <span class="nx">ret</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 没有设置ServiceConfig,进入到该分支,主要处理balancer对象.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span>
		<span class="c1">// TODO: do we need to apply a failing LB policy if there is no
</span><span class="c1"></span>		<span class="c1">// default, per the error handling design?
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">......</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">balCfg</span> <span class="nx">serviceconfig</span><span class="p">.</span><span class="nx">LoadBalancingConfig</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">balCfg</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span><span class="p">.</span><span class="nx">cfg</span>
	<span class="p">}</span>

	<span class="nx">cbn</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span>
	<span class="nx">bw</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">cbn</span> <span class="o">!=</span> <span class="nx">grpclbName</span> <span class="p">{</span>
		<span class="c1">// Filter any grpclb addresses since we don&#39;t have the grpclb balancer.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">);</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">GRPCLB</span> <span class="p">{</span>
				<span class="nb">copy</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 主要处理连接的逻辑,在后面要重点关注.
</span><span class="c1"></span>	<span class="nx">uccsErr</span> <span class="o">:=</span> <span class="nx">bw</span><span class="p">.</span><span class="nf">updateClientConnState</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">{</span><span class="nx">ResolverState</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">BalancerConfig</span><span class="p">:</span> <span class="nx">balCfg</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">uccsErr</span> <span class="c1">// prefer ErrBadResolver state since any other error is
</span><span class="c1"></span>		<span class="c1">// currently meaningless to the caller.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 默认会走到该分支.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">emptyServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">ServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// should never reach here.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="p">=</span> <span class="nx">sc</span>

    <span class="o">......</span>

	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Only look at balancer types and switch balancer if balancer dial
</span><span class="c1"></span>		<span class="c1">// option is not set.
</span><span class="c1"></span>        <span class="o">......</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Balancer dial option was set, and this is the first time handling
</span><span class="c1"></span>        <span class="c1">// resolved addresses. Build a balancer with dopts.balancerBuilder.
</span><span class="c1"></span>        <span class="c1">// 调用grpc.WithBalancerName()设置了balancerBuiler,进入该分支.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="p">=</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Builder</span><span class="p">,</span> <span class="nx">bopts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span> <span class="p">{</span>
	<span class="nx">ccb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccBalancerWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>       <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">scBuffer</span><span class="p">:</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">NewUnbounded</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">subConns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
    <span class="p">}</span>
    <span class="c1">// watcher会持续观察连接的状态变更,重点关注.
</span><span class="c1"></span>    <span class="k">go</span> <span class="nx">ccb</span><span class="p">.</span><span class="nf">watcher</span><span class="p">()</span>
    <span class="c1">// 调用banlancer.Builder对象的Build方法来构建banlancer.
</span><span class="c1"></span>    <span class="c1">// 注意banlancer.Builder和base.PickerBuilder这两个接口.
</span><span class="c1"></span>    <span class="c1">// 自定义的负载均衡算法一般都是实现PickerBuilder或V2PickerBuilder接口,再通过base.NewBalancerBuilder包装成banlancer.Builder接口,实际对象是base.baseBuilder,这里Build返回的实际是base.baseBalancer对象(其实现了balancer.Balancer接口).
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">ccb</span><span class="p">,</span> <span class="nx">bopts</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ccb</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">bb</span> <span class="o">*</span><span class="nx">baseBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opt</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Balancer</span> <span class="p">{</span>
    <span class="c1">// 返回的是baseBalancer对象.
</span><span class="c1"></span>	<span class="nx">bal</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">baseBalancer</span><span class="p">{</span>
        <span class="c1">// 这里cc对象是ccBalancerWrapper.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">:</span>              <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">pickerBuilder</span><span class="p">:</span>   <span class="nx">bb</span><span class="p">.</span><span class="nx">pickerBuilder</span><span class="p">,</span>
		<span class="nx">v2PickerBuilder</span><span class="p">:</span> <span class="nx">bb</span><span class="p">.</span><span class="nx">v2PickerBuilder</span><span class="p">,</span>

		<span class="nx">subConns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">),</span>
		<span class="nx">scStates</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">]</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">),</span>
		<span class="nx">csEvltr</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ConnectivityStateEvaluator</span><span class="p">{},</span>
		<span class="nx">config</span><span class="p">:</span>   <span class="nx">bb</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c1">// Initialize picker to a picker that always returns
</span><span class="c1"></span>	<span class="c1">// ErrNoSubConnAvailable, because when state of a SubConn changes, we
</span><span class="c1"></span>	<span class="c1">// may call UpdateState with this picker.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">bb</span><span class="p">.</span><span class="nx">pickerBuilder</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 当前还没有与服务端建立连接,先设置一个返回error的Picker对象.
</span><span class="c1"></span>		<span class="nx">bal</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">bal</span><span class="p">.</span><span class="nx">v2Picker</span> <span class="p">=</span> <span class="nf">NewErrPickerV2</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">updateClientConnState</span><span class="p">(</span><span class="nx">ccs</span> <span class="o">*</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 调用了Balancer接口的方法,这里实际上是base.baseBalancer对象.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="o">*</span><span class="nx">ccs</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// TODO: handle s.ResolverState.ServiceConfig?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;base.baseBalancer: got new ClientConn state: &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Successful resolution; clear resolver error and ensure we return nil.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">resolverErr</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// addrsSet is the set converted from addrs, it&#39;s used for quick lookup of an address.
</span><span class="c1"></span>	<span class="nx">addrsSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">{</span>
		<span class="nx">addrsSet</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 创建连接,会调用到ccBalancerWrapper的NewSubConn方法,返回的实际上acBalancerWrapper对象.
</span><span class="c1"></span>			<span class="c1">// a is a new address (not existing in b.subConns).
</span><span class="c1"></span>			<span class="nx">sc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">NewSubConn</span><span class="p">([]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{</span><span class="nx">a</span><span class="p">},</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">NewSubConnOptions</span><span class="p">{</span><span class="nx">HealthCheckEnabled</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">HealthCheck</span><span class="p">})</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">logger</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;base.baseBalancer: failed to create new SubConn: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sc</span>
            <span class="c1">// 初始状态默认为空闲.
</span><span class="c1"></span>            <span class="nx">b</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span>
            <span class="c1">// 连接服务端.
</span><span class="c1"></span>			<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
		<span class="c1">// a was removed by resolver.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">addrsSet</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">RemoveSubConn</span><span class="p">(</span><span class="nx">sc</span><span class="p">)</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
			<span class="c1">// Keep the state of this sc in b.scStates until sc&#39;s state becomes Shutdown.
</span><span class="c1"></span>			<span class="c1">// The entry will be deleted in UpdateSubConnState.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// If resolver state contains no addresses, return an error so ClientConn
</span><span class="c1"></span>	<span class="c1">// will trigger re-resolve. Also records this as an resolver error, so when
</span><span class="c1"></span>	<span class="c1">// the overall state turns transient failure, the error message will have
</span><span class="c1"></span>	<span class="c1">// the zero address information.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">ResolverError</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;produced zero addresses&#34;</span><span class="p">))</span>
		<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrBadResolverState</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 建立连接.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">acbw</span> <span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">)</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">ac</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 最终会调用到这个connect方法.
</span><span class="c1">// connect starts creating a transport.
</span><span class="c1">// It does nothing if the ac is not IDLE.
</span><span class="c1">// TODO(bar) Move this to the addrConn section.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">connect</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">errConnClosing</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// Update connectivity state within the lock to prevent subsequent or
</span><span class="c1"></span>	<span class="c1">// concurrent calls from resetting the transport more than once.
</span><span class="c1"></span>	<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="c1">// 采用异步的方式来与服务端建立连接的.
</span><span class="c1"></span>    <span class="c1">// Start a goroutine connecting to the server asynchronously.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">resetTransport</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

        <span class="o">......</span>

        <span class="c1">// 尝试去建立连接.
</span><span class="c1"></span>		<span class="nx">newTr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">reconnect</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">tryAllAddrs</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">connectDeadline</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 错误处理.
</span><span class="c1"></span>            <span class="o">......</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">newTr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">curAddr</span> <span class="p">=</span> <span class="nx">addr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="p">=</span> <span class="nx">newTr</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">backoffIdx</span> <span class="p">=</span> <span class="mi">0</span>

        <span class="nx">hctx</span><span class="p">,</span> <span class="nx">hcancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
        <span class="c1">// 重点关注startHealthCheck方法.
</span><span class="c1"></span>		<span class="nx">ac</span><span class="p">.</span><span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">hctx</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Block until the created transport is down. And when this happens,
</span><span class="c1"></span>		<span class="c1">// we restart from the top of the addr list.
</span><span class="c1"></span>		<span class="o">&lt;-</span><span class="nx">reconnect</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">hcancel</span><span class="p">()</span>
		<span class="c1">// restart connecting - the top of the loop will set state to
</span><span class="c1"></span>		<span class="c1">// CONNECTING.  This is against the current connectivity semantics doc,
</span><span class="c1"></span>		<span class="c1">// however it allows for graceful behavior for RPCs not yet dispatched
</span><span class="c1"></span>		<span class="c1">// - unfortunate timing would otherwise lead to the RPC failing even
</span><span class="c1"></span>		<span class="c1">// though the TRANSIENT_FAILURE state (called for by the doc) would be
</span><span class="c1"></span>		<span class="c1">// instantaneous.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Ideally we should transition to Idle here and block until there is
</span><span class="c1"></span>		<span class="c1">// RPC activity that leads to the balancer requesting a reconnect of
</span><span class="c1"></span>		<span class="c1">// the associated SubConn.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// startHealthCheck starts the health checking stream (RPC) to watch the health
</span><span class="c1">// stats of this connection if health checking is requested and configured.
</span><span class="c1">//
</span><span class="c1">// LB channel health checking is enabled when all requirements below are met:
</span><span class="c1">// 1. it is not disabled by the user with the WithDisableHealthCheck DialOption
</span><span class="c1">// 2. internal.HealthCheckFunc is set by importing the grpc/health package
</span><span class="c1">// 3. a service config with non-empty healthCheckConfig field is provided
</span><span class="c1">// 4. the load balancer requests it
</span><span class="c1">//
</span><span class="c1">// It sets addrConn to READY if the health checking stream is not started.
</span><span class="c1">//
</span><span class="c1">// Caller must hold ac.mu.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">startHealthCheck</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 整个函数的重点是调用ac.updateConnecttivityState来设置状态.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">healthcheckManagingState</span> <span class="kt">bool</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">healthcheckManagingState</span> <span class="p">{</span>
            <span class="c1">// 设置连接状态为Ready.
</span><span class="c1"></span>			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableHealthCheck</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 若没有设置healthCheckConfig直接返回.
</span><span class="c1"></span>	<span class="nx">healthCheckConfig</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">healthCheckConfig</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">healthCheckConfig</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ac</span><span class="p">.</span><span class="nx">scopts</span><span class="p">.</span><span class="nx">HealthCheckEnabled</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">healthCheckFunc</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">healthCheckFunc</span>
	<span class="k">if</span> <span class="nx">healthCheckFunc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// The health package is not imported to set health check function.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// TODO: add a link to the health check doc in the error message.
</span><span class="c1"></span>		<span class="nx">channelz</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Health check is requested but health check function is not set.&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">healthcheckManagingState</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Set up the health check helper functions.
</span><span class="c1"></span>	<span class="nx">currentTr</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span>
	<span class="nx">newStream</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="o">!=</span> <span class="nx">currentTr</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Canceled</span><span class="p">,</span> <span class="s">&#34;the provided transport is no longer valid to use&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nf">newNonRetryClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">StreamDesc</span><span class="p">{</span><span class="nx">ServerStreams</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">currentTr</span><span class="p">,</span> <span class="nx">ac</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// headlthCheckFunc最终会调用到下面的函数,来设置连接状态.
</span><span class="c1"></span>	<span class="nx">setConnectivityState</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">lastErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">transport</span> <span class="o">!=</span> <span class="nx">currentTr</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">lastErr</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Start the health checking stream.
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// healthCheckFunc默认值是health.clientHealthCheck函数(health/client.go文件中).
</span><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">healthCheckFunc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">newStream</span><span class="p">,</span> <span class="nx">setConnectivityState</span><span class="p">,</span> <span class="nx">healthCheckConfig</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Code</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">==</span> <span class="nx">codes</span><span class="p">.</span><span class="nx">Unimplemented</span> <span class="p">{</span>
				<span class="nx">channelz</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Subchannel health check is unimplemented at server side, thus health check is disabled&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">channelz</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;HealthCheckFunc exits with unexpected error %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="c1">// Note: this requires a lock on ac.mu.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">lastErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Subchannel Connectivity change to %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">acbw</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">lastErr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// TODO(bar switching) send updates to all balancer wrappers when balancer
</span><span class="c1"></span>	<span class="c1">// gracefully switching is supported.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// When updating addresses for a SubConn, if the address in use is not in
</span><span class="c1"></span>	<span class="c1">// the new addresses, the old ac will be tearDown() and a new ac will be
</span><span class="c1"></span>	<span class="c1">// created. tearDown() generates a state change with Shutdown state, we
</span><span class="c1"></span>	<span class="c1">// don&#39;t want the balancer to receive this state change. So before
</span><span class="c1"></span>	<span class="c1">// tearDown() on the old ac, ac.acbw (acWrapper) will be set to nil, and
</span><span class="c1"></span>	<span class="c1">// this function will be called with (nil, Shutdown). We don&#39;t need to call
</span><span class="c1"></span>	<span class="c1">// balancer method in this case.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 最终会向scBuffer里写入连接的状态信息,还记得之前需要重点关注的ccBalancerWrapper对象的watcher方法么.
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scStateUpdate</span><span class="p">{</span>
		<span class="nx">sc</span><span class="p">:</span>    <span class="nx">sc</span><span class="p">,</span>
		<span class="nx">state</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span>
		<span class="nx">err</span><span class="p">:</span>   <span class="nx">err</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// watcher balancer functions sequentially, so the balancer can be implemented
</span><span class="c1">// lock-free.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">watcher</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Get</span><span class="p">():</span>
            <span class="c1">// 从scBuffer中获取数据.
</span><span class="c1"></span>			<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
            <span class="nx">su</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="o">*</span><span class="nx">scStateUpdate</span><span class="p">)</span>
            <span class="c1">// 调用Balancer接口的UpdateSubConnState来设置连接的状态,这里balancer对象是base.baseBalancer对象.
</span><span class="c1"></span>			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">su</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">ConnectionError</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">err</span><span class="p">})</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        <span class="p">}</span>

		<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">scs</span> <span class="o">:=</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">acbw</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scs</span> <span class="p">{</span>
				<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">removeAddrConn</span><span class="p">(</span><span class="nx">acbw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">(),</span> <span class="nx">errConnDrain</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="kc">nil</span><span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">ConnectivityState</span>

    <span class="o">......</span>

    <span class="c1">// 中间代码忽略,重点关注下面的.
</span><span class="c1"></span>	<span class="c1">// Regenerate picker when one of the following happens:
</span><span class="c1"></span>	<span class="c1">//  - this sc entered or left ready
</span><span class="c1"></span>	<span class="c1">//  - the aggregated state of balancer is TransientFailure
</span><span class="c1"></span>	<span class="c1">//    (may need to update error message)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nx">oldS</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span> <span class="o">||</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
        <span class="c1">// 获取Picker接口的对象.
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nf">regeneratePicker</span><span class="p">()</span>
	<span class="p">}</span>

    <span class="c1">// 这里cc对象是ccBalancerWrapper对象(实现了balancer.ClientConn接口).
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">picker</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// regeneratePicker takes a snapshot of the balancer, and generates a picker
</span><span class="c1">// from it. The picker is
</span><span class="c1">//  - errPicker if the balancer is in TransientFailure,
</span><span class="c1">//  - built by the pickerBuilder with all READY SubConns otherwise.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">baseBalancer</span><span class="p">)</span> <span class="nf">regeneratePicker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">mergeErrors</span><span class="p">())</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 记录状态为Ready的连接.
</span><span class="c1"></span>	<span class="nx">readySCs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">]</span><span class="nx">SubConnInfo</span><span class="p">)</span>

	<span class="c1">// Filter out all ready SCs from full subConn map.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
			<span class="nx">readySCs</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">SubConnInfo</span><span class="p">{</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">addr</span><span class="p">}</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 调用PickerBuilder接口的Build方法来生成Picker接口,供后续负载均衡使用,一般自定义负载均衡算法是需要实现这两个接口的.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">pickerBuilder</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">PickerBuildInfo</span><span class="p">{</span><span class="nx">ReadySCs</span><span class="p">:</span> <span class="nx">readySCs</span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="c1">// 设置ClientConn的blockingpicker对象的picker字段.
</span><span class="c1"></span>	<span class="c1">// Update picker before updating state.  Even though the ordering here does
</span><span class="c1"></span>	<span class="c1">// not matter, it can lead to multiple calls of Pick in the common start-up
</span><span class="c1"></span>	<span class="c1">// case where we wait for ready and then perform an RPC.  If the picker is
</span><span class="c1"></span>	<span class="c1">// updated later, we could call the &#34;connecting&#34; picker when the state is
</span><span class="c1"></span>	<span class="c1">// updated, and then call the &#34;ready&#34; picker after the picker gets updated.
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">updatePicker</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Picker</span><span class="p">)</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ConnectivityState</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="调用rpc接口">调用RPC接口</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">helloServiceClient</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloReply</span><span class="p">)</span>
    <span class="c1">// 这里cc是ClientConn对象,调用其Invoke方法,定义在call.go文件里.
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Invoke sends the RPC request on the wire and returns after response is
</span><span class="c1">// received.  This is typically called by generated code.
</span><span class="c1">//
</span><span class="c1">// All errors returned by Invoke are compatible with the status package.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// allow interceptor to see all applicable call options, which means those
</span><span class="c1"></span>	<span class="c1">// configured as defaults from dial option as well as per-call options
</span><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">callOptions</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果有设置客户端拦截器,最终也会调用到invoke函数.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">unaryInt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">invoke</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 没有就直接调用invoke函数.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 该函数内部会使用负载均衡算法,来选出一个连接.
</span><span class="c1"></span>	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">ClientStream</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 前面代码可以不关注.
</span><span class="c1"></span>    <span class="o">......</span>

	<span class="nx">cs</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">clientStream</span><span class="p">{</span>
		<span class="nx">callHdr</span><span class="p">:</span>      <span class="nx">callHdr</span><span class="p">,</span>
		<span class="nx">ctx</span><span class="p">:</span>          <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">methodConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">mc</span><span class="p">,</span>
		<span class="nx">opts</span><span class="p">:</span>         <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">callInfo</span><span class="p">:</span>     <span class="nx">c</span><span class="p">,</span>
		<span class="nx">cc</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">desc</span><span class="p">:</span>         <span class="nx">desc</span><span class="p">,</span>
		<span class="nx">codec</span><span class="p">:</span>        <span class="nx">c</span><span class="p">.</span><span class="nx">codec</span><span class="p">,</span>
		<span class="nx">cp</span><span class="p">:</span>           <span class="nx">cp</span><span class="p">,</span>
		<span class="nx">comp</span><span class="p">:</span>         <span class="nx">comp</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>       <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">beginTime</span><span class="p">:</span>    <span class="nx">beginTime</span><span class="p">,</span>
		<span class="nx">firstAttempt</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableRetry</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">retryThrottler</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="p">=</span> <span class="nx">binarylog</span><span class="p">.</span><span class="nf">GetMethodLogger</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span>

    <span class="c1">// 重点关注newAttempLocked.
</span><span class="c1"></span>	<span class="c1">// Only this initial attempt has stats/tracing.
</span><span class="c1"></span>	<span class="c1">// TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">newStream</span><span class="p">()</span> <span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">withRetry</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">bufferForRetryLocked</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">md</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromOutgoingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="nx">logEntry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">binarylog</span><span class="p">.</span><span class="nx">ClientHeader</span><span class="p">{</span>
			<span class="nx">OnClientSide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
			<span class="nx">Header</span><span class="p">:</span>       <span class="nx">md</span><span class="p">,</span>
			<span class="nx">MethodName</span><span class="p">:</span>   <span class="nx">method</span><span class="p">,</span>
			<span class="nx">Authority</span><span class="p">:</span>    <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">deadline</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">logEntry</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">binlog</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nx">logEntry</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">desc</span> <span class="o">!=</span> <span class="nx">unaryStreamDesc</span> <span class="p">{</span>
		<span class="c1">// Listen on cc and stream contexts to cleanup when the user closes the
</span><span class="c1"></span>		<span class="c1">// ClientConn or cancels the stream context.  In all other cases, an error
</span><span class="c1"></span>		<span class="c1">// should already be injected into the recv buffer by the transport, which
</span><span class="c1"></span>		<span class="c1">// the client will eventually receive, and then we will cancel the stream&#39;s
</span><span class="c1"></span>		<span class="c1">// context in clientStream.finish.
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nx">ErrClientConnClosing</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">cs</span><span class="p">.</span><span class="nf">finish</span><span class="p">(</span><span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()))</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// newAttemptLocked creates a new attempt with a transport.
</span><span class="c1">// If it succeeds, then it replaces clientStream&#39;s attempt with this new attempt.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">clientStream</span><span class="p">)</span> <span class="nf">newAttemptLocked</span><span class="p">(</span><span class="nx">sh</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">Handler</span><span class="p">,</span> <span class="nx">trInfo</span> <span class="o">*</span><span class="nx">traceInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">retErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newAttempt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">csAttempt</span><span class="p">{</span>
		<span class="nx">cs</span><span class="p">:</span>           <span class="nx">cs</span><span class="p">,</span>
		<span class="nx">dc</span><span class="p">:</span>           <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span>
		<span class="nx">statsHandler</span><span class="p">:</span> <span class="nx">sh</span><span class="p">,</span>
		<span class="nx">trInfo</span><span class="p">:</span>       <span class="nx">trInfo</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="o">......</span>

    <span class="c1">// 重点关注getTransport.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">getTransport</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callInfo</span><span class="p">.</span><span class="nx">failFast</span><span class="p">,</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">callHdr</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trInfo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">trInfo</span><span class="p">.</span><span class="nx">firstLine</span><span class="p">.</span><span class="nf">SetRemoteAddr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">newAttempt</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">newAttempt</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nx">done</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">attempt</span> <span class="p">=</span> <span class="nx">newAttempt</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">getTransport</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">failfast</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ClientTransport</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 调用pick方法来负载均衡.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">pick</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">failfast</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">{</span>
		<span class="nx">Ctx</span><span class="p">:</span>            <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">FullMethodName</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// pick returns the transport that will be used for the RPC.
</span><span class="c1">// It may block in the following cases:
</span><span class="c1">// - there&#39;s no picker
</span><span class="c1">// - the current picker returns ErrNoSubConnAvailable
</span><span class="c1">// - the current picker returns other errors and failfast is false.
</span><span class="c1">// - the subConn returned by the current picker is not READY
</span><span class="c1">// When one of these situations happens, pick blocks until the picker gets updated.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pw</span> <span class="o">*</span><span class="nx">pickerWrapper</span><span class="p">)</span> <span class="nf">pick</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">failfast</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ClientTransport</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="kd">var</span> <span class="nx">lastPickErr</span> <span class="kt">error</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">done</span> <span class="p">{</span>
			<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrClientConnClosing</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">picker</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="p">=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ch</span> <span class="o">==</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span> <span class="p">{</span>

            <span class="o">......</span>

			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">ch</span> <span class="p">=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">blockingCh</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">picker</span>
		<span class="nx">pw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

        <span class="c1">// 调用Pick方法负载均衡,可以是自定义负载均衡算法,gRPC默认的是轮询.
</span><span class="c1"></span>		<span class="nx">pickResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Pick</span><span class="p">(</span><span class="nx">info</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 返回错误时的处理.
</span><span class="c1"></span>            <span class="o">......</span>
		<span class="p">}</span>

        <span class="c1">// 把conn显示的转化为acBalancerWrapper.
</span><span class="c1"></span>		<span class="nx">acw</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">.(</span><span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;subconn returned from pick is not *acBalancerWrapper&#34;</span><span class="p">)</span>
			<span class="k">continue</span>
        <span class="p">}</span>
        
        <span class="c1">// 调用getReadyTransport,来判断状态是否为Ready,若为Idle则发起connect.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">acw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">().</span><span class="nf">getReadyTransport</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nf">doneChannelzWrapper</span><span class="p">(</span><span class="nx">acw</span><span class="p">,</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span><span class="p">),</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 状态不为Ready,则返回重新进行pick.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pickResult</span><span class="p">.</span><span class="nx">Done</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Calling done with nil error, no bytes sent and no bytes received.
</span><span class="c1"></span>			<span class="c1">// DoneInfo with default value works.
</span><span class="c1"></span>			<span class="nx">pickResult</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;blockingPicker: the picked transport is not ready, loop back to repick&#34;</span><span class="p">)</span>
		<span class="c1">// If ok == false, ac.state is not READY.
</span><span class="c1"></span>		<span class="c1">// A valid picker always returns READY subConn. This means the state of ac
</span><span class="c1"></span>		<span class="c1">// just changed, and picker will be updated shortly.
</span><span class="c1"></span>		<span class="c1">// continue back to the beginning of the for loop to repick.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<ul>
<li>要实现自定义Resolver,需要实现resolver.Builder接口和resolver.Resolver接口.在init函数中调用resolver.Register来注册自定义的Builder对象.在Builder接口的Build方法中要调用UpdateState来更新服务端地址信息.客户端在解析target时会根据scheme来获取对应的Resolver对象.</li>
<li>要实现自定义负载均衡算法,需要实现base.PickerBuilder接口和balancer.Picker接口(注意这两个接口有V2版的),通过base.NewBalancerBuilder包装成balancer.Builder接口,再在init函数中调用balancer.Register来注册该Builder对象.最后grpc.WithBalancerName把Builder包装成grpc.DialOption.</li>
<li>要实现自定义认证,需要实现credentials.PerRPCCredentials接口,然后调用grpc.WithPerRPCCredentials把对象包装成grpc.DialOption.</li>
<li>在客户端调用<code>Dial</code>或<code>DialContext</code>过程中,会先通过Resolver来解析出所有的Endpoint,然后会与每一个Endpoint建立连接(采用异步的方式),同时也会设置好对应的负载均衡Picker对象.注意如果使用了grpc.WithBlock()会同步等待连接建立成功(有一个成功就可以了),否则就会直接返回.</li>
<li>负载均衡算法会在调用具体的RPC函数过程中使用到,在invoke函数(call.go文件中)中会根据负载均衡算法来选定一个连接,然后发起请求.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之server端调用</title>
			<link>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bserver%E7%AB%AF%E8%B0%83%E7%94%A8/</link>
			<pubDate>Sat, 07 Nov 2020 11:47:48 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8Bserver%E7%AB%AF%E8%B0%83%E7%94%A8/</guid>
			<description>NewServer创建gRPC服务对象 主要是基于grpc-go的1.33.1版本Unary RPC来分析. // NewServer creates a gRPC server which has no service registered and has not // started to accept</description>
			<content type="html"><![CDATA[<h2 id="newserver创建grpc服务对象">NewServer创建gRPC服务对象</h2>
<p>主要是基于grpc-go的1.33.1版本Unary RPC来分析.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewServer creates a gRPC server which has no service registered and has not
</span><span class="c1">// started to accept requests yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewServer</span><span class="p">(</span><span class="nx">opt</span> <span class="o">...</span><span class="nx">ServerOption</span><span class="p">)</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
    <span class="c1">// 处理Server对象的一些定制化参数.在Go中推荐采用Option的方式从外部来影响对象内的行为.
</span><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="nx">defaultServerOptions</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opt</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">opts</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 生成Server对象.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span>
        <span class="nx">lis</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
        <span class="nx">opts</span><span class="p">:</span>     <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">conns</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
		<span class="nx">services</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">serviceInfo</span><span class="p">),</span>
		<span class="nx">quit</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">czData</span><span class="p">:</span>   <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
    <span class="p">}</span>
    
    <span class="c1">// 处理一元服务端拦截器,支持链式多拦截器.
</span><span class="c1"></span>    <span class="nf">chainUnaryServerInterceptors</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    
    <span class="c1">// 处理流式服务端拦截器,支持链式多拦截器.
</span><span class="c1"></span>	<span class="nf">chainStreamServerInterceptors</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">cv</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">EnableTracing</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">events</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">NewEventLog</span><span class="p">(</span><span class="s">&#34;grpc.Server&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s:%d&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">))</span>
	<span class="p">}</span>

    <span class="c1">// 用来控制处理连接的goroutine的数量,为0时表示不控制.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">initServerWorkers</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">channelzID</span> <span class="p">=</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">RegisterServer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">channelzServer</span><span class="p">{</span><span class="nx">s</span><span class="p">},</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h2 id="serveroption自定义参数">ServerOption自定义参数</h2>
<p><strong>Creds</strong>
主要用来设置服务端认证相关的参数.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用来设置TLS.
</span><span class="c1">// Creds returns a ServerOption that sets credentials for server connections.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Creds</span><span class="p">(</span><span class="nx">c</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">creds</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// gRPC中的credentials包,已定义相关的TransportCredentials.
</span><span class="c1">// NewServerTLSFromFile constructs TLS credentials from the input certificate file and key
</span><span class="c1">// file for server.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewServerTLSFromFile</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">TransportCredentials</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cert</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tls</span><span class="p">.</span><span class="nf">LoadX509KeyPair</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">NewTLS</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Certificates</span><span class="p">:</span> <span class="p">[]</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Certificate</span><span class="p">{</span><span class="nx">cert</span><span class="p">}}),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><strong>UnaryInterceptor</strong>
主要用来设置服务端的拦截器.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// UnaryInterceptor returns a ServerOption that sets the UnaryServerInterceptor for the
</span><span class="c1">// server. Only one unary interceptor can be installed. The construction of multiple
</span><span class="c1">// interceptors (e.g., chaining) can be implemented at the caller.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">UnaryInterceptor</span><span class="p">(</span><span class="nx">i</span> <span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;The unary server interceptor was already set and may not be reset.&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 具体的自定义拦截器需要实现UnaryServerInterceptor函数原型.
</span><span class="c1">// UnaryServerInterceptor provides a hook to intercept the execution of a unary RPC on the server. info
</span><span class="c1">// contains all the information of this RPC the interceptor can operate on. And handler is the wrapper
</span><span class="c1">// of the service method implementation. It is the responsibility of the interceptor to invoke handler
</span><span class="c1">// to complete the RPC.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnaryServerInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p><strong>ChainUnaryInterceptor</strong>
主要用来设置服务端的链式拦截器.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 支持同时设置多个拦截器.
</span><span class="c1">// ChainUnaryInterceptor returns a ServerOption that specifies the chained interceptor
</span><span class="c1">// for unary RPCs. The first interceptor will be the outer most,
</span><span class="c1">// while the last interceptor will be the inner most wrapper around the real call.
</span><span class="c1">// All unary interceptors added by this method will be chained.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ChainUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptors</span> <span class="o">...</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncServerOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">serverOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span><span class="p">,</span> <span class="nx">interceptors</span><span class="o">...</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h2 id="注册rpc对象到server中">注册RPC对象到Server中</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 注册HelloServiceServer对象到gRPC对象中.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">HelloServiceServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_HelloService_serviceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// _HelloService_serviceDesc主要用来描述RPC对象的信息.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_HelloService_serviceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;HelloService&#34;</span><span class="p">,</span>
	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloServiceServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>
		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;SayHello&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_HelloService_SayHello_Handler</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>
	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;hello.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 注册RPC服务对象.
</span><span class="c1">// RegisterService registers a service and its implementation to the gRPC
</span><span class="c1">// server. It is called from the IDL generated code. This must be called before
</span><span class="c1">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to
</span><span class="c1">// ensure it implements sd.HandlerType.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">RegisterService</span><span class="p">(</span><span class="nx">sd</span> <span class="o">*</span><span class="nx">ServiceDesc</span><span class="p">,</span> <span class="nx">ss</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// 主要用来判断接口类型是否一致.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ss</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ht</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">sd</span><span class="p">.</span><span class="nx">HandlerType</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
		<span class="nx">st</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">ss</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">ht</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&#34;</span><span class="p">,</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ht</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="nx">sd</span><span class="p">,</span> <span class="nx">ss</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">register</span><span class="p">(</span><span class="nx">sd</span> <span class="o">*</span><span class="nx">ServiceDesc</span><span class="p">,</span> <span class="nx">ss</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;RegisterService(%q)&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serve</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService after Server.Serve for %q&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 判断服务名是否已经注册过了.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc: Server.RegisterService found duplicate service registration for %q&#34;</span><span class="p">,</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 创建serviceInfo对象.
</span><span class="c1"></span>	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">serviceInfo</span><span class="p">{</span>
        <span class="c1">// 接口的实现对象.
</span><span class="c1"></span>        <span class="nx">serviceImpl</span><span class="p">:</span> <span class="nx">ss</span><span class="p">,</span>
        
        <span class="c1">// 具体的方法描述信息.
</span><span class="c1"></span>		<span class="nx">methods</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">MethodDesc</span><span class="p">),</span>
        <span class="nx">streams</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">StreamDesc</span><span class="p">),</span>
        
        <span class="c1">// 元数据.
</span><span class="c1"></span>		<span class="nx">mdata</span><span class="p">:</span>       <span class="nx">sd</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1">// 保存具体的方法.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">info</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">MethodName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Streams</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sd</span><span class="p">.</span><span class="nx">Streams</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">info</span><span class="p">.</span><span class="nx">streams</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">StreamName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">info</span>
<span class="p">}</span>
</code></pre></div><h2 id="server启动监听等待连接">Server启动监听等待连接</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Serve accepts incoming connections on the listener lis, creating a new
</span><span class="c1">// ServerTransport and service goroutine for each. The service goroutines
</span><span class="c1">// read gRPC requests and then call the registered handlers to reply to them.
</span><span class="c1">// Serve returns when lis.Accept fails with fatal errors.  lis will be closed when
</span><span class="c1">// this method returns.
</span><span class="c1">// Serve will return a non-nil error unless Stop or GracefulStop is called.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

    <span class="o">......</span>

	<span class="nx">ls</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">listenSocket</span><span class="p">{</span><span class="nx">Listener</span><span class="p">:</span> <span class="nx">lis</span><span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">[</span><span class="nx">ls</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

    <span class="o">......</span>

	<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lis</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">[</span><span class="nx">ls</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">ls</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">lis</span><span class="p">,</span> <span class="nx">ls</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="kd">var</span> <span class="nx">tempDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// how long to sleep on accept failure
</span><span class="c1"></span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 等待连接.
</span><span class="c1"></span>		<span class="nx">rawConn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 当返回错误时,会尝试重新调用Accept,时间间隔从5毫秒开始,每重试一次时间翻倍,直到1秒.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ne</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">interface</span> <span class="p">{</span>
				<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span>
			<span class="p">});</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ne</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 计算时间间隔的逻辑.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">tempDelay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="o">*=</span> <span class="mi">2</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">max</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">;</span> <span class="nx">tempDelay</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="nx">max</span>
				<span class="p">}</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Accept error: %v; retrying in %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">tempDelay</span><span class="p">)</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">tempDelay</span><span class="p">)</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
					<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;done serving; Accept = %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        
        <span class="c1">// Accept正常后,重置时间为0.
</span><span class="c1"></span>		<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// Start a new goroutine to deal with rawConn so we don&#39;t stall this Accept
</span><span class="c1"></span>		<span class="c1">// loop goroutine.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Make sure we account for the goroutine so GracefulStop doesn&#39;t nil out
</span><span class="c1"></span>        <span class="c1">// s.conns before this conn can be added.
</span><span class="c1"></span>        <span class="c1">// 主要是为了优雅的关闭,在关闭前所有的连接必须被处理完了.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// 启动一个新的goroutine来处理新的连接.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="业务处理逻辑">业务处理逻辑</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// handleRawConn forks a goroutine to handle a just-accepted connection that
</span><span class="c1">// has not had any I/O performed on it yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">rawConn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rawConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="c1">// 设置超时时间,默认是120秒.
</span><span class="c1"></span>    <span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">connectionTimeout</span><span class="p">))</span>
    
    <span class="c1">// 处理TLS认证.
</span><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">authInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">useTransportAuthenticator</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// ErrConnDispatched means that the connection was dispatched away from
</span><span class="c1"></span>		<span class="c1">// gRPC; those connections should be left open.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">ErrConnDispatched</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">errorf</span><span class="p">(</span><span class="s">&#34;ServerHandshake(%q) failed: %v&#34;</span><span class="p">,</span> <span class="nx">rawConn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">channelz</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;grpc: Server.Serve failed to complete security handshake from %q: %v&#34;</span><span class="p">,</span> <span class="nx">rawConn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">rawConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
		<span class="k">return</span>
	<span class="p">}</span>

    <span class="c1">// 开启HTTP/2协议.
</span><span class="c1"></span>	<span class="c1">// Finish handshaking (HTTP2)
</span><span class="c1"></span>	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newHTTP2Transport</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">authInfo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">rawConn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nf">addConn</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 开启新的goroutine来处理业务数据.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">removeConn</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

    <span class="kd">var</span> <span class="nx">roundRobinCounter</span> <span class="kt">uint32</span>
    <span class="c1">// HandleStreams主要是接收数据,并生成Stream对象,在调用下面的匿名函数来处理具体的业务逻辑.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">HandleStreams</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// 判断是否有设置numServerWorkers.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">data</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">serverWorkerData</span><span class="p">{</span><span class="nx">st</span><span class="p">:</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">wg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">stream</span><span class="p">:</span> <span class="nx">stream</span><span class="p">}</span>
			<span class="k">select</span> <span class="p">{</span>
            <span class="c1">// 发送数据到指定的channel中.
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serverWorkerChannels</span><span class="p">[</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">roundRobinCounter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">data</span><span class="p">:</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="c1">// If all stream workers are busy, fallback to the default code path.
</span><span class="c1"></span>				<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                    <span class="c1">// 若所有workerchannel都在忙,则单独创建goroutine.
</span><span class="c1"></span>					<span class="nx">s</span><span class="p">.</span><span class="nf">handleStream</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">traceInfo</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">))</span>
					<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="p">}()</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 没有限制worker大小,则单独创建goroutine.
</span><span class="c1"></span>				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">handleStream</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">traceInfo</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">))</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">EnableTracing</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">ctx</span>
		<span class="p">}</span>
		<span class="nx">tr</span> <span class="o">:=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;grpc.Recv.&#34;</span><span class="o">+</span><span class="nf">methodFamily</span><span class="p">(</span><span class="nx">method</span><span class="p">),</span> <span class="nx">method</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">tr</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// HandleStreams receives incoming streams using the given handler. This is
</span><span class="c1">// typically run in a separate goroutine.
</span><span class="c1">// traceCtx attaches trace to ctx and returns the new context.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">http2Server</span><span class="p">)</span> <span class="nf">HandleStreams</span><span class="p">(</span><span class="nx">handle</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">readerDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">controlBuf</span><span class="p">.</span><span class="nf">throttle</span><span class="p">()</span>
        <span class="c1">// 读取HTTP/2协议中的frame数据.
</span><span class="c1"></span>		<span class="nx">frame</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">framer</span><span class="p">.</span><span class="nx">fr</span><span class="p">.</span><span class="nf">ReadFrame</span><span class="p">()</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">lastRead</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 错误相关.
</span><span class="c1"></span>            <span class="o">......</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// 针对不同类型的frame的处理,可以和之前的抓包对应起来.
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">frame</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">MetaHeadersFrame</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">operateHeaders</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="nx">handle</span><span class="p">,</span> <span class="nx">traceCtx</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">DataFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleData</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">RSTStreamFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleRSTStream</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">SettingsFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleSettings</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">PingFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handlePing</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">WindowUpdateFrame</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">handleWindowUpdate</span><span class="p">(</span><span class="nx">frame</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">GoAwayFrame</span><span class="p">:</span>
			<span class="c1">// TODO: Handle GoAway from the client appropriately.
</span><span class="c1"></span>		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="nx">logLevel</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">logger</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;transport: http2Server.HandleStreams found unhandled frame type %v.&#34;</span><span class="p">,</span> <span class="nx">frame</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleStream</span><span class="p">(</span><span class="nx">t</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">,</span> <span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">,</span> <span class="nx">trInfo</span> <span class="o">*</span><span class="nx">traceInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 解析方法名,如/HelloService/SayHello.
</span><span class="c1"></span>	<span class="nx">sm</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Method</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sm</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">sm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">sm</span> <span class="p">=</span> <span class="nx">sm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="p">}</span>
	<span class="nx">pos</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">LastIndex</span><span class="p">(</span><span class="nx">sm</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// 错误处理.
</span><span class="c1"></span>        <span class="o">......</span>
		<span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// service服务名等于HelloService.
</span><span class="c1"></span>    <span class="nx">service</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">[:</span><span class="nx">pos</span><span class="p">]</span>
    <span class="c1">// 方法名等于SyaHello.
</span><span class="c1"></span>	<span class="nx">method</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">[</span><span class="nx">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">// 从已注册的service中查找.
</span><span class="c1"></span>	<span class="nx">srv</span><span class="p">,</span> <span class="nx">knownService</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">service</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">knownService</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 若方法存在,在调用processUnaryRPC.此时md已经指向注册时的Handler了,如SyaHello方法对应的_HelloService_SayHello_Handler.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">processUnaryRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">streams</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="c1">// 调用流式处理.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">processStreamingRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 若不存在,调用unknown.
</span><span class="c1"></span>	<span class="c1">// Unknown service, or known server unknown method.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">unknownDesc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">unknownStreamDesc</span><span class="p">;</span> <span class="nx">unknownDesc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">processStreamingRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unknownDesc</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
		<span class="k">return</span>
    <span class="p">}</span>
    
    <span class="o">......</span>
<span class="p">}</span>

<span class="c1">// processUnaryRPC实质上就是先从stream中读取一个完整的message,然后再调用md的Handler,来执行具体的业务代码,最后再sendResponse.
</span><span class="c1"></span>
<span class="c1">// 具体的业务逻辑代码,*.pb.go文件中.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_HelloService_SayHello_Handler</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dec</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">interceptor</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 解析请求参数.
</span><span class="c1"></span>	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">dec</span><span class="p">(</span><span class="nx">in</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    
    <span class="c1">// 如果没有设置拦截器,就直接调用SayHello.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">interceptor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">{</span>
		<span class="nx">Server</span><span class="p">:</span>     <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">FullMethod</span><span class="p">:</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1">// UnaryHandler,具体的业务逻辑.
</span><span class="c1"></span>	<span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">.(</span><span class="o">*</span><span class="nx">HelloRequest</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="c1">// 调用拦截器,最后再执行handler,来处理业务逻辑.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">interceptor</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<ul>
<li>通过<code>ServerOption</code>来设置自定义参数,最主要的包括<code>grpc.Creds</code>(用于设置服务端认证)和<code>grpc.UnaryInterceptor</code>(用于设置服务端拦截器).</li>
<li>在*.pb.go中主要是通过<code>grpc.ServiceDesc</code>来描述rpc接口的信息,最终调用会指向其<code>Handler</code>字段.</li>
<li>在整个处理过程中会涉及到的goroutine.
<ul>
<li>当<code>Accept</code>接收到一个新连接时就会启用一个goroutine,主要用来处理认证及HTTP/2相关的初始化.</li>
<li>接着会启用一个goroutine用来接收HTTP/2协议的数据.</li>
<li>每接收到一个完整请求包时,会再启用一个goroutine用来处理新的消息包.注意:此处如果设置了<code>numServerWorkers</code>,会优先使用workchannel.</li>
</ul>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>gRPC系列之初识</title>
			<link>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E8%AF%86/</link>
			<pubDate>Fri, 06 Nov 2020 22:05:51 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/grpc%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E8%AF%86/</guid>
			<description>RPC RPC指远程过程调用(Remote Procedure Call),让远程服务调用更加简单、透明.服务调用者可以像调用本地接口一样调用远程的服务提供者,而不需</description>
			<content type="html"><![CDATA[<h2 id="rpc">RPC</h2>
<p>RPC指远程过程调用(Remote Procedure Call),让远程服务调用更加简单、透明.服务调用者可以像调用本地接口一样调用远程的服务提供者,而不需要关心底层通信细节和调用过程,RPC框架负责底层的传输方式、序列化方式和通信细节.</p>
<p>gRPC是一个高性能、开源和通用的RPC框架,面向服务端和移动端,特点如下:</p>
<ul>
<li>支持多语言.</li>
<li>基于IDL文件定义服务,通过protoc工具生成指定语言的数据结构、服务端接口和客户端Stub.</li>
<li>通信协议基于HTTP/2设计,支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性.使得在移动端设备上更加省电和节省网络流量.</li>
<li>序列化支持<a href="https://github.com/protocolbuffers/protobuf">Protocol Buffer</a>和JSON.</li>
</ul>
<p><img src="/images/grpc.png" alt="gRPC调用示例" title="gRPC调用"></p>
<h2 id="protoc工具">protoc工具</h2>
<p>先安装相关工具,可以用来直接生成go和grpc的代码.</p>
<ol>
<li>安装<a href="https://github.com/protocolbuffers/protobuf">protoc</a></li>
<li>安装<a href="https://github.com/protocolbuffers/protobuf-go">protoc-gen-go</a></li>
<li>安装<a href="https://github.com/grpc/grpc-go">protoc-gen-go-grpc</a></li>
</ol>
<h2 id="idl文件">IDL文件</h2>
<p>生成<code>hello.proto</code>文件,内容如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>

<span class="nx">option</span> <span class="nx">go_package</span><span class="p">=</span><span class="s">&#34;.;pb&#34;</span><span class="p">;</span>

<span class="nx">message</span> <span class="nx">HelloRequest</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">name</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">HelloReply</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">message</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">HelloService</span> <span class="p">{</span>
    <span class="nx">rpc</span> <span class="nf">SayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>syntax,定义proto的版本,支持proto2和proto3,proto3才支持grpc.</li>
<li>go_package,定义生成的go文件的包名(package name).</li>
<li>message,定义数据结构.</li>
<li>service,定义服务,可包含多个rpc函数.</li>
</ul>
<h2 id="生成go语言代码">生成go语言代码</h2>
<p>使用工具<code>protoc</code>来生成对应的go文件,命令<code>protoc -I=./proto --go_out=plugins=grpc:./pb hello.proto</code>.</p>
<ul>
<li><code>-I=./proto</code>,表示proto文件所在的目录.</li>
<li><code>--go_out</code>,表示生成go语言的代码,且存放go文件的目录,默认是不会生成grpc的代码的,需要显式声明<code>plugins=grpc</code>.</li>
<li><code>hello.proto</code>,表示proto文件的名字.</li>
</ul>
<p>在目录<code>pb</code>中生成文件<code>hello.pb.go</code>,文件里面包含了grpc相关代码.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Reference imports to suppress errors if they are not otherwise used.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span>

<span class="c1">// This is a compile-time assertion to ensure that this generated file
</span><span class="c1">// is compatible with the grpc package it is being compiled against.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">SupportPackageIsVersion6</span>

<span class="c1">// HelloServiceClient is the client API for HelloService service.
</span><span class="c1">//
</span><span class="c1">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">HelloServiceClient</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">helloServiceClient</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cc</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewHelloServiceClient</span><span class="p">(</span><span class="nx">cc</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConnInterface</span><span class="p">)</span> <span class="nx">HelloServiceClient</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">helloServiceClient</span><span class="p">{</span><span class="nx">cc</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">helloServiceClient</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloReply</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// HelloServiceServer is the server API for HelloService service.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">HelloServiceServer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// UnimplementedHelloServiceServer can be embedded to have forward compatible implementations.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnimplementedHelloServiceServer</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">UnimplementedHelloServiceServer</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Unimplemented</span><span class="p">,</span> <span class="s">&#34;method SayHello not implemented&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">HelloServiceServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_HelloService_serviceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_HelloService_SayHello_Handler</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dec</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">interceptor</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">dec</span><span class="p">(</span><span class="nx">in</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">interceptor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">{</span>
		<span class="nx">Server</span><span class="p">:</span>     <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">FullMethod</span><span class="p">:</span> <span class="s">&#34;/HelloService/SayHello&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">HelloServiceServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">.(</span><span class="o">*</span><span class="nx">HelloRequest</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">interceptor</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">_HelloService_serviceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;HelloService&#34;</span><span class="p">,</span>
	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloServiceServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>
		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;SayHello&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_HelloService_SayHello_Handler</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>
	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;hello.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><h2 id="服务端代码">服务端代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 监听tcp端口,用于接受客户端请求.
</span><span class="c1"></span><span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">port</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to listen: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 创建gRPC服务实例对象.
</span><span class="c1"></span><span class="nx">grpcserver</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>

<span class="c1">// 把server对象注册到gRPC服务中,server对象实现了HelloServiceServer接口.
</span><span class="c1"></span><span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterHelloServiceServer</span><span class="p">(</span><span class="nx">grpcserver</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">server</span><span class="p">{})</span>

<span class="c1">// 阻塞等待客户端连接,直到进程被终止或Stop函数被调用.
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">grpcserver</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to server: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="客户端代码">客户端代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个连接与服务端进行通信.
</span><span class="c1"></span><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to dail: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 关闭连接.
</span><span class="c1"></span><span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="c1">// 创建HelloService的Client stub.
</span><span class="c1"></span><span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewHelloServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>

<span class="c1">// 调用对应的服务方法.
</span><span class="c1"></span><span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;zhou&#34;</span><span class="p">})</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;failed to sayhello: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
</code></pre></div><h2 id="调用分析">调用分析</h2>
<h3 id="wireshark抓包">wireshark抓包</h3>
<p>服务端监听在9090端口,用<a href="https://www.wireshark.org/">wireshark</a>来进行抓包.
<img src="/images/pcap1.png" alt="抓包" title="wireshark抓包">
可以看到前三行是tcp三次握手的报文,后续的全部都解析成了tcp协议,gRPC是基于http/2,需要手工修改Protocol为http/2.
wireshark菜单栏&ndash;&gt;分析(A)&ndash;&gt;解码为(Decode As),在弹出的界面新增一行,然后修改&quot;当前&quot;列为HTTP2.
<img src="/images/pcap2.png" alt="设置http/2" title="设置协议为http2"></p>
<p>现在能正常解析为HTTP/2协议了,一次gRPC调用总览如下:
<img src="/images/pcap3.png" alt="HTTP/2协议" title="gRPC调用总览">
从上图大体可以看出,gRPC调用过程分为:<code>Magic(C-&gt;S) --&gt; SETTINGS(S-&gt;C) --&gt; SETTINGS(C-&gt;S) --&gt; SETTINGS(S-&gt;C) --&gt; SETTINGS,HEADERS,DATA(C-&gt;S) --&gt; WINDOW_UPDATE,PING(S-&gt;C) --&gt; HEADERS,DATA,HEADERS(S-&gt;C) --&gt; PING,WINDOW_UPDATE,PING(C-&gt;S) --&gt; PING(S-&gt;C)</code></p>
<h3 id="magic">Magic</h3>
<p><img src="/images/grpc-magic.png" alt="Magic" title="gRPC-Magic">
Magic帧的主要作用是建立HTTP/2请求的前言.在HTTP/2协议中,要求两端都要发送连接前言,来最终确认所使用的协议,并确定HTTP/2连接的初始设置.</p>
<p>而Magic帧是客户端的前言之一,内容为<code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>,以确定启用HTTP/2连接.</p>
<h3 id="settings">SETTINGS</h3>
<p><img src="/images/grpc-settings1.png" alt="SETTINGS1" title="gRPC-SETTINGS">
由服务端发送给客户端,主要设置<code>Max Frame Size</code>为16384字节,作用域是整个连接而非单一的流.也是服务端的连接前言.</p>
<p><img src="/images/grpc-settings2.png" alt="SETTINGS2" title="gRPC-SETTINGS">
由客户端发送给服务端,是客户端的连接前言(和Magic一起).</p>
<p><img src="/images/grpc-settings3.png" alt="SETTINGS3" title="gRPC-SETTINGS">
由服务端发送给客户端,在发送完前言后,客户端和服务端还需要有一步互相确认的动作,对应的就是带有<code>ACK: True</code>的帧.</p>
<p><img src="/images/grpc-settings4.png" alt="SETTINGS4" title="gRPC-SETTINGS">
由客户端发送给服务端,是带有<code>ACK: True</code>的帧.</p>
<h3 id="headers">HEADERS</h3>
<p><img src="/images/grpc-headers1.png" alt="HEADERS1" title="gRPC-HEADERS">
主要是存储和传播HTTP的表头信息.</p>
<h3 id="data">DATA</h3>
<p><img src="/images/grpc-data1.png" alt="DATA1" title="gRPC-DATA">
DATA是数据帧,可以看到请求的protobuf结构只有1个字段,该字段的值为<code>zhou</code>(可以参见客户端代码).</p>
<h3 id="window_update">WINDOW_UPDATE</h3>
<p><img src="/images/grpc-win.png" alt="WIN" title="gRPC-WINDOW_UPDATE">
主要是管理流控制窗口的大小.</p>
<h3 id="headersdataheaders">HEADERS,DATA,HEADERS</h3>
<p><img src="/images/grpc-rsp1.png" alt="RSP1" title="gRPC-DATA">
<img src="/images/grpc-rsp2.png" alt="RSP2" title="gRPC-DATA">
服务端发送给客户端的响应,HEADERS frame记录的是HTTP响应状态(<code>200 OK</code>)和响应的内容格式(<code>application/grpc</code>).
响应的protobuf结构也是只有1个字段,字段的值是<code>zhou</code>.</p>
<h3 id="ping">PING</h3>
<p>主要是判断当前连接是否仍然可用,也常用于计算往返时间.</p>
<h2 id="流式模式">流式模式</h2>
<p>gRPC支持UnaryRPC(一元PRC)和StreamRPC(流式RPC).</p>
<ul>
<li>UnaryRPC,上面介绍的都是基于UnaryRPC的,该模式是一个请求对应一个响应.</li>
<li>StreamRPC流式模式的请求和响应是多对多的,又分为三种类型:
<ul>
<li>Server-side streaming RPC,服务端流式模式,即一个请求对应多个响应.</li>
<li>Client-side streaming RPC,客户端流式模式,即多个请求对应一个响应.</li>
<li>Bidirectional streaming RPC,双向流式模式,即多个请求对应多个响应.</li>
</ul>
</li>
</ul>
<p>流式模式需要用到关键字<code>stream</code>,如下proto文件.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>

<span class="nx">option</span> <span class="nx">go_package</span><span class="p">=</span><span class="s">&#34;.;pb&#34;</span><span class="p">;</span>

<span class="nx">message</span> <span class="nx">HelloRequest</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">name</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">HelloReply</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">message</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">HelloService</span> <span class="p">{</span>
    <span class="nx">rpc</span> <span class="nf">SayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">ServerSayHello</span> <span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">ClientSayHello</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">HelloReply</span><span class="p">);</span>
    <span class="nx">rpc</span> <span class="nf">BidirSayHello</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">HelloReply</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>SayHello</code>是一元RPC模式.
<code>ServerSayHello</code>是服务端流式模式.
<code>ClientSayHello</code>是客户端流式模式.
<code>BidirSayHello</code>是双向流式模式.</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://jingwei.link/2018/10/02/grpc-wireshark-analysis.html">抓包gRPC的细节与分析</a></li>
<li><a href="https://httpwg.org/specs/rfc7540.html">Hypertext Transfer Protocol Version 2</a></li>
<li><a href="https://eddycjy.com/posts/go/talk/2019-06-29-talking-grpc/">从实践到原理，带你参透 gRPC</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>go性能分析</title>
			<link>https://shenbaise9527.com/golang/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
			<description>性能分析 Go语言项目中的性能分析主要有以下几个方面: CPU profile: CPU使用情况,按照一定频率去采集应用程序在CPU和寄存器上面的数据. Memory profile(Heap profile): 报告程序</description>
			<content type="html"><![CDATA[<h2 id="性能分析">性能分析</h2>
<p>Go语言项目中的性能分析主要有以下几个方面:</p>
<ul>
<li>CPU profile: CPU使用情况,按照一定频率去采集应用程序在CPU和寄存器上面的数据.</li>
<li>Memory profile(Heap profile): 报告程序的内存使用情况.</li>
<li>Block Profiling: 报告goroutines不在运行状态的情况,可用来分析和查找死锁等性能瓶颈.</li>
<li>Goroutine Profiling: 报告goroutines的使用情况,有哪些goroutines,调用关系是怎么样的?</li>
</ul>
<h2 id="数据采集">数据采集</h2>
<p>Go语言内置了获取程序运行数据的工具,包括两个标准库:</p>
<ol>
<li><code>runtime/pprof</code>: 采集工具型应用的运行数据进行分析</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;runtime/pprof&#34;</span>

<span class="c1">// 开启CPU性能分析.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">StartCPUProfile</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>

<span class="c1">// 关闭CPU性能分析.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">StopCPUProfile</span><span class="p">()</span>

<span class="c1">// 记录程序堆栈信息.
</span><span class="c1"></span><span class="nx">pprof</span><span class="p">.</span><span class="nf">WriteHeapProfile</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
</code></pre></div><p>pprof开启后,每隔一段时间(10ms)就会收集下当前的堆栈信息,获取各个函数占用的CPU以及内存资源,最后通过采样数据分析,形成性能分析报告.</p>
<ol start="2">
<li><code>net/http/pprof</code>: 采集服务型应用的运行数据进行分析</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在web server端导入pprof库.
</span><span class="c1"></span><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>

<span class="c1">// 如果使用自定义Mux,需要手动注册路由规则.
</span><span class="c1"></span><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/cmdline&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Cmdline</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/profile&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Profile</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/symbol&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Symbol</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/trace&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Trace</span><span class="p">)</span>

<span class="c1">// 如果使用gin框架,推荐使用&#39;github.com/DeanThompson/ginpprof&#39;
</span></code></pre></div><p>http服务会多出<code>/debug/pprof</code>的endpoint:</p>
<ul>
<li>/debug/pprof/profile: 访问这个链接会自动进行CPU Profiling,持续30s,并生成文件供下载.</li>
<li>/debug/pprof/heap: Memory Profiling.</li>
<li>/debug/pprof/block: Block Profiling.</li>
<li>/debug/pprof/goroutines: 运行的goroutines列表以及调用关系.</li>
</ul>
<ol start="3">
<li>profiling数据是动态的,要想获得有效的数据,请保证应用处于较大的负载,否则如果处于空闲状态,得到的结果可能没有任何意义</li>
</ol>
<h2 id="数据分析">数据分析</h2>
<h3 id="go-tool-pprof命令">go tool pprof命令</h3>
<p>可以通过命令<code>go tool pprof --help</code>查看命令的具体使用方法.</p>
<pre><code>$ go tool pprof --help
usage:

Produce output in the specified format.

   pprof &lt;format&gt; [options] [binary] &lt;source&gt; ...

Omit the format to get an interactive shell whose commands can be used
to generate various views of a profile

   pprof [options] [binary] &lt;source&gt; ...

Omit the format and provide the &quot;-http&quot; flag to get an interactive web
interface at the specified host:port that can be used to navigate through
various views of a profile.

   pprof -http [host]:[port] [options] [binary] &lt;source&gt; ...

Details:
  Output formats (select at most one):
</code></pre><h3 id="图形化">图形化</h3>
<ol>
<li>
<p>安装<a href="https://graphviz.gitlab.io/">graphviz</a>,windows是还需要把安装目录下的<code>bin</code>文件夹添加到<code>PATH</code>环境变量中.</p>
</li>
<li>
<p>使用<code>dot -version</code>命令查看graphviz安装是否成功.</p>
</li>
<li>
<p>安装go-torch,使用<code>go get -v github.com/uber/go-torch</code>命令安装.
当<code>go-torch</code>不带任何参数时,会默认从<code>http://localhost:8080/debug/pprof/profile</code>获取profiling数据.</p>
<pre><code>$ go-torch --help
Usage:
go-torch [options] [binary] &lt;profile source&gt;

pprof Options:
-u, --url=         Base URL of your Go program (default: http://localhost:8080)
    --suffix=      URL path of pprof profile (default: /debug/pprof/profile)
-b, --binaryinput= File path of previously saved binary profile. (binary profile is anything accepted by https://golang.org/cmd/pprof)
    --binaryname=  File path of the binary that the binaryinput is for, used for pprof inputs
-t, --seconds=     Number of seconds to profile for (default: 30)
    --pprofArgs=   Extra arguments for pprof
</code></pre></li>
<li>
<p>安装<a href="https://www.perl.org/get.html">perl</a>,FlameGraph需要perl支持.</p>
</li>
<li>
<p>安装FlameGraph,使用<code>git clone https://github.com/brendangregg/FlameGraph.git</code>命令安装.
windows平台下,需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code>按如下方式修改,然后在<code>go-torch</code>目录下执行<code>go install</code>命令.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) {
</span><span class="c1"></span><span class="nx">flameGraph</span> <span class="o">:=</span> <span class="nf">findInPath</span><span class="p">(</span><span class="nx">flameGraphScripts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">flameGraph</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errNoPerlScript</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">runScript</span><span class="p">(</span><span class="s">&#34;perl&#34;</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">flameGraph</span><span class="p">},</span> <span class="nx">args</span><span class="o">...</span><span class="p">),</span> <span class="nx">graphInput</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nf">runScript</span><span class="p">(</span><span class="nx">flameGraph</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">graphInput</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>安装go-wrk,使用<code>go get -v https://github.com/adjust/go-wrk</code>命令安装.</p>
<pre><code>$ go-wrk --help
Usage of go-wrk:
-CA string
        A PEM eoncoded CA's certificate file. (default &quot;someCertCAFile&quot;)
-H string
        the http headers sent separated by '\n' (default &quot;User-Agent: go-wrk 0.1 benchmark\nContent-Type: text/html;&quot;)
-b string
        the http request body
-c int
        the max numbers of connections used (default 100)
-cert string
        A PEM eoncoded certificate file. (default &quot;someCertFile&quot;)
-d string
        dist mode
-f string
        json config file
-i	TLS checks are disabled
-k	if keep-alives are disabled (default true)
-key string
        A PEM encoded private key file. (default &quot;someKeyFile&quot;)
-m string
        the http request method (default &quot;GET&quot;)
-n int
        the total number of calls processed (default 1000)
-p string
        the http request body data file
-r	in the case of having stream or file in the response,
        it reads all response body to calculate the response size
-s string
        if specified, it counts how often the searched string s is contained in the responses
-t int
        the numbers of threads used (default 1)
</code></pre></li>
<li>
<p>使用方式</p>
<ul>
<li>使用go-wrk压测,使用命令<code>go-wrk -n 50000 http://127.0.0.1:8080/*/*</code>在某个接口进行压测</li>
<li>使用go-torch收集数据,使用命令<code>go-torch -u http://127.0.0.1:8080 -t 30</code>,30秒之后终端会出现如下提示: <code>Writing svg to torch.svg</code>,然后使用浏览器打开<code>torch.svg</code>,就能看到火焰图.</li>
</ul>
</li>
<li>
<p>perf</p>
<ul>
<li>Linux下使用命令<code>perf record -a -g -p pid -- sleep 30</code>,对指定进程采样30秒.</li>
<li>使用命令<code>perf script -i ../perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl &gt; app.svg</code>,其中<code>../perf.data</code>为<code>perf record</code>生成的采样数据,然后切换到FlameGraph的目录来执行上述命令,就能得到火焰图了(<code>stackcollapse-perf.pl</code>脚本是合并调用栈信息,<code>flamegraph.pl</code>脚本是生成火焰图).</li>
</ul>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/Dr-wei/p/11742414.html">Go pprof性能调优</a>.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>记录cgo调用C实现的加解密静态库中遇到的问题</title>
			<link>https://shenbaise9527.com/golang/cgo/</link>
			<pubDate>Tue, 03 Nov 2020 21:35:24 +0800</pubDate>
			
			<guid>https://shenbaise9527.com/golang/cgo/</guid>
			<description>起因 公司有个公共的加解密库,供所有后端C++服务调用的,但最近要使用Go来实现个服务需要用到加解密,而Go并没有提供AES-256-ECB的</description>
			<content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>公司有个公共的加解密库,供所有后端C++服务调用的,但最近要使用Go来实现个服务需要用到加解密,而Go并没有提供AES-256-ECB的加解密库,所以决定用cgo来调用这个公共的加解密库.</p>
<h2 id="window">Window</h2>
<p>在window下加解密库是提供的DLL,用Go的<code>syscall.NewLazyDLL</code>可以非常方便的加载DLL,window下基本没有遇到障碍.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="c1">// MICrypt 接口.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MICrypt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">MIFreeSafeHandle</span>    <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetDecryptDataLen</span> <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetEncryptDataLen</span> <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MIGetSafeHandle</span>     <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MILoad</span>              <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MITransDecrypt</span>      <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
	<span class="nx">MITransEncrypt</span>      <span class="o">*</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">LazyProc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">lib</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">NewLazyDLL</span><span class="p">(</span><span class="s">&#34;crypto64.dll&#34;</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MICrypt</span><span class="p">{</span>
		<span class="nx">MIGetSafeHandle</span><span class="p">:</span>     <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetSafeHandle&#34;</span><span class="p">),</span>
		<span class="nx">MIFreeSafeHandle</span><span class="p">:</span>    <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIFreeSafeHandle&#34;</span><span class="p">),</span>
		<span class="nx">MIGetDecryptDataLen</span><span class="p">:</span> <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetDecryptDataLen&#34;</span><span class="p">),</span>
		<span class="nx">MIGetEncryptDataLen</span><span class="p">:</span> <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MIGetEncryptDataLen&#34;</span><span class="p">),</span>
		<span class="nx">MILoad</span><span class="p">:</span>              <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MILoad&#34;</span><span class="p">),</span>
		<span class="nx">MITransDecrypt</span><span class="p">:</span>      <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MITransDecrypt&#34;</span><span class="p">),</span>
		<span class="nx">MITransEncrypt</span><span class="p">:</span>      <span class="nx">lib</span><span class="p">.</span><span class="nf">NewProc</span><span class="p">(</span><span class="s">&#34;MITransEncrypt&#34;</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="c1">// 待加密字符串.
</span><span class="c1"></span>	<span class="nx">msg</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;I am test trans crypto!&#34;</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">MIGetSafeHandle</span><span class="p">.</span><span class="nf">Call</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MILoad</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">iLen</span> <span class="kt">int32</span>
	<span class="kd">var</span> <span class="nx">srcLen</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIGetEncryptDataLen</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">iLen</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iLen</span><span class="p">)</span>

	<span class="c1">// 加密.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">MITransEncrypt</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">iLen</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>

	<span class="nx">dstLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">iDLen</span> <span class="kt">int32</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIGetDecryptDataLen</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">iDLen</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>

	<span class="c1">// 再解密.
</span><span class="c1"></span>	<span class="nx">newSrc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iDLen</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MITransDecrypt</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newSrc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">newSrc</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">MIFreeSafeHandle</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="linux">Linux</h2>
<p>在Linux下加解密库提供的是静态库,调用方式完全不同于windows,碰到很多问题.</p>
<h3 id="不支持c中的引用">不支持C++中的引用<code>&amp;</code></h3>
<pre><code># aesecb
./aesecb.go:27:2: could not determine kind of name for C.MIGetDecryptDataLen
./aesecb.go:20:2: could not determine kind of name for C.MIGetEncryptDataLen
cgo: 
gcc errors for preamble:
In file included from ./aesecb.go:6:0:
/home/sky/code/imp/2nd/crypto/include/ISafeInterface.h:111:50: error: expected ';', ',' or ')' before '&amp;' token
 _DLL_EXP_API int32_t MIGetEncryptDataLen(int32_t &amp;iRevLen, const char *pData, int32_t iLen, intptr_t pSafeHandle);
</code></pre><p><strong>解决方案</strong>
把引用修改为指针</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">_DLL_EXP_API</span> <span class="kt">int32_t</span> <span class="nf">MIGetEncryptDataLen</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span> <span class="n">iRevLen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pData</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">iLen</span><span class="p">,</span> <span class="n">intptr_t</span> <span class="n">pSafeHandle</span><span class="p">);</span>
</code></pre></div><h3 id="undefined-reference">undefined reference</h3>
<pre><code>$ go build -x
WORK=/tmp/go-build163613860
mkdir -p $WORK/b001/
cd /home/sky/go/path/src/aesecb
CGO_LDFLAGS='&quot;-g&quot; &quot;-O2&quot; &quot;-L/home/sky/code/imp/2nd/cryptogo/lib/Linux_x86_64&quot; &quot;-lmism&quot; &quot;-lstdc++&quot;' /home/sky/go/go1.14/pkg/tool/linux_amd64/cgo -objdir $WORK/b001/ -importpath aesecb -- -I/h
ome/sky/code/imp/2nd/cryptogo/include -I $WORK/b001/ -g -O2 ./aesecb.gocd $WORK
gcc -fno-caret-diagnostics -c -x c - -o /dev/null || true
gcc -Qunused-arguments -c -x c - -o /dev/null || true
gcc -fdebug-prefix-map=a=b -c -x c - -o /dev/null || true
gcc -gno-record-gcc-switches -c -x c - -o /dev/null || true
cd $WORK/b001
TERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_x001.o -c _cgo_export.cTERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_x002.o -c aesecb.cgo2.cTERM='dumb' gcc -I /home/sky/go/path/src/aesecb -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -I/home/sky/code/imp/2nd/cryptogo
/include -I ./ -g -O2 -o ./_cgo_main.o -c _cgo_main.ccd /home/sky/go/path/src/aesecb
TERM='dumb' gcc -I . -fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=$WORK/b001=/tmp/go-build -gno-record-gcc-switches -o $WORK/b001/_cgo_.o $WORK/b001/_cgo_main.o $WORK/b001/_x00
1.o $WORK/b001/_x002.o -g -O2 -L/home/sky/code/imp/2nd/cryptogo/lib/Linux_x86_64 -lmism -lstdc++# aesecb
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetDecryptDataLen':
/tmp/go-build/cgo-gcc-prolog:69: undefined reference to `MIGetDecryptDataLen'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetEncryptDataLen':
/tmp/go-build/cgo-gcc-prolog:92: undefined reference to `MIGetEncryptDataLen'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIGetSafeHandle':
/tmp/go-build/cgo-gcc-prolog:109: undefined reference to `MIGetSafeHandle'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MILoad':
/tmp/go-build/cgo-gcc-prolog:131: undefined reference to `MILoad'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MITransDecrypt':
/tmp/go-build/cgo-gcc-prolog:156: undefined reference to `MITransDecrypt'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MITransEncrypt':
/tmp/go-build/cgo-gcc-prolog:181: undefined reference to `MITransEncrypt'
/tmp/go-build163613860/b001/_x002.o: In function `_cgo_2c40edecf6fd_Cfunc_MIFreeSafeHandle':
/tmp/go-build/cgo-gcc-prolog:49: undefined reference to `MIFreeSafeHandle'
collect2: error: ld returned 1 exit status
</code></pre><p>由于在编译加解密库mism时,是使用的g++编译器,编译出来的函数名会加上修饰符,导致cgo找不到对应的函数</p>
<pre><code># 查看符号表
$ nm libmism.a
...
0000000000000490 T _Z12MIMD5DecryptPcRiPKci
000000000000040f T _Z12MIMD5EncryptPcRiPKci
000000000000031f T _Z14MITransDecryptPciPKcil
00000000000002c9 T _Z14MITransEncryptPciPKcil
...
</code></pre><p>可以看到函数名已经发生变化了.</p>
<p><strong>解决方案</strong>
修改代码以C方式编译</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span>
<span class="p">{</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">......</span>
    <span class="n">_DLL_EXP_API</span> <span class="n">intptr_t</span> <span class="n">MIGetSafeHandle</span><span class="p">();</span>
<span class="p">......</span>
<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div><p>再次编译后,查看符号表,可以看到函数名没有发生变化.</p>
<pre><code>$ nm libmism.a
......
0000000000000040 T MIFreeSafeHandle
00000000000001d0 T MIGetDecryptDataLen
0000000000000190 T MIGetEncryptDataLen
0000000000000000 T MIGetSafeHandle
0000000000000070 T MILoad
0000000000000150 T MITransDecrypt
0000000000000110 T MITransEncrypt
......
</code></pre><h3 id="库依赖">库依赖</h3>
<p>继续编译,又报了undefined reference</p>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./libmism.a(AESEncryptHandle.cpp.o): In function `AESEncryptHandle::Encrypt(char*, int&amp;, char const*, int const&amp;)':
AESEncryptHandle.cpp:(.text+0x135): undefined reference to `EVP_aes_256_ecb'
AESEncryptHandle.cpp:(.text+0x145): undefined reference to `EVP_EncryptInit'
AESEncryptHandle.cpp:(.text+0x15c): undefined reference to `EVP_EncryptUpdate'
AESEncryptHandle.cpp:(.text+0x171): undefined reference to `EVP_EncryptFinal'
AESEncryptHandle.cpp:(.text+0x179): undefined reference to `EVP_CIPHER_CTX_cleanup'
./libmism.a(AESEncryptHandle.cpp.o): In function `AESEncryptHandle::Decrypt(char*, int&amp;, char const*, int const&amp;)':
AESEncryptHandle.cpp:(.text+0x215): undefined reference to `EVP_aes_256_ecb'
AESEncryptHandle.cpp:(.text+0x225): undefined reference to `EVP_DecryptInit'
AESEncryptHandle.cpp:(.text+0x23c): undefined reference to `EVP_DecryptUpdate'
AESEncryptHandle.cpp:(.text+0x251): undefined reference to `EVP_DecryptFinal'
AESEncryptHandle.cpp:(.text+0x259): undefined reference to `EVP_CIPHER_CTX_cleanup'
collect2: error: ld returned 1 exit status
</code></pre><p>这是加解密库是调用的openssl来实现的,而在go代码里只显示链接了加解密库</p>
<p><strong>解决方案</strong>
修改go代码,还要额外链接openssl的库.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="nx">cgo</span> <span class="nx">LDFLAGS</span><span class="p">:</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">2</span><span class="nx">nd</span><span class="o">/</span><span class="nx">crypto</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">openssl</span><span class="o">-</span><span class="nx">OpenSSL_1_0_2</span><span class="o">-</span><span class="nx">stable</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">lmism</span> <span class="o">-</span><span class="nx">lssl</span> <span class="o">-</span><span class="nx">lcrypto</span> <span class="o">-</span><span class="nx">lstdc</span><span class="o">++</span>
</code></pre></div><p>继续编译,又报了undefined reference</p>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_globallookup':
dso_dlfcn.c:(.text+0x11): undefined reference to `dlopen'
dso_dlfcn.c:(.text+0x24): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x2f): undefined reference to `dlclose'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_bind_func':
dso_dlfcn.c:(.text+0x354): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x412): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_bind_var':
dso_dlfcn.c:(.text+0x484): undefined reference to `dlsym'
dso_dlfcn.c:(.text+0x542): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_load':
dso_dlfcn.c:(.text+0x5a9): undefined reference to `dlopen'
dso_dlfcn.c:(.text+0x60d): undefined reference to `dlclose'
dso_dlfcn.c:(.text+0x645): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_pathbyaddr':
dso_dlfcn.c:(.text+0x6d1): undefined reference to `dladdr'
dso_dlfcn.c:(.text+0x731): undefined reference to `dlerror'
./libcrypto.a(dso_dlfcn.o): In function `dlfcn_unload':
dso_dlfcn.c:(.text+0x792): undefined reference to `dlclose'
collect2: error: ld returned 1 exit status
</code></pre><p>缺少ld引用.</p>
<p><strong>解决方案</strong>
修改go代码,还要额外链接ld的库.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="nx">cgo</span> <span class="nx">LDFLAGS</span><span class="p">:</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">2</span><span class="nx">nd</span><span class="o">/</span><span class="nx">crypto</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">L</span><span class="p">..</span><span class="o">/</span><span class="mi">3</span><span class="nx">rd</span><span class="o">/</span><span class="nx">openssl</span><span class="o">-</span><span class="nx">OpenSSL_1_0_2</span><span class="o">-</span><span class="nx">stable</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">Linux_x86_64</span> <span class="o">-</span><span class="nx">lmism</span> <span class="o">-</span><span class="nx">lssl</span> <span class="o">-</span><span class="nx">lcrypto</span> <span class="o">-</span><span class="nx">lstdc</span><span class="o">++</span> <span class="o">-</span><span class="nx">ldl</span>
</code></pre></div><h3 id="类型映射错误">类型映射错误</h3>
<pre><code>$ go build aesecb.go 
# command-line-arguments
./aesecb.go:16:10: assignment mismatch: 3 variables but _Cfunc_MIGetSafeHandle returns 1 values
./aesecb.go:17:18: cannot use uintptr(0) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MILoad
./aesecb.go:20:31: cannot use uintptr(unsafe.Pointer(&amp;iLen)) (type uintptr) as type *_Ctype_int in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:20:63: cannot use uintptr(unsafe.Pointer(&amp;msg[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:20:97: cannot use uintptr(srcLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MIGetEncryptDataLen
./aesecb.go:22:26: cannot use uintptr(unsafe.Pointer(&amp;buf[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:60: cannot use uintptr(iLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:75: cannot use uintptr(unsafe.Pointer(&amp;msg[0])) (type uintptr) as type *_Ctype_char in argument to _Cfunc_MITransEncrypt
./aesecb.go:22:109: cannot use uintptr(srcLen) (type uintptr) as type _Ctype_int in argument to _Cfunc_MITransEncrypt
./aesecb.go:27:31: cannot use uintptr(unsafe.Pointer(&amp;iDLen)) (type uintptr) as type *_Ctype_int in argument to _Cfunc_MIGetDecryptDataLen
./aesecb.go:27:31: too many errors
</code></pre><p>基本上都是用错了类型,参考类型映射来修改.</p>
<table>
<thead>
<tr>
<th style="text-align:left">C类型</th>
<th style="text-align:left">调用方法</th>
<th style="text-align:left">Go类型</th>
<th style="text-align:left">字节数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">C.char</td>
<td style="text-align:left">byte</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">signed char</td>
<td style="text-align:left">C.schar</td>
<td style="text-align:left">int8</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">C.uchar</td>
<td style="text-align:left">uint8</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">short int</td>
<td style="text-align:left">C.short</td>
<td style="text-align:left">int16</td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">short unsigned int</td>
<td style="text-align:left">C.ushort</td>
<td style="text-align:left">uint16</td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">C.int</td>
<td style="text-align:left">int</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">C.uint</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long int</td>
<td style="text-align:left">C.long</td>
<td style="text-align:left">int32 or int64</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long unsigned int</td>
<td style="text-align:left">C.ulong</td>
<td style="text-align:left">uint32 or uint64</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long long int</td>
<td style="text-align:left">C.longlong</td>
<td style="text-align:left">int64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">long long unsigned int</td>
<td style="text-align:left">C.ulonglong</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">C.float</td>
<td style="text-align:left">float32</td>
<td style="text-align:left">4</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">C.double</td>
<td style="text-align:left">float64</td>
<td style="text-align:left">8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">wchar_t</td>
<td style="text-align:left">C.wchar_t</td>
<td style="text-align:left"></td>
<td style="text-align:left">2</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">void *</td>
<td style="text-align:left">unsafe.Pointer</td>
<td style="text-align:left"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>最后完整代码如下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>                                     

<span class="cm">/*                                               
</span><span class="cm">#cgo CFLAGS: -I../2nd/crypto/include
</span><span class="cm">#cgo LDFLAGS: -L../2nd/crypto/lib/Linux_x86_64 -L../3rd/openssl-OpenSSL_1_0_2-stable/lib/Linux_x86_64 -lmism -lssl -lcrypto -lstdc++ -ldl                    
</span><span class="cm">#include &#34;ISafeInterface.h&#34;                      
</span><span class="cm">*/</span>                                               
<span class="kn">import</span> <span class="s">&#34;C&#34;</span>                                       
<span class="kn">import</span> <span class="p">(</span>                                         
    <span class="s">&#34;fmt&#34;</span>                                        
    <span class="s">&#34;unsafe&#34;</span>                                     
<span class="p">)</span>                                                

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>                                    
    <span class="nx">msg</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;I am test trans crypto!&#34;</span><span class="p">)</span>  
    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetSafeHandle</span><span class="p">()</span>                     
    <span class="nx">C</span><span class="p">.</span><span class="nf">MILoad</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>                   
    <span class="kd">var</span> <span class="nx">iLen</span> <span class="kt">int32</span>                               
    <span class="kd">var</span> <span class="nx">srcLen</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>                    
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetEncryptDataLen</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="nx">iLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">44</span><span class="p">)</span>                      
    <span class="nx">C</span><span class="p">.</span><span class="nf">MITransEncrypt</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">iLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">srcLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                             
                                                 
    <span class="nx">dstLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                           
    <span class="kd">var</span> <span class="nx">iDLen</span> <span class="kt">int32</span>                              
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIGetDecryptDataLen</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="nx">iDLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
                                                 
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">)</span>                           
    <span class="nx">newSrc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">iDLen</span><span class="p">)</span>                
    <span class="nx">C</span><span class="p">.</span><span class="nf">MITransDecrypt</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newSrc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">iDLen</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">int</span><span class="p">(</span><span class="nx">dstLen</span><span class="p">),</span> <span class="nx">h</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">newSrc</span><span class="p">))</span>                  
    <span class="nx">C</span><span class="p">.</span><span class="nf">MIFreeSafeHandle</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="go-tool-cgo">go tool cgo</h3>
<p>调用该命令会在当前目录生成_obj文件夹,在里面文件可以看到类型转换的信息.<a href="https://wiki.jikexueyuan.com/project/go-command-tutorial/0.13.html">参考命令</a></p>
<pre><code># sky @ localhost in ~/go/path/src/aesecb/_obj [11:33:09] 
$ ll 
total 48
drwxr-xr-x 2 sky sky 4096 Sep 10 11:32 .
drwxr-xr-x 3 sky sky   92 Sep 10 11:32 ..
-rw-r--r-- 1 sky sky 6264 Sep 10 11:32 _cgo_.o
-rw-r--r-- 1 sky sky  605 Sep 10 11:32 _cgo_export.c
-rw-r--r-- 1 sky sky 1547 Sep 10 11:32 _cgo_export.h
-rw-r--r-- 1 sky sky   13 Sep 10 11:32 _cgo_flags
-rw-r--r-- 1 sky sky 5427 Sep 10 11:32 _cgo_gotypes.go
-rw-r--r-- 1 sky sky  416 Sep 10 11:32 _cgo_main.c
-rw-r--r-- 1 sky sky 2020 Sep 10 11:32 aesecb.cgo1.go
-rw-r--r-- 1 sky sky 5710 Sep 10 11:32 aesecb.cgo2.c
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
